-零
    基础知识
        原型 原型链
        作用域 闭包
        异步 单线程
    JS API
        DOM操作
        Ajax
        事件绑定
    开发环境
        版本管理
        模块化
        打包工具
    运行环境
        页面渲染
        性能优化

一.JavaScript语法基础
    1.语言编码
        JavaScript语言建立在Unicode字符集基础之上，因此在脚本中，用户可以使用双字:符命名常量，变量或者函数等。但是考虑到JavaScript脚本嵌入到网页中，还是不建议用户使用中文命名。
    2.大小写敏感
        与html标签和css样式码不同，JavaScript对大小写是非常敏感的。为了避免出错，用户应该养成使用小写字符命名变量的习惯，对于保留字可以根据系统的默认大小写来输入，而对于特定的变量可以使用大写字符或者大写字符开头，如类，构造函数等。
    3.代码格式化
        JavaScript一般会忽略分隔符，如空格符，制表符合换行符。在保证不引起奇异的情况下，用户可以利用分隔符对脚本进行排版
    4.代码注释
        //和/**/
    5.标签
        在JavaScript中添加标签，方便JavaScript程序快速定位，标签一般由一个合法的字符名称加上一个冒号组成。标签可以放在任意行的起始位置，这样就可以为该行设置一个标签，然后在break和continue等语句调出循环结构。
            <script>
                loop:for(var j=1;j<6;j++)
                    {
                        if(j==2)continue loop;
                        document.write("<br>"+j);
                    }
            </script>
    6.关键字和保留字
        关键字
            break case catch continue default delete do else finallly for function if in instanceof new return switch this throw try typeof var void while with
        保留字
            abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile
    7.常量和变量
        JavaScript暂时不支持constant关键字，不允许用户自定义常量，但是提供几个默认的常量供开发者使用：
            常量                    描述                                                        JavaScript 对象
            E                       数学常量 e。  这是欧拉数，即自然对数的底。                          Math
            Infinity                一个大于最大浮点数的值。  负无穷大 (-Infinity) 小于最小浮点数。     Global
            LN2                     2 的自然对数。                                                  Math
            LN10                    10 的自然对数。                                                 Math
            LOG2E                   e 的以 2 为底的对数。                                           Math
            LOG10E                  e 的以 10 为底的对数。                                          Math
            MAX_VALUE               可在 JavaScript 中表示的最大数字。                              Number
            MIN_VALUE               可在 JavaScript 中表示的最接近零的数字。                        Number
            NaN                     表示算术表达式返回了非数字值。                                  Number
            NaN（全局）              一个指示表达式不是数字的值。                                   Global
            NEGATIVE_INFINITY       一个小于最小浮点数的值。                                        Number
            null                    常量 (JavaScript)  不指向有效数据的变量值。                     Global
            PI                      Pi.  这是圆的周长与直径的比率。                                  Math
            POSITIVE_INFINITY       一个大于最大浮点数的值。                                        Number
            SQRT1_2                 0.5 的平方根或相等项（即 2 的平方根分之一）。                     Math
            SQRT2                   2 的平方根。                                                    Math
            未定义                  已声明但未初始化的变量的值。                                     Global
            NaN 属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。
        JavaScript使用var关键字声明变量。
            var a;
            var a,b;
            var c=1;
            var a=1,b=2;
            var a=s=2;
    8.表达式和运算符
        表达式
            this
                this关键字被用于指代当前的对象，通常，this指代的是方法中正在被调用的对象。用法如下：
                    this["propertyName"]
                    this.propertyName
                假设一个用于验证对象value属性的validate函数，传参有对象，最高值和最低值。
                    function validate(obj, lowval, hival){
                    if ((obj.value < lowval) || (obj.value > hival))
                        console.log("Invalid Value!");
                    }
                你可以在任何表单元素的onchange事件处理中调用validat函数，用this来指代当前的表单元素，用例如下：
                    <p>Enter a number between 18 and 99:</p>
                    <input type="text" name="age" size=3 onChange="validate(this, 18, 99);">
            数值推导
                Comprehensions 是一个带有实验性质的JavaScript特性, 计划将在未来的ECMAScript版本中加入该特性. 有两种类型的comprehensions:
                    [for (x of y) x]
                    数列数值推导 （非标准用法）
                    (for (x of y) y)
                    生成器数值推导 （注：生成器数值推导标准化可能不大，推荐使用 生成器函数）
                Comprehensions特性被许多编程语言所采用，该特性能够使你快速地通过一个已有的数组来创建出一个新的数组，比如：
                    [for (i of [ 1, 2, 3 ]) i*i ]; 
                    // [ 1, 4, 9 ]
                    var abc = [ "A", "B", "C" ];
                    [for (letters of abc) letters.toLowerCase()];
                    // [ "a", "b", "c" ]
            左值表达式
                左值可以作为赋值的目标。
                new
                    你可以使用new operator 创建一个自定义类型或者是预置类型的对象实例。用法如下：
                    var objectName = new objectType([param1, param2, ..., paramN]);
                super
                    super 关键字可以用来调用一个对象父类的函数，它在用来调用一个类的父类的构造函数时非常有用，比如：
                    super([arguments]); // calls the parent constructor. super.functionOnParent([arguments]);调用父构造函数。 super.functionOnParent（[参数]）;
                扩展语句(...)
                    扩展语句符允许一个表达式在原地展开， 当需要多个参数 (比如函数调用时) 或者多个值(比如字面量数组) 。
                    例如：现在你有一个数组，你想创建一个新数组，并将刚才那个作为它的一部分，用array的字面语法是不够的，你不得不写一些代码实现它，比如用些push, splice, concat等等。但是用spread syntax就没问题了：
                        var parts = ['shoulder', 'knees'];
                        var lyrics = ['head', ...parts, 'and', 'toes'];
                    类似的，扩展语句也可以用在函数调用的时候:
                        function f(x, y, z) { }
                        var args = [0, 1, 2];
                        f(...args);
                    eg:
                        computed:{
                            // ...mapGetters(['test']),
                            // ...fn(['a','b','d','c'])
                            // // 3点扩展运算符，实现了将对象展开并且合并到新的对象里，这里即是向computed对象里混入一个新的对象test，然后便于使用this.test
                        },
        位运算符：
            位运算符将它的操作数视为32位元的二进制串（0和1组成）而非十进制八进制或十六进制数。例如：十进制数字9用二进制表示为1001，位运算符就是在这个二进制表示上执行运算，但是返回结果是标准的JavaScript数值。
            Operator	                 Usage	                Description
            按位与 AND	                 a & b	        在a,b的位表示中，每一个对应的位都为1则返回1， 否则返回0.
            按位或 OR	                 a | b	        在a,b的位表示中，每一个对应的位，只要有一个为1则返回1， 否则返回0.
            按位异或 XOR	             a ^ b	        在a,b的位表示中，每一个对应的位，两个不相同则返回1，相同则返回0.
            按位非 NOT	                 ~ a	        反转被操作数的位。
            左移 shift                   a << b	        将a的二进制串向左移动b位,右边移入0.
            算术右移	                 a >> b	        把a的二进制表示向右移动b位，丢弃被移出的所有位.(译注:算术右移左边空出的位是根据最高位是0和1来进行填充的)
            无符号右移(左边空出位用0填充)  a >>> b        把a的二进制表示向右移动b位，丢弃被移出的所有位，并把左边空出的位都填充为0
        比较运算符：
            比较运算符比较它的操作数并返回一个基于表达式是否为真的逻辑值。操作数可以是数字，字符串，逻辑，对象值。字符串比较是基于标准的字典顺序，使用Unicode值。在多数情况下，如果两个操作数不是相同的类型， JavaScript 会尝试转换它们为恰当的类型来比较。这种行为通常发生在数字作为操作数的比较。类型转换的例外是使用 === 和 !== 操作符，它们会执行严格的相等和不相等比较。这些运算符不会在检查相等之前转换操作数的类型。
            运算符	                            描述	                                  返回true的示例
            等于 Equal (==)	                    如果两边操作数相等时返回true。              3 == var1 "3" == var1 3 == '3'
            不等于 Not equal (!=)	            如果两边操作数不相等时返回true	            var1 != 4var2 != "3"
            全等 Strict equal (===)	            两边操作数相等且类型相同时返回true。        参见 Object.is and sameness in JS.	3 === var1
            不全等 Strict not equal (!==)	    两边操作数不相等或类型不同时返回true。	     var1 !== "3"3 !== '3'
            大于 Greater than (>)	            左边的操作数大于右边的操作数返回true	    var2 > var1 "12" > 2
            大于等于 Greater than or equal (>=)	左边的操作数大于或等于右边的操作数返回true	 var2 >= var1 var1 >= 3
            小于 Less than (<)	                左边的操作数小于右边的操作数返回true	    var1 < var2 "2" < 12
            小于等于 Less than or equal (<=)	左边的操作数小于或等于右边的操作数返回true	 var1 <= var2 var2 <= 5
            注意: （=>） 不是运算符，而是箭头函数的标记符号 。
        字符串运算符：
            除了比较操作符，它可以在字符串值中使用，连接操作符（+）连接两个字符串值相连接，返回另一个字符串，它是两个操作数串的结合。
        条件（三元）运算符：
            条件运算符是JavaScript中唯一需要三个操作数的运算符。运算的结果根据给定条件在两个值中取其一。语法为：
            条件 ? 值1 : 值2
                如果条件为真，则结果取值1。否则为值2。你能够在任何允许使用标准运算符的地方使用条件运算符。
            例如，
                var status = (age >= 18) ? "adult" : "minor";
                当 age 大于等于18的时候，将“adult”赋值给 status；否则将“minor”赋值给 status。
        逗号操作符
            逗号操作符（,）对两个操作数进行求值并返回最终操作数的值。它常常用在 for 循环中，在每次循环时对多个变量进行更新。
                例如，假如 a 是一个二维数组，每个维度各有10个元素，以下代码利用逗号操作符来同时改变两个变量的值。这段代码的功能是打印出该二维数组的对角线元素的值：
                    var x = [0,1,2,3,4,5,6,7,8,9]
                    var a = [x, x, x, x, x];
                    for (var i = 0, j = 9; i <= j; i++, j--)
                        console.log('a[' + i + '][' + j + ']= ' + a[i][j]);
        一元操作符:
            一元操作符仅对应一个操作数。
            delete
                delete操作符，删除一个对象或一个对象的属性或者一个数组中某一个键值。语法如下:
                    delete objectName;
                    delete objectName.property;
                    delete objectName[index];
                    delete property; // legal only within a with statement
                    objectName是一个对象名，property 是一个已经存在的属性，index是数组中的一个已经存在的键值的索引值。
                        第四行的形式只在with声明的状态下是合法的， 从对象中删除一个属性。
                        你能使用 delete 删除各种各样的隐式声明， 但是被var声明的除外。
                        如果 delete 操作成功，属性或者元素会变成 undefined。如果 delete可行会返回true，如果不成功返回false。
                        x = 42;
                        var y = 43;
                        myobj = new Number();
                        myobj.h = 4;    // create property h
                        delete x;       // returns true (can delete if declared implicitly)
                        delete y;       // returns false (cannot delete if declared with var)
                        delete Math.PI; // returns false (cannot delete predefined properties)
                        delete myobj.h; // returns true (can delete user-defined properties)
                        delete myobj;   // returns true (can delete if declared implicitly)
                删除数组元素
                    删除数组中的元素时，数组的长度是不变的，例如删除a[3], a[4]，a[4]和a[3] 仍然存在变成了undefined。
                    delete 删除数组中的一个元素，这个元素就不在数组中了。例如，trees[3]被删除，trees[3] 仍然可寻址并返回undefined。
                        var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
                        delete trees[3];
                        if (3 in trees) {
                        // 不会被执行
                        }
                        如果想让数组中存在一个元素但是是undefined值，使用undefined关键字而不是delete操作. 如下： trees[3]分配一个undefined,但是这个数组元素仍然存在:
                        var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
                        trees[3] = undefined;
                        if (3 in trees) {
                        // this gets executed（会被执行）
                        } 
            typeof
                typeof操作符 可通过下面2种方式使用：
                    typeof operand
                    typeof (operand)
                    typeof 操作符返回一个表示 operand 类型的字符串值。operand 可为字符串、变量、关键词或对象，其类型将被返回。operand 两侧的括号为可选。
                    假设你定义了如下的变量：
                    var myFun = new Function("5 + 2");
                    var shape = "round";
                    var size = 1;
                    var today = new Date();
                    typeof 操作符将会返回如下的结果：
                        typeof myFun;     // returns "function"
                        typeof shape;     // returns "string"
                        typeof size;      // returns "number"
                        typeof today;     // returns "object"
                        typeof dontExist; // returns "undefined"
                    对于关键词 true 和 null， typeof 操作符将会返回如下结果：
                        typeof true;    // returns "boolean"
                        typeof null;    // returns "object"
                    对于一个数值或字符串， typeof 操作符将会返回如下结果：
                        typeof 62;            // returns "number"
                        typeof 'Hello world'; // returns "string"
                    对于属性值，typeof 操作符将会返回属性所包含值的类型：
                        typeof document.lastModified; // returns "string"
                        typeof window.length;         // returns "number"
                        typeof Math.LN2;              // returns "number"
                    对于方法和函数，typeof 操作符将会返回如下结果：
                        typeof blur;        // returns "function"
                        typeof eval;        // returns "function"
                        typeof parseInt;    // returns "function"
                        typeof shape.split; // returns "function"
                    对于预定义的对象，typeof 操作符将会返回如下结果：
                        typeof Date;     // returns "function"
                        typeof Function; // returns "function"
                        typeof Math;     // returns "object"
                        typeof Option;   // returns "function"
                        typeof String;   // returns "function"
            void
                void 运算符运用方法如下：
                    void (expression)
                    void expression
                    void运算符,表明一个运算没有返回值。expression是javaScript表达式，括号中的表达式是一个可选项，当然使用该方式是一种好的形式。
                    你可以使用void运算符指明一个超文本链接。该表达式是有效的，但是并不会在当前文档中进行加载。
                    如下创建了一个超链接文本，当用户单击该文本时，不会有任何效果。
                        <a href="javascript:void(0)">Click here to do nothing</a>
                    下面的代码创建了一个超链接，当用户单击它时，提交一个表单。
                        <a href="javascript:void(document.form.submit())">
                        Click here to submit</a>
        关系操作符:
            关系操作符对操作数进行比较，根据比较结果真或假，返回相应的布尔值。
            in
                in操作符，如果所指定的属性确实存在于所指定的对象中，则会返回true，语法如下：
                propNameOrNumber in objectName
                在这里 propNameOrNumber可以是一个代表着属性名的字符串或者是一个代表着数组索引的数值表达式，而objectName则是一个对象名。
                下面的例子是 in 操作的常见用法。
                // Arrays(数组)
                    var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
                    0 in trees;        // returns true
                    3 in trees;        // returns true
                    6 in trees;        // returns false
                    "bay" in trees;    // returns false (you must specify the index number,
                                    // not the value at that index)你必须指定索引号，
                                    //不是该索引的值
                    "length" in trees; // returns true (length is an Array property (length是一个Array属性))
                // Predefined objects(预定义的对象)
                    "PI" in Math;          // returns true
                    var myString = new String("coral");
                    "length" in myString;  // returns true
                // Custom objects(自定义对象)
                    var mycar = {make: "Honda", model: "Accord", year: 1998};
                    "make" in mycar;  // returns true
                    "model" in mycar; // returns true
            instanceof
                如果所判别的对象确实是所指定的类型，则返回true。其语法如下：
                objectName instanceof objectType
                objectName 是需要做判别的对象的名称,而objectType是假定的对象的类型, 例如Date或 Array.
                当你需要确认一个对象在运行时的类型时，可使用instanceof. 例如，需要 catch 异常时，你可以针对抛出异常的类型，来做不同的异常处理。
                例如, 下面的代码使用instanceof去判断 theDay是否是一个 Date 对象. 因为theDay是一个Date对象, 所以if中的代码会执行.
                    var theDay = new Date(1995, 12, 17);
                    if (theDay instanceof Date) {
                    // statements to execute要执行的语句
                    }
        Set
            语法:
                new Set([iterable]);
            参数:
                iterable
                如果传递一个可迭代对象，它的所有元素将不重复地被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。
            返回值:
                一个新的Set对象。
            简述:
                Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。
            值的相等:
                因为 Set 中的值总是唯一的，所以需要判断两个值是否相等。在ECMAScript规范的早期版本中，这不是基于和===操作符中使用的算法相同的算法。具体来说，对于 Set s， +0 （+0 严格相等于-0）和-0是不同的值。然而，在 ECMAScript 2015规范中这点已被更改。有关详细信息，请参阅浏览器兼容性 表中的“value equality for -0 and 0”。
                另外，NaN和undefined都可以被存储在Set 中， NaN之间被视为相同的值（尽管 NaN !== NaN）。
            属性:
                Set.length
                    length属性的值为0。
                get Set[@@species]
                    构造函数用来创建派生对象.
                Set.prototype
                    表示Set构造器的原型，允许向所有Set对象添加新的属性。
            Set实例:
            所有Set实例继承自 Set.prototype。
            属性:
                Set.prototype.constructor
                    返回实例的构造函数。默认情况下是Set。
                Set.prototype.size
                    返回Set对象的值的个数。
            方法:
                Set.prototype.add(value)
                    在Set对象尾部添加一个元素。返回该Set对象。
                Set.prototype.clear()
                    移除Set对象内的所有元素。
                Set.prototype.delete(value)
                    移除Set的中与这个值相等的元素，返回Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回true，否则返回false）。Set.prototype.has(value)在此后会返回false。
                Set.prototype.entries()
                    返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。
                Set.prototype.forEach(callbackFn[, thisArg])
                    按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。
                Set.prototype.has(value)
                    返回一个布尔值，表示该值在Set中存在与否。
                Set.prototype.keys()
                    与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。
                Set.prototype.values()
                    返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。
                Set.prototype[@@iterator]()
                    返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。
            示例:
                使用Set对象:
                    let mySet = new Set();
                    mySet.add(1); // Set(1) {1}
                    mySet.add(5); // Set(2) {1, 5}
                    mySet.add(5); // Set { 1, 5 }
                    mySet.add("some text"); // Set(3) {1, 5, "some text"}
                    var o = {a: 1, b: 2};
                    mySet.add(o);
                    mySet.add({a: 1, b: 2}); // o 指向的是不同的对象，所以没问题
                    mySet.has(1); // true
                    mySet.has(3); // false
                    mySet.has(5);              // true
                    mySet.has(Math.sqrt(25));  // true
                    mySet.has("Some Text".toLowerCase()); // true
                    mySet.has(o); // true
                    mySet.size; // 5
                    mySet.delete(5);  // true,  从set中移除5
                    mySet.has(5);     // false, 5已经被移除
                    mySet.size; // 4, 刚刚移除一个值
                    console.log(mySet); // Set {1, "some text", Object {a: 1, b: 2}, Object {a: 1, b: 2}}
            迭代Set:
                // 迭代整个set
                // 按顺序输出：1, "some text" 
                    for (let item of mySet) console.log(item);
                // 按顺序输出：1, "some text" 
                    for (let item of mySet.keys()) console.log(item);
                // 按顺序输出：1, "some text" 
                    for (let item of mySet.values()) console.log(item);
                // 按顺序输出：1, "some text" 
                //(键与值相等)
                    for (let [key, value] of mySet.entries()) console.log(key);
                // 转换Set为Array 
                    var myArr = Array.from(mySet); // [1, "some text"]
                // 如果在HTML文档中工作，也可以：
                    mySet.add(document.body);
                    mySet.has(document.querySelector("body")); // true
                // Set 和 Array互换
                    mySet2 = new Set([1,2,3,4]);
                    mySet2.size; // 4
                    [...mySet2]; // [1,2,3,4]
                // intersect can be simulated via 
                    var intersection = new Set([...set1].filter(x => set2.has(x)));
                // difference can be simulated via
                    var difference = new Set([...set1].filter(x => !set2.has(x)));
                // 用forEach迭代
                    mySet.forEach(function(value) {
                    console.log(value);
                });
                    // 1
                    // 2
                    // 3
                    // 4
            实现基本集合操作:
                function isSuperset(set, subset) {
                    for (var elem of subset) {
                        if (!set.has(elem)) {
                            return false;
                        }
                    }
                    return true;
                }
                function union(setA, setB) {
                    var _union = new Set(setA);
                    for (var elem of setB) {
                        _union.add(elem);
                    }
                    return _union;
                }
                function intersection(setA, setB) {
                    var _intersection = new Set();
                    for (var elem of setB) {
                        if (setA.has(elem)) {
                            _intersection.add(elem);
                        }
                    }
                    return _intersection;
                }
                function difference(setA, setB) {
                    var _difference = new Set(setA);
                    for (var elem of setB) {
                        _difference.delete(elem);
                    }
                    return _difference;
                }
                //Examples
                var setA = new Set([1, 2, 3, 4]),
                    setB = new Set([2, 3]),
                    setC = new Set([3, 4, 5, 6]);

                isSuperset(setA, setB); // => true
                union(setA, setC); // => Set [1, 2, 3, 4, 5, 6]
                intersection(setA, setC); // => Set [3, 4]
                difference(setA, setC); // => Set [1, 2]
                Array 相关:
                var myArray = ["value1", "value2", "value3"];
                // 用Set构造器将Array转换为Set
                var mySet = new Set(myArray);

                mySet.has("value1"); // returns true

                // 用...(展开操作符)操作符将Set转换为Array
                console.log([...mySet]); // 与myArray完全一致
                String 相关:
                var text = 'Indiana';

                var mySet = new Set(text);  // Set {'I', 'n', 'd', 'i', 'a'}
                mySet.size;  // 5
            数组去重:
                // Use to remove duplicate elements from the array 
                const numbers = [2,3,4,4,2,3,3,4,4,5,5,6,6,7,5,32,3,4,5]
                console.log([...new Set(numbers)]) 
                // [2, 3, 4, 5, 6, 7, 32]    
        map
            Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。
            语法:
                new Map([iterable])
            参数:
                iterable
                Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, 'one' ],[ 2, 'two' ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。
            描述:
                一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个  for...of 循环在每次迭代后会返回一个形式为[key，value]的数组。
            键的相等(Key equality):
                键的比较是基于 "SameValueZero" 算法：NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。在目前的ECMAScript规范中，-0和+0被认为是相等的，尽管这在早期的草案中并不是这样。有关详细信息，请参阅浏览器兼容性 表中的“Value equality for -0 and 0”。
            Objects 和 maps 的比较:
                Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择：
                一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。
                Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。
                你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。
                Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。
                Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。
                Map 在涉及频繁增删键值对的场景下会有些性能优势。
            属性:
                Map.length
                    属性 length 的值为 0 。
                get Map[@@species]
                    本构造函数用于创建派生对象。
                Map.prototype
                    表示 Map 构造器的原型。 允许添加属性从而应用于所有的 Map 对象。
                Map 实例:
                    所有的 Map 对象实例都会继承 Map.prototype。
            属性:
                Map.prototype.constructor
                    返回一个函数，它创建了实例的原型。默认是Map函数。
                Map.prototype.size
                    返回Map对象的键/值对的数量。
            方法:
                Map.prototype.clear()
                    移除Map对象的所有键/值对 。
                Map.prototype.delete(key)
                    如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false
                Map.prototype.entries()
                    返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。
                Map.prototype.forEach(callbackFn[, thisArg])
                    按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。
                Map.prototype.get(key)
                    返回键对应的值，如果不存在，则返回undefined。
                Map.prototype.has(key)
                    返回一个布尔值，表示Map实例是否包含键对应的值。
                Map.prototype.keys()
                    返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。
                Map.prototype.set(key, value)
                    设置Map对象中键的值。返回该Map对象。
                Map.prototype.values()
                    返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。
                Map.prototype[@@iterator]()
                    返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。
            示例:
                使用 Map 对象:
                    var myMap = new Map();
                    var keyObj = {},
                        keyFunc = function () {},
                        keyString = "a string";            
                // 添加键
                    myMap.set(keyString, "和键'a string'关联的值");
                    myMap.set(keyObj, "和键keyObj关联的值");
                    myMap.set(keyFunc, "和键keyFunc关联的值");    
                    myMap.size; // 3
                // 读取值
                    myMap.get(keyString);    // "和键'a string'关联的值"
                    myMap.get(keyObj);       // "和键keyObj关联的值"
                    myMap.get(keyFunc);      // "和键keyFunc关联的值"
                    
                    myMap.get("a string");   // "和键'a string'关联的值"
                                            // 因为keyString === 'a string'
                    myMap.get({});           // undefined, 因为keyObj !== {}
                    myMap.get(function() {}) // undefined, 因为keyFunc !== function () {}
                将 NaN 作为 Map 的键:
                    NaN 也可以作为Map对象的键。虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，但下面的例子表明，NaN作为Map的键来说是没有区别的:
                        var myMap = new Map();
                        myMap.set(NaN, "not a number");
                        myMap.get(NaN); // "not a number"
                        var otherNaN = Number("foo");
                        myMap.get(otherNaN); // "not a number"
                使用 for..of 方法迭代 Map:
                    Map可以使用for..of循环来实现迭代：
                    var myMap = new Map();
                    myMap.set(0, "zero");
                    myMap.set(1, "one");
                    for (var [key, value] of myMap) {
                    console.log(key + " = " + value);
                    }
                        // 将会显示两个log。一个是"0 = zero"另一个是"1 = one"
                    for (var key of myMap.keys()) {
                    console.log(key);
                    }
                        // 将会显示两个log。 一个是 "0" 另一个是 "1"
                    for (var value of myMap.values()) {
                    console.log(value);
                    }
                        // 将会显示两个log。 一个是 "zero" 另一个是 "one"
                    for (var [key, value] of myMap.entries()) {
                    console.log(key + " = " + value);
                    }
                        // 将会显示两个log。 一个是 "0 = zero" 另一个是 "1 = one"
                使用 forEach() 方法迭代 Map:
                    Map也可以通过forEach()方法迭代：
                    myMap.forEach(function(value, key) {
                    console.log(key + " = " + value);
                    })
                        // 将会显示两个logs。 一个是 "0 = zero" 另一个是 "1 = one"
            Map 与数组的关系:
                var kvArray = [["key1", "value1"], ["key2", "value2"]];
                // 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象
                    var myMap = new Map(kvArray);
                    myMap.get("key1"); // 返回值为 "value1"
                // 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组
                    console.log(Array.from(myMap)); // 输出和kvArray相同的数组
                // 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组
                    console.log(Array.from(myMap.keys())); // 输出 ["key1", "key2"]
            复制或合并 Maps:
                Map 能像数组一样被复制：
                    var original = new Map([
                    [1, 'one']
                    ]);
                    var clone = new Map(original);
                    console.log(clone.get(1)); // one
                    console.log(original === clone); // false. Useful for shallow comparison
                    请记住，数据本身未被克隆。
                Map对象间可以进行合并，但是会保持键的唯一性。
                    var first = new Map([
                    [1, 'one'],
                    [2, 'two'],
                    [3, 'three'],
                    ]);
                    var second = new Map([
                    [1, 'uno'],
                    [2, 'dos']
                    ]);
                    // 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。
                    // 展开运算符本质上是将Map对象转换成数组。
                    var merged = new Map([...first, ...second]);
                    console.log(merged.get(1)); // uno
                    console.log(merged.get(2)); // dos
                    console.log(merged.get(3)); // three
                Map对象也能与数组合并：
                    var first = new Map([
                    [1, 'one'],
                    [2, 'two'],
                    [3, 'three'],
                    ]);
                    var second = new Map([
                    [1, 'uno'],
                    [2, 'dos']
                    ]);
                    // Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。
                    var merged = new Map([...first, ...second, [1, 'eins']]);
                    console.log(merged.get(1)); // eins
                    console.log(merged.get(2)); // dos
                    console.log(merged.get(3)); // three
        let
            let 命令
                基本用法
                    ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。
                        {
                        let a = 10;
                        var b = 1;
                        }
                        a // ReferenceError: a is not defined.
                        b // 1
                            上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。
                    for循环的计数器，就很合适使用let命令。
                        for (let i = 0; i < 10; i++) {
                        // ...
                        }
                        console.log(i);
                        // ReferenceError: i is not defined
                        上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。
                    下面的代码如果使用var，最后输出的是10。
                        var a = [];
                        for (var i = 0; i < 10; i++) {
                            a[i] = function () {
                                console.log(i);
                            };
                        }
                        a[6](); // 10
                        上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。
                    如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。
                        var a = [];
                        for (let i = 0; i < 10; i++) {
                        a[i] = function () {
                            console.log(i);
                        };
                        }
                        a[6](); // 6
                        上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。
                    另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
                        for (let i = 0; i < 3; i++) {
                        let i = 'abc';
                        console.log(i);
                        }
                        // abc
                        // abc
                        // abc
                        上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。
                        不存在变量提升
                    var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。
                    为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。
                        // var 的情况
                            console.log(foo); // 输出undefined
                            var foo = 2;
                        // let 的情况
                            console.log(bar); // 报错ReferenceError
                            let bar = 2;
                        上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。
                暂时性死区
                    只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
                        var tmp = 123;
                        if (true) {
                        tmp = 'abc'; // ReferenceError
                        let tmp;
                        }
                        上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。
                    ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
                    总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
                        if (true) {
                        // TDZ开始
                        tmp = 'abc'; // ReferenceError
                        console.log(tmp); // ReferenceError
                        let tmp; // TDZ结束
                        console.log(tmp); // undefined
                        tmp = 123;
                        console.log(tmp); // 123
                        }
                        上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。
                    “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。
                        typeof x; // ReferenceError
                        let x;
                        上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。
                        作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。
                            typeof undeclared_variable // "undefined"
                            上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。
                    有些“死区”比较隐蔽，不太容易发现。
                        function bar(x = y, y = 2) {
                            return [x, y];
                        }
                        bar(); // 报错
                        上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。
                        function bar(x = 2, y = x) {
                        return [x, y];
                        }
                        bar(); // [2, 2]
                        另外，下面的代码也会报错，与var的行为不同。
                        // 不报错
                        var x = x;
                        // 报错
                        let x = x;
                        // ReferenceError: x is not defined
                        上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。
                    ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。
                    总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
                不允许重复声明
                    let不允许在相同作用域内，重复声明同一个变量。
                        // 报错
                        function func() {
                        let a = 10;
                        var a = 1;
                        }
                        // 报错
                        function func() {
                        let a = 10;
                        let a = 1;
                        }
                        因此，不能在函数内部重新声明参数。
                        function func(arg) {
                        let arg;
                        }
                        func() // 报错
                        function func(arg) {
                        {
                            let arg;
                        }
                        }
                        func() // 不报错
                块级作用域
                    为什么需要块级作用域？
                    ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。
                    第一种场景，内层变量可能会覆盖外层变量。
                        var tmp = new Date();
                        function f() {
                            console.log(tmp);
                            if (false) {
                                var tmp = 'hello world';
                            }
                        }
                        f(); // undefined
                        上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。
                    第二种场景，用来计数的循环变量泄露为全局变量。
                        var s = 'hello';
                        for (var i = 0; i < s.length; i++) {
                        console.log(s[i]);
                        }
                        console.log(i); // 5
                        上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。
                    ES6 的块级作用域
                        let实际上为 JavaScript 新增了块级作用域。
                            function f1() {
                            let n = 5;
                            if (true) {
                                let n = 10;
                            }
                            console.log(n); // 5
                            }
                            上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。
                    ES6 允许块级作用域的任意嵌套。
                        {{{{
                        {let insane = 'Hello World'}
                        console.log(insane); // 报错
                        }}}};
                        上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。
                        内层作用域可以定义外层作用域的同名变量。
                        {{{{
                        let insane = 'Hello World';
                        {let insane = 'Hello World'}
                        }}}};
                        块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。
                        // IIFE 写法
                        (function () {
                        var tmp = ...;
                        ...
                        }());
                        // 块级作用域写法
                        {
                        let tmp = ...;
                        ...
                        }
                        块级作用域与函数声明
                        函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。
                        ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
        const
            常量是块级作用域，很像使用 let 语句定义的变量。常量的值不能通过重新赋值来改变，并且不能重新声明。
            语法:
                const name1 = value1 [, name2 = value2 [, ... [, nameN = valueN]]];
            nameN
                常量名称，可以是任意合法的标识符。
            valueN
                常量值，可以是任意合法的表达式。
            描述:
                此声明创建一个常量，其作用域可以是全局或本地声明的块。 与var变量不同，全局常量不会变为窗口对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。
                const声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。
            关于“暂存死区”的所有讨论都适用于let和const。
                一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。
            示例:
                下面的例子演示了常量的特性。在浏览器的控制台试一下这个例子。
                // 注意: 常量在声明的时候可以使用大小写，但通常情况下全部用大写字母。 
                // 定义常量MY_FAV并赋值7
                    const MY_FAV = 7;
                // 报错
                    MY_FAV = 20;
                // 输出 7
                    console.log("my favorite number is: " + MY_FAV);
                // 尝试重新声明会报错 
                    const MY_FAV = 20;
                //  MY_FAV 保留给上面的常量，这个操作会失败
                    var MY_FAV = 20; 
                // 也会报错
                    let MY_FAV = 20;
                // 注意块范围的性质很重要
                    if (MY_FAV === 7) { 
                        // 没问题，并且创建了一个块作用域变量 MY_FAV
                        // (works equally well with let to declare a block scoped non const variable)
                        let MY_FAV = 20;
                        // MY_FAV 现在为 20
                        console.log('my favorite number is ' + MY_FAV);
                        // 这被提升到全局上下文并引发错误
                        var MY_FAV = 20;
                    }
                // MY_FAV 依旧为7
                    console.log("my favorite number is " + MY_FAV);
                // 常量要求一个初始值
                    const FOO; // SyntaxError: missing = in const declaration
                // 常量可以定义成对象
                    const MY_OBJECT = {"key": "value"};
                // 重写对象和上面一样会失败
                    MY_OBJECT = {"OTHER_KEY": "value"};
                // 对象属性并不在保护的范围内，下面这个声明会成功执行
                    MY_OBJECT.key = "otherValue";
                // 也可以用来定义数组
                    const MY_ARRAY = [];
                    // It's possible to push items into the array
                // 可以向数组填充数据
                    MY_ARRAY.push('A'); // ["A"]
                // 但是，将一个新数组赋给变量会引发错误
                    MY_ARRAY = ['B']
        date
            创建一个 JavaScript Date 实例，该实例呈现时间中的某个时刻。Date 对象则基于 Unix Time Stamp，即自1970年1月1日（UTC）起经过的毫秒数。
            实例化Date对象:
            创建一个新Date对象的唯一方法是通过new 操作符：
                let now = new Date();
                只能将 Date 作为构造函数调用，才能实例化（instantiate） Date 对象：若将它作为常规函数调用（即不加 new 操作符），则将会返回一个字符串，而非 Date 对象。另外，不像其他的 JavaScript 对象类型，Date 对象没有字面量语法（literal syntax）。
            语法:
                new Date();
                new Date(value);
                new Date(dateString);
                new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);
            参数:
                注意 参数monthIndex 是从“0”开始计算的，这就意味着一月份为“0”，十二月份为“11”。
                注意：当Date作为构造函数调用并传入多个参数时，如果数值大于合理范围时（如月份为 13 或者分钟数为 70），相邻的数值会被调整。比如 new Date(2013, 13, 1)等于new Date(2014, 1, 1)，它们都表示日期2014-02-01（注意月份是从0开始的）。其他数值也是类似，new Date(2013, 2, 1, 0, 70)等于new Date(2013, 2, 1, 1, 10)，都表示同一个时间：2013-03-01T01:10:00。
                注意：当Date作为构造函数调用并传入多个参数时，所定义参数代表的是当地时间。如果需要使用世界协调时 UTC，使用 new Date(Date.UTC(...)) 和相同参数。
                Date()构造函数有四种基本形式
                没有参数
                如果没有提供参数，那么新创建的Date对象表示实例化时刻的日期和时间。

            Unix时间戳
                value
                    一个 Unix 时间戳（Unix Time Stamp），它是一个整数值，表示自1970年1月1日00:00:00 UTC（the Unix epoch）以来的毫秒数，忽略了闰秒。请注意大多数 Unix 时间戳功能仅精确到最接近的秒。
            时间戳字符串
                dateString
                表示日期的字符串值。该字符串应该能被 Date.parse() 正确方法识别（即符合 IETF-compliant RFC 2822 timestamps 或 version of ISO8601）。
                注意: 由于浏览器之间的差异与不一致性，强烈不推荐使用Date构造函数来解析日期字符串 (或使用与其等价的Date.parse)。对 RFC 2822 格式的日期仅有约定俗称的支持。 对 ISO 8601 格式的支持中，仅有日期的串 (例如 "1970-01-01") 会被处理为 UTC 而不是本地时间，与其他格式的串的处理不同。

                分别提供日期与时间的每一个成员
                当至少提供了年份与月份时，这一形式的 Date() 返回的 Date 对象中的每一个成员都来自下列参数。没有提供的成员将使用最小可能值（对日期为1，其他为0）。

            year
                表示年份的整数值。 0到99会被映射至1900年至1999年，其它值代表实际年份。参见 示例。
            monthIndex
                表示月份的整数值，从 0（1月）到 11（12月）。
            day 可选
                表示一个月中的第几天的整数值，从1开始。默认值为1。
            hours 可选
                表示一天中的小时数的整数值 (24小时制)。默认值为0（午夜）。
            minutes 可选
                表示一个完整时间（如 01:10:00）中的分钟部分的整数值。默认值为0。
            seconds 可选
                表示一个完整时间（如 01:10:00）中的秒部分的整数值。默认值为0。
            milliseconds 可选
                表示一个完整时间的毫秒部分的整数值。默认值为0。
            简介:
                如果没有输入任何参数，则Date的构造器会依据系统设置的当前时间来创建一个Date对象。
                如果提供了至少两个参数，其余的参数均会默认设置为 1（如果没有指定 day 参数）或者 0（如果没有指定 day 以外的参数）。
                JavaScript的时间由世界标准时间（UTC）1970年1月1日开始，用毫秒计时，一天由 86,400,000 毫秒组成。Date 对象的范围是 -100,000,000 天至 100,000,000 天（等效的毫秒值）。
                Date 对象为跨平台提供了统一的行为。时间属性可以在不同的系统中表示相同的时刻，而如果使用了本地时间对象，则反映当地的时间。
                Date 对象支持多个处理 UTC 时间的方法，也相应地提供了应对当地时间的方法。UTC，也就是我们所说的格林威治时间，指的是time中的世界时间标准。而当地时间则是指执行JavaScript的客户端电脑所设置的时间。
                以一个函数的形式来调用 Date 对象（即不使用 new 操作符）会返回一个代表当前日期和时间的字符串。
            属性:
                Date.prototype
                允许为 Date 对象添加属性。
                Date.length
                Date.length 的值是 7。这是该构造函数可接受的参数个数。
            方法:
                Date.now()
                    返回自 1970-1-1 00:00:00  UTC（世界标准时间）至今所经过的毫秒数。
                Date.parse()
                    解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 所经过的毫秒数。
                    Note: Parsing of strings with Date.parse is strongly discouraged due to browser differences and inconsistencies.
                Date.UTC()
                    接受和构造函数最长形式的参数相同的参数（从2到7），并返回从 1970-01-01 00:00:00 UTC 开始所经过的毫秒数。
            例子:
                >例子：创建一个日期对象的几种方法:
                下例展示了用来创建一个日期对象的多种方法。
                    var today = new Date();
                    var birthday = new Date('December 17, 1995 03:24:00');
                    var birthday = new Date('1995-12-17T03:24:00');
                    var birthday = new Date(1995, 11, 17);
                    var birthday = new Date(1995, 11, 17, 3, 24, 0);
                例子：将两位数年份映射为 1900 - 1999 年:
                为了创建和获取 0 到 99 之间的年份，应使用 Date.prototype.setFullYear() 和 Date.prototype.getFullYear() 方法。
                        var date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
                    // 已弃用的方法, 同样将 98 映射为 1998
                        date.setYear(98);           // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
                        date.setFullYear(98);       // Sat Feb 01 0098 00:00:00 GMT+0000 (BST)
                例子：计算经过的时间:
                下例展示了如何以毫秒精度计算两个日期对象的时间差：
                    由于不同日期、月份、年份长度的不同（日期长度不同来自夏令时的切换），使用大于秒、分钟、小时的单位表示经过的时间会遇到很多问题，在使用前需要经过详尽的调研。
                    // 使用 Date 对象
                        var start = Date.now();
                    // 调用一个消耗一定时间的方法：
                        doSomethingForALongTime();
                        var end = Date.now();
                        var elapsed = end - start; // 以毫秒计的运行时长
                    // 使用内建的创建方法
                        var start = new Date();
                    // 调用一个消耗一定时间的方法：
                        doSomethingForALongTime();
                        var end = new Date();
                        var elapsed = end.getTime() - start.getTime(); // 运行时间的毫秒值
                    // to test a function and get back its return
                        function printElapsedTime (fTest) {
                            var nStartTime = Date.now(),
                                vReturn = fTest(),
                                nEndTime = Date.now();
                            alert("Elapsed time: " + String(nEndTime - nStartTime) + " milliseconds"); 
                            return vReturn;
                        }
                        yourFunctionReturn = printElapsedTime(yourFunction);
                    注意：在支持 Web Performance API 的高精细度（high-resolution）时间功能的浏览器中，Performance.now() 提供的所经过的时间比 Date.now() 更加可靠、精确。
                获取自 Unix 起始时间以来经过的秒数:
                    var seconds = Math.floor(Date.now() / 1000);
                    注意此处需要返回一个整数 （仅做除法得到的不是整数），并且需要返回实际已经经过的秒数（所以这里使用了Math.floor()而不是Math.round()).
    9.语句
        for...in语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性
            语法：
                for (variable in object)
                statement
            variable
                在每次迭代时，variable会被赋值为不同的属性名。
            object
                被迭代枚举其属性的对象。
            for...in 循环只遍历可枚举属性。像 Array和 Object使用内置构造函数所创建的对象都会继承自Object.prototype和String.prototype的不可枚举属性，例如 String 的 indexOf()  方法或 Object的toString()方法。循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。
            删除，添加或者修改属性
                for...in 循环以任意序迭代一个对象的属性。如果一个属性在一次迭代中被修改，在稍后被访问，其在循环中的值是其在稍后时间的值。一个在被访问之前已经被删除的属性将不会在之后被访问。在迭代进行时被添加到对象的属性，可能在之后的迭代被访问，也可能被忽略。
                通常，在迭代过程中最好不要在对象上进行添加、修改或者删除属性的操作，除非是对当前正在被访问的属性。这里并不保证是否一个被添加的属性在迭代过程中会被访问到，不保证一个修改后的属性（除非是正在被访问的）会在修改前或者修改后被访问，不保证一个被删除的属性将会在它被删除之前被访问。
            数组迭代和 for...in:
                提示：for...in不应该用于迭代一个 Array，其中索引顺序很重要。
                数组索引只是具有整数名称的枚举属性，并且与通用对象属性相同。不能保证for ... in将以任何特定的顺序返回索引。for ... in循环语句将返回所有可枚举属性，包括非整数类型的名称和继承的那些。
                因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素。因此当迭代访问顺序很重要的数组时，最好用整数索引去进行for循环（或者使用 Array.prototype.forEach() 或 for...of 循环）。
            仅迭代自身的属性
                如果你只要考虑对象本身的属性，而不是它的原型，那么使用 getOwnPropertyNames() 或执行 hasOwnProperty() 来确定某属性是否是对象本身的属性（也能使用propertyIsEnumerable）。或者，如果你知道不会有任何外部代码干扰，您可以使用检查方法扩展内置原型。
            示例：
                下面的函数接受一个对象作为参数。被调用时迭代传入对象的所有可枚举属性然后返回一个所有属性名和其对应值的字符串。
                var obj = {a:1, b:2, c:3};    
                for (var prop in obj) {
                console.log("obj." + prop + " = " + obj[prop]);
                }
                // Output:
                // "obj.a = 1"
                // "obj.b = 2"
                // "obj.c = 3"
            下面的函数说明了hasOwnProperty()的用法：继承的属性不显示。
                var triangle = {a: 1, b: 2, c: 3};
                function ColoredTriangle() {
                this.color = 'red';
                }
                ColoredTriangle.prototype = triangle;
                var obj = new ColoredTriangle();
                for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    console.log(`obj.${prop} = ${obj[prop]}`);
                    } 
                }
                // Output:
                // "obj.color = red"
        for...of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句
            语法：
                for (variable of iterable) {
                    //statements
                }
            variable
                在每次迭代中，将不同属性的值分配给变量。
            iterable
                被迭代枚举其属性的对象。
            示例：
            迭代Array:
                let iterable = [10, 20, 30];

                for (let value of iterable) {
                    value += 1;
                    console.log(value);
                }
                // 11
                // 21
                // 31
                如果你不想修改语句块中的变量 , 也可以使用const代替let。
                    let iterable = [10, 20, 30];

                    for (const value of iterable) {
                    console.log(value);
                    }
                    // 10
                    // 20
                    // 30
            迭代String：
                let iterable = "boo";

                for (let value of iterable) {
                console.log(value);
                }
                // "b"
                // "o"
                // "o"
            迭代 TypedArray:
                let iterable = new Uint8Array([0x00, 0xff]);
                for (let value of iterable) {
                console.log(value);
                }
                // 0
                // 255
            迭代Map:
                let iterable = new Map([["a", 1], ["b", 2], ["c", 3]]);
                for (let entry of iterable) {
                console.log(entry);
                }
                // ["a", 1]
                // ["b", 2]
                // ["c", 3]
                for (let [key, value] of iterable) {
                console.log(value);
                }
                // 1
                // 2
                // 3
            迭代 Set:
                let iterable = new Set([1, 1, 2, 2, 3, 3]);
                for (let value of iterable) {
                console.log(value);
                }
                // 1
                // 2
                // 3
            迭代 arguments(参数) 对象:
                (function() {
                for (let argument of arguments) {
                    console.log(argument);
                }
                })(1, 2, 3);
                // 1
                // 2
                // 3
            迭代 DOM 集合:
                迭代 DOM 元素集合，比如一个NodeList对象：下面的例子演示给每一个 article 标签内的 p 标签添加一个 "read" 类。
                //注意：这只能在实现了NodeList.prototype[Symbol.iterator]的平台上运行
                let articleParagraphs = document.querySelectorAll("article > p");
                for (let paragraph of articleParagraphs) {
                paragraph.classList.add("read");
                }
            关闭迭代器:
                对于for...of的循环，可以由break, throw  continue    或return终止。在这些情况下，迭代器关闭。
                function* foo(){ 
                yield 1; 
                yield 2; 
                yield 3; 
                }; 

                for (let o of foo()) { 
                console.log(o); 
                break; // closes iterator, triggers return
                }
            迭代生成器:
                你还可以迭代一个生成器：
                function* fibonacci() { // 一个生成器函数
                    let [prev, curr] = [0, 1];
                    for (;;) { // while (true) {
                        [prev, curr] = [curr, prev + curr];
                        yield curr;
                    }
                }
                for (let n of fibonacci()) {
                    console.log(n); 
                    // 当n大于1000时跳出循环
                    if (n >= 1000)
                        break;
                }
                不要重用生成器
                生成器不应该重用，即使for...of循环的提前终止，例如通过break关键字。在退出循环后，生成器关闭，并尝试再次迭代，不会产生任何进一步的结果。
                var gen = (function *(){
                    yield 1;
                    yield 2;
                    yield 3;
                })();
                for (let o of gen) {
                    console.log(o);
                    break;//关闭生成器
                } 
                //生成器不应该重用，以下没有意义！
                for (let o of gen) {
                    console.log(o);
                }
            迭代其他可迭代对象:
                你还可以迭代显式实现可迭代协议的对象：
                var iterable = {
                [Symbol.iterator]() {
                    return {
                    i: 0,
                    next() {
                        if (this.i < 3) {
                        return { value: this.i++, done: false };
                        }
                        return { value: undefined, done: true };
                    }
                    };
                }
                };
                for (var value of iterable) {
                console.log(value);
                }
                // 0
                // 1
                // 2
            for...of与for...in的区别:
                无论是for...in还是for...of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。
                for...in 语句以原始插入顺序迭代对象的可枚举属性。
                for...of 语句遍历可迭代对象定义要迭代的数据。
                以下示例显示了与Array一起使用时，for...of循环和for...in循环之间的区别。
                    Object.prototype.objCustom = function() {}; 
                    Array.prototype.arrCustom = function() {};
                    let iterable = [3, 5, 7];
                    iterable.foo = 'hello';
                    for (let i in iterable) {
                    console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"
                    }
                    for (let i in iterable) {
                    if (iterable.hasOwnProperty(i)) {
                        console.log(i); // logs 0, 1, 2, "foo"
                    }
                    }
                    for (let i of iterable) {
                    console.log(i); // logs 3, 5, 7
                    }
                    Object.prototype.objCustom = function() {};
                    Array.prototype.arrCustom = function() {}; 

                    let iterable = [3, 5, 7]; 
                    iterable.foo = 'hello';
                    每个对象将继承objCustom属性，并且作为Array的每个对象将继承arrCustom属性，因为将这些属性添加到Object.prototype和Array.prototype。由于继承和原型链，对象iterable继承属性objCustom和arrCustom。
                    for (let i in iterable) {
                    console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom" 
                    }
                    此循环仅以原始插入顺序记录iterable 对象的可枚举属性。它不记录数组元素3, 5, 7 或hello，因为这些不是枚举属性。但是它记录了数组索引以及arrCustom和objCustom。如果你不知道为什么这些属性被迭代，array iteration and for...in中有更多解释。
                    for (let i in iterable) {
                    if (iterable.hasOwnProperty(i)) {
                        console.log(i); // logs 0, 1, 2, "foo"
                    }
                    }
                    这个循环类似于第一个，但是它使用hasOwnProperty() 来检查，如果找到的枚举属性是对象自己的（不是继承的）。如果是，该属性被记录。记录的属性是0, 1, 2和foo，因为它们是自身的属性（不是继承的）。属性arrCustom和objCustom不会被记录，因为它们是继承的。

                    for (let i of iterable) {
                    console.log(i); // logs 3, 5, 7 
                    }
                    该循环迭代并记录iterable作为可迭代对象定义的迭代值，这些是数组元素 3, 5, 7，而不是任何对象的属性。
    10.函数
        箭头函数：
            箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。
            语法:
                基础语法:
                        (参数1, 参数2, …, 参数N) => { 函数声明 }
                    //相当于：(参数1, 参数2, …, 参数N) =>{ return 表达式; }
                        (参数1, 参数2, …, 参数N) => 表达式（单一）
                    // 当只有一个参数时，圆括号是可选的：
                        (单一参数) => {函数声明}
                        单一参数 => {函数声明}
                    // 没有参数的函数应该写成一对圆括号。
                        () => {函数声明}
                高级语法:
                    //加括号的函数体返回对象字面表达式：
                        参数=> ({foo: bar})
                    //支持剩余参数和默认参数
                        (参数1, 参数2, ...rest) => {函数声明}
                        (参数1 = 默认值1,参数2, …, 参数N = 默认值N) => {函数声明}
                    //同样支持参数列表解构
                        let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;
                        f();  // 6
            描述:
                引入箭头函数有两个方面的作用：更简短的函数并且不绑定this。
                更短的函数:
                    var elements = [
                    'Hydrogen',
                    'Helium',
                    'Lithium',
                    'Beryllium'
                    ];
                    elements.map(function(element) { 
                    return element.length; 
                    }); // 返回数组：[8, 6, 7, 9]
                    // 上面的普通函数可以改写成如下的箭头函数
                        elements.map((element) => {
                        return element.length;
                        }); // [8, 6, 7, 9]
                    // 当箭头函数只有一个参数时，可以省略参数的圆括号
                        elements.map(element => {
                        return element.length;
                        }); // [8, 6, 7, 9]
                    // 当箭头函数的函数体只有一个 `return` 语句时，可以省略 `return` 关键字和方法体的花括号
                        elements.map(element => element.length); // [8, 6, 7, 9]
                    // 在这个例子中，因为我们只需要 `length` 属性，所以可以使用参数解构
                    // 需要注意的是字符串 `"length"` 是我们想要获得的属性的名称，而 `lengthFooBArX` 则只是个变量名，
                    // 可以替换成任意合法的变量名
                        elements.map(({ "length": lengthFooBArX }) => lengthFooBArX); // [8, 6, 7, 9]
                不绑定this:
                在箭头函数出现之前，每个新定义的函数都有它自己的 this值（在构造函数的情况下是一个新对象，在严格模式的函数调用中为 undefined，如果该函数被作为“对象方法”调用则为基础对象等）。This被证明是令人厌烦的面向对象风格的编程。
                    function Person() {
                    // Person() 构造函数定义 `this`作为它自己的实例.
                    this.age = 0;
                    setInterval(function growUp() {
                        // 在非严格模式, growUp()函数定义 `this`作为全局对象, 
                        // 与在 Person()构造函数中定义的 `this`并不相同.
                        this.age++;
                    }, 1000);
                    }
                    var p = new Person();
                在ECMAScript 3/5中，通过将this值分配给封闭的变量，可以解决this问题。
                    function Person() {
                    var that = this;
                    that.age = 0;
                    setInterval(function growUp() {
                        //  回调引用的是`that`变量, 其值是预期的对象. 
                        that.age++;
                    }, 1000);
                    }
                或者，可以创建绑定函数，以便将预先分配的this值传递到绑定的目标函数（上述示例中的growUp()函数）。
                箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同：
                    function Person(){
                    this.age = 0;
                    setInterval(() => {
                        this.age++; // |this| 正确地指向 p 实例
                    }, 1000);
                    }
                    var p = new Person();
                与严格模式的关系
                鉴于 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。
                    function Person() {
                    this.age = 0;
                    var closure = "123"
                    setInterval(function growUp() {
                        this.age++;
                        console.log(closure)
                    }, 1000);
                    }
                    var p = new Person();
                    function PersonX() {
                    'use strict'
                    this.age = 0;
                    var closure = "123"
                    setInterval(()=>{
                        this.age++;
                        console.log(closure)
                    }, 1000);
                    }
                    var px = new PersonX();
                    严格模式的其他规则依然不变.
            通过 call 或 apply 调用
                由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this---注），他们的第一个参数会被忽略。（这种现象对于bind方法同样成立---注）
                    var adder = {
                    base : 1,                        
                    add : function(a) {
                        var f = v => v + this.base;
                        return f(a);
                    },
                    addThruCall: function(a) {
                        var f = v => v + this.base;
                        var b = {
                        base : 2
                        };                                
                        return f.call(b, a);
                    }
                    };
                    console.log(adder.add(1));         // 输出 2
                    console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——注）
            不绑定arguments:
                箭头函数不绑定Arguments 对象。因此，在本示例中，arguments只是引用了封闭作用域内的arguments：
                    var arguments = [1, 2, 3];
                    var arr = () => arguments[0];
                    arr(); // 1
                    function foo(n) {
                    var f = () => arguments[0] + n; // 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n
                    return f();
                    }
                    foo(1); // 2
                    在大多数情况下，使用剩余参数是相较使用arguments对象的更好选择。
                    function foo(arg) { 
                    var f = (...args) => args[0]; 
                    return f(arg); 
                    }
                    foo(1); // 1
                    function foo(arg1,arg2) { 
                        var f = (...args) => args[1]; 
                        return f(arg1,arg2); 
                    } 
                    foo(1,2);  //2
            像函数一样使用箭头函数:
            如上所述，箭头函数表达式对非方法函数是最合适的。让我们看看当我们试着把它们作为方法时发生了什么。
                'use strict';
                var obj = {
                i: 10,
                b: () => console.log(this.i, this),
                c: function() {
                    console.log( this.i, this)
                }
                }
                obj.b(); 
                // undefined, Window{...}
                obj.c(); 
                // 10, Object {...}
            箭头函数没有定义this绑定。另一个涉及Object.defineProperty()的示例：
                'use strict';
                var obj = {
                a: 10
                };
                Object.defineProperty(obj, "b", {
                get: () => {
                    console.log(this.a, typeof this.a, this);
                    return this.a+10; 
                // 代表全局对象 'Window', 因此 'this.a' 返回 'undefined'
                }
                });
                obj.b; // undefined   "undefined"   Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}
            使用 new 操作符:
            箭头函数不能用作构造器，和 new一起用会抛出错误。
                var Foo = () => {};
                var foo = new Foo(); // TypeError: Foo is not a constructor
            使用prototype属性:
            箭头函数没有prototype属性。
                var Foo = () => {};
                console.log(Foo.prototype); // undefined
            使用 yield 关键字:
            yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。
            函数体:
            箭头函数可以有一个“简写体”或常见的“块体”。
            在一个简写体中，只需要一个表达式，并附加一个隐式的返回值。在块体中，必须使用明确的return语句。
                var func = x => x * x;                  
                    // 简写函数 省略return
                var func = (x, y) => { return x + y; }; 
                    //常规编写 明确的返回值
            返回对象字面量:
            记住用params => {object:literal}这种简单的语法返回对象字面量是行不通的。
                var func = () => { foo: 1 };               
                // Calling func() returns undefined!
                var func = () => { foo: function() {} };   
                // SyntaxError: function statement requires a name
                这是因为花括号（{} ）里面的代码被解析为一系列语句（即 foo 被认为是一个标签，而非对象字面量的组成部分）。
                所以，记得用圆括号把对象字面量包起来：
                    var func = () => ({foo: 1});
            换行:
            箭头函数在参数和箭头之间不能换行。
                var func = ()
                        => 1; 
                // SyntaxError: expected expression, got '=>'
            解析顺序:
            虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则。
                let callback;
                callback = callback || function() {}; // ok
                callback = callback || () => {};      
                // SyntaxError: invalid arrow-function arguments
                callback = callback || (() => {});    // ok
            更多示例:
            // 空的箭头函数返回 undefined
                let empty = () => {};
                (() => 'foobar')(); 
                // Returns "foobar"
                // (这是一个立即执行函数表达式,可参阅 'IIFE'术语表) 
                var simple = a => a > 15 ? 15 : a; 
                simple(16); // 15
                simple(10); // 10
                let max = (a, b) => a > b ? a : b;
                // Easy array filtering, mapping, ...
                var arr = [5, 6, 13, 0, 1, 18, 23];
                var sum = arr.reduce((a, b) => a + b);  
                // 66
                var even = arr.filter(v => v % 2 == 0); 
                // [6, 0, 18]
                var double = arr.map(v => v * 2);       
                // [10, 12, 26, 0, 2, 36, 46]
                // 更简明的promise链
                promise.then(a => {
                // ...
                }).then(b => {
                // ...
                });
            // 无参数箭头函数在视觉上容易分析
                setTimeout( () => {
                console.log('I happen sooner');
                setTimeout( () => {
                    // deeper code
                    console.log('I happen later');
                }, 1);
                }, 1);            
            箭头函数也可以使用条件（三元）运算符：
                var simple = a => a > 15 ? 15 : a;
                simple(16); // 15
                simple(10); // 10
                let max = (a, b) => a > b ? a : b;
            箭头函数内定义的变量及其作用域
            // 常规写法
                var greeting = () => {let now = new Date(); return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));}
                greeting();          //"Good day."
                console.log(now);    // ReferenceError: now is not defined 标准的let作用域
            // 参数括号内定义的变量是局部变量（默认参数）
                var greeting = (now=new Date()) => "Good" + (now.getHours() > 17 ? " evening." : " day.");
                greeting();          //"Good day."
                console.log(now);    // ReferenceError: now is not defined
            // 对比：函数体内{}不使用var定义的变量是全局变量
                var greeting = () => {now = new Date(); return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));}
                greeting();           //"Good day."
                console.log(now);     // Fri Dec 22 2017 10:01:00 GMT+0800 (中国标准时间)
            // 对比：函数体内{} 用var定义的变量是局部变量
                var greeting = () => {var now = new Date(); return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));}
                greeting(); //"Good day."
                console.log(now);    // ReferenceError: now is not defined            
            箭头函数也可以使用闭包：
                // 标准的闭包函数
                    function A(){
                        var i=0;
                        return function b(){
                                return (++i);
                        };
                    };

                    var v=A();
                    v();    //1
                    v();    //2
                //箭头函数体的闭包（ i=0 是默认参数）
                    var Add = (i=0) => {return (() => (++i) )};
                    var v = Add();
                    v();           //1
                    v();           //2
                    //因为仅有一个返回，return 及括号（）也可以省略
                    var Add = (i=0)=> ()=> (++i);
             箭头函数递归：
                var fact = (x) => ( x==0 ?  1 : x*fact(x-1) );
                fact(5);       // 120
        Arguments 
            arguments 是一个对应于传递给函数的参数的类数组对象。
            语法：
                arguments
            描述：
                arguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引0处。例如，如果一个函数传递了三个参数，你可以以如下方式引用他们：
                arguments[0]
                arguments[1]
                arguments[2]
            参数也可以被设置：
                arguments[1] = 'new value';
            arguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性。例如，它没有 pop 方法。但是它可以被转换为一个真正的Array：
                var args = Array.prototype.slice.call(arguments);
                var args = [].slice.call(arguments);
                // ES2015
                const args = Array.from(arguments);
                const args = [...arguments];
            可以使用索引确定单个参数的类型。
                console.log(typeof arguments[0]); //this will return the typeof individual arguments.
            对参数使用扩展语法：
                您还可以使用Array.from()方法或扩展运算符将参数转换为真实数组：
                var args = Array.from(arguments);
                var args = [...arguments];
            属性:
                arguments.callee
                    指向当前执行的函数。
                arguments.caller 
                    指向调用当前函数的函数。
                arguments.length
                    指向传递给当前函数的参数数量。
                arguments[@@iterator]
                    返回一个新的Array迭代器对象，该对象包含参数中每个索引的值。
                注意:现在在严格模式下，arguments对象已与过往不同。arguments[@@iterator]不再与函数的实际形参之间共享，同时caller属性也被移除。
            例子:
                遍历参数求和:
                    function add() {
                        var sum =0,
                            len = arguments.length;
                        for(var i=0; i<len; i++){
                            sum += arguments[i];
                        }
                        return sum;
                    }
                    add()                           // 0
                    add(1)                          // 1
                    add(1,2,3,4);                   // 10
                定义连接字符串的函数:
                    这个例子定义了一个函数来连接字符串。这个函数唯一正式声明了的参数是一个字符串，该参数指定一个字符作为衔接点来连接字符串。该函数定义如下：
                    function myConcat(separator) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    return args.join(separator);
                    }
                    你可以传递任意数量的参数到该函数，并使用每个参数作为列表中的项创建列表。
                        // returns "red, orange, blue"
                            myConcat(", ", "red", "orange", "blue");
                        // returns "elephant; giraffe; lion; cheetah"
                            myConcat("; ", "elephant", "giraffe", "lion", "cheetah");
                        // returns "sage. basil. oregano. pepper. parsley"
                            myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley");
                定义创建HTML列表的方法:
                    这个例子定义了一个函数通过一个字符串来创建HTML列表。这个函数唯一正式声明了的参数是一个字符。当该参数为 "u" 时，创建一个无序列表 (项目列表)；当该参数为 "o" 时，则创建一个有序列表 (编号列表)。该函数定义如下：
                    function list(type) {
                    var result = "<" + type + "l><li>";
                    var args = Array.prototype.slice.call(arguments, 1);
                    result += args.join("</li><li>");
                    result += "</li></" + type + "l>"; // end list
                    return result;
                    }
                        你可以传递任意数量的参数到该函数，并将每个参数作为一个项添加到指定类型的列表中。例如：
                            var listHTML = list("u", "One", "Two", "Three");
                            /* listHTML is:
                            "<ul><li>One</li><li>Two</li><li>Three</li></ul>"
                            */
                剩余参数、默认参数和解构赋值参数:
                    arguments对象可以与剩余参数、默认参数和解构赋值参数结合使用。
                    function foo(...args) {
                    return args;
                    }
                    foo(1, 2, 3);  // [1,2,3]
                    在严格模式下，剩余参数、默认参数和解构赋值参数的存在不会改变 arguments对象的行为，但是在非严格模式下就有所不同了。
                    当非严格模式中的函数没有包含剩余参数、默认参数和解构赋值，那么arguments对象中的值会跟踪参数的值（反之亦然）。看下面的代码：
                        function func(a) { 
                        arguments[0] = 99;   // 更新了arguments[0] 同样更新了a
                        console.log(a);
                        }
                        func(10); // 99
                        并且
                        function func(a) { 
                        a = 99;              // 更新了a 同样更新了arguments[0] 
                        console.log(arguments[0]);
                        }
                        func(10); // 99
                    当非严格模式中的函数有包含剩余参数、默认参数和解构赋值，那么arguments对象中的值不会跟踪参数的值（反之亦然）。相反, arguments反映了调用时提供的参数：
                        function func(a = 55) { 
                        arguments[0] = 99; // updating arguments[0] does not also update a
                        console.log(a);
                        }
                        func(10); // 10
                        并且
                        function func(a = 55) { 
                        a = 99; // updating a does not also update arguments[0]
                        console.log(arguments[0]);
                        }
                        func(10); // 10
                        并且
                        function func(a = 55) { 
                        console.log(arguments[0]);
                        }
                        func(); // undefined
    11.数组
        创建数组
            var a=new Array();
            var a=new Array(6);创建指定长度的数组
            var fruits = ['Apple', 'Banana'];
            console.log(fruits.length);
            // 2
        通过索引访问数组元素
            var first = fruits[0];
            // Apple
            var last = fruits[fruits.length - 1];
            // Banana
        遍历数组
            fruits.forEach(function (item, index, array) {
                console.log(item, index);
            });
            // Apple 0
            // Banana 1
        添加元素到数组的末尾
            var newLength = fruits.push('Orange');
            // newLength:3; fruits: ["Apple", "Banana", "Orange"]
        删除数组末尾的元素
            var last = fruits.pop(); // remove Orange (from the end)
            // last: "Orange"; fruits: ["Apple", "Banana"];
        删除数组最前面（头部）的元素
            var first = fruits.shift(); // remove Apple from the front
            // first: "Apple"; fruits: ["Banana"];
        添加元素到数组的头部
            var newLength = fruits.unshift('Strawberry') // add to the front
            // ["Strawberry", "Banana"];
        找出某个元素在数组中的索引
            fruits.push('Mango');
            // ["Strawberry", "Banana", "Mango"]
            var pos = fruits.indexOf('Banana');
            // 1
        通过索引删除某个元素
            var removedItem = fruits.splice(pos, 1); // this is how to remove an item
            // ["Strawberry", "Mango"]
                arrayObject.splice(index,howmany,item1,.....,itemX)
                参数	描述
                index	必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。
                howmany	必需。要删除的项目数量。如果设置为 0，则不会删除项目。
                item1, ..., itemX	可选。向数组添加的新项目。
        从一个索引位置删除多个元素
            var vegetables = ['Cabbage', 'Turnip', 'Radish', 'Carrot'];
            console.log(vegetables); 
                // ["Cabbage", "Turnip", "Radish", "Carrot"]
            var pos = 1, n = 2;
            var removedItems = vegetables.splice(pos, n);
                // this is how to remove items, n defines the number of items to be removed,
                // from that position(pos) onward to the end of array.
            console.log(vegetables); 
                // ["Cabbage", "Carrot"] (the original array is changed)
            console.log(removedItems); 
                // ["Turnip", "Radish"]
        复制一个数组
            var shallowCopy = fruits.slice(); // this is how to make a copy 
            // ["Strawberry", "Mango"]
        使用push和pop方法来操作数组
            push（）在数组末尾插入一个或者多个元素，pop（）在数组末尾删除并且返回末尾元素，pop（）不带参数。
        使用unshift和shift方法来操作数组
            unshift（）在数组开头插入一个或者多个元素，shift（）在数组开头删除并且返回该元素，shift（）不带参数。
        使用splice（）方法
            splice方法包含3个参数，第一个指定参数插入的起始位置，第二个参数指定要删除的元素个数，第三个参数指定要插入的元素。
            例如：splice（2,2,1,2,2,2）说明从第二个元素后面开始截取2个元素，并且替换为1,2,2,2。然后返回截取的2个元素。
        reverse() 方法将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组。
            语法：
                arr.reverse()
            参数:
                无
            描述：
                reverse 方法颠倒数组中元素的位置，并返回该数组的引用。
            示例:
                例子：颠倒数组中的元素:
                下例将会创建一个数组 sourceArray，其包含三个元素，然后颠倒该数组。
                    var sourceArray = ['one', 'two', 'three'];
                    var reverseArray = sourceArray.reverse();
                    console.log(sourceArray ) // ['three', 'two', 'one']
                    console.log(sourceArray === reverseArray); // true
        sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的
            由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。
            语法:
                arr.sort([compareFunction])
            参数:
                compareFunction 可选
                用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。
            firstEl
                第一个用于比较的元素。
            secondEl
                第二个用于比较的元素。
                返回值:
                排序后的数组。请注意，数组已原地排序，并且不进行复制。
            描述:
                如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 "Banana" 会被排列到 "cherry" 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 "80" 要比 "9" 要靠前。
                如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：
                如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；
                如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；
                如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。
                compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。
                所以，比较函数格式如下：
                    function compare(a, b) {
                    if (a < b ) {           // 按某种排序标准进行比较, a 小于 b
                        return -1;
                    }
                    if (a > b ) {
                        return 1;
                    }
                    // a must be equal to b
                    return 0;
                    }
                    要比较数字而非字符串，比较函数可以简单的以 a 减 b，如下的函数将会将数组升序排列
                        function compareNumbers(a, b) {
                        return a - b;
                        }
                sort 方法可以使用 函数表达式 方便地书写：
                    var numbers = [4, 2, 5, 1, 3];
                    numbers.sort(function(a, b) {
                    return a - b;
                    });
                    console.log(numbers);
                    也可以写成：
                        var numbers = [4, 2, 5, 1, 3]; 
                        numbers.sort((a, b) => a - b); 
                        console.log(numbers);
                        // [1, 2, 3, 4, 5]
                对象可以按照某个属性排序：
                    var items = [
                    { name: 'Edward', value: 21 },
                    { name: 'Sharpe', value: 37 },
                    { name: 'And', value: 45 },
                    { name: 'The', value: -12 },
                    { name: 'Magnetic' },
                    { name: 'Zeros', value: 37 }
                    ];
                    // sort by value
                        items.sort(function (a, b) {
                        return (a.value - b.value)
                        });
                    // sort by name
                        items.sort(function(a, b) {
                        var nameA = a.name.toUpperCase(); // ignore upper and lowercase
                        var nameB = b.name.toUpperCase(); // ignore upper and lowercase
                        if (nameA < nameB) {
                            return -1;
                        }
                        if (nameA > nameB) {
                            return 1;
                        }                
                        // names must be equal
                        return 0;
                        });
                示例:
                创建、显示及排序数组:
                下述示例创建了四个数组，并展示原数组。之后对数组进行排序。对比了数字数组分别指定与不指定比较函数的结果。
                    var stringArray = ["Blue", "Humpback", "Beluga"];
                    var numericStringArray = ["80", "9", "700"];
                    var numberArray = [40, 1, 5, 200];
                    var mixedNumericArray = ["80", "9", "700", 40, 1, 5, 200];
                    function compareNumbers(a, b)
                    {
                    return a - b;
                    }
                    console.log('stringArray:' + stringArray.join());
                    console.log('Sorted:' + stringArray.sort());
                    console.log('numberArray:' + numberArray.join());
                    console.log('Sorted without a compare function:'+ numberArray.sort());
                    console.log('Sorted with compareNumbers:'+ numberArray.sort(compareNumbers));
                    console.log('numericStringArray:'+ numericStringArray.join());
                    console.log('Sorted without a compare function:'+ numericStringArray.sort());
                    console.log('Sorted with compareNumbers:'+ numericStringArray.sort(compareNumbers));
                    console.log('mixedNumericArray:'+ mixedNumericArray.join());
                    console.log('Sorted without a compare function:'+ mixedNumericArray.sort());
                    console.log('Sorted with compareNumbers:'+ mixedNumericArray.sort(compareNumbers));
                该示例的返回结果如下。输出显示，当使用比较函数后，数字数组会按照数字大小排序。
                stringArray: Blue,Humpback,Beluga
                Sorted: Beluga,Blue,Humpback
                numberArray: 40,1,5,200
                Sorted without a compare function: 1,200,40,5
                Sorted with compareNumbers: 1,5,40,200
                numericStringArray: 80,9,700
                Sorted without a compare function: 700,80,9
                Sorted with compareNumbers: 9,80,700
                mixedNumericArray: 80,9,700,40,1,5,200
                Sorted without a compare function: 1,200,40,5,700,80,9
                Sorted with compareNumbers: 1,5,9,40,80,200,700
            对非 ASCII 字符排序:
                当排序非 ASCII 字符的字符串（如包含类似 e, é, è, a, ä 等字符的字符串）。一些非英语语言的字符串需要使用 String.localeCompare。这个函数可以将函数排序到正确的顺序。
                    var items = ['réservé', 'premier', 'cliché', 'communiqué', 'café', 'adieu'];
                    items.sort(function (a, b) {
                    return a.localeCompare(b);
                    });
                        // items is ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé']
            使用映射改善排序:
                compareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。
                // 需要被排序的数组
                    var list = ['Delta', 'alpha', 'CHARLIE', 'bravo'];
                // 对需要排序的数字和位置的临时存储
                    var mapped = list.map(function(el, i) {
                    return { index: i, value: el.toLowerCase() };
                    })
                // 按照多个值排序数组
                    mapped.sort(function(a, b) {
                    return +(a.value > b.value) || +(a.value === b.value) - 1;
                    });
                // 根据索引得到排序的结果
                    var result = mapped.map(function(el){
                    return list[el.index];
                    });
    12.正则表达式
        正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、matchAll、replace、search 和 split 方法。
        创建一个正则表达式：
            你可以使用以下两种方法之一构建一个正则表达式：
                使用一个正则表达式字面量，其由包含在斜杠之间的模式组成，如下所示：（利用字面量创建）
                    var re = /ab+c/;
                    使用正则表达式字面量为正则表达式提供了脚本加载后的编译。当正则表达式保持不变时，使用此方法可获得更好的性能。
                或者调用RegExp对象的构造函数，如下所示：
                    var re = new RegExp("ab+c");
                    或者
                    var re = new RegExp(/ab+c/);
                    使用构造函数为正则表达式提供了运行时的编译。使用构造函数的方式，当你知道正则表达式的模式将会改变，或者你不知道模式，并且从其他来源获取它，如用户输入。
                测试正则表达式test
                    test()正则表达式对象方法，用于检测字符串是否符合该标准规范，该对象会返回true或者false，其参数是测试字符串
                    regexObj.test(str);
                    regexObj是写的正则表达式
                    str是我们要测试的文本
                    就是检测str文本是否符合我们的正则表达式规范
        编写一个正则表达式的模式：
            一个正则表达式模式是由简单的字符所构成的，比如 /abc/；或者是简单和特殊字符的组合，比如 /ab*c/ 或 /Chapter (\d+)\.\d*/。最后的例子中用到了括号，它在正则表达式中常用作记忆设备。即这部分所匹配的字符将会被记住以备后续使用，例如使用括号的子字符串匹配。
            使用简单模式：
                简单模式是由你想直接找到的字符构成。比如，/abc/ 这个模式就能且仅能匹配 "abc" 字符按照顺序同时出现的情况。例如在 "Hi, do you know your abc's?" 和 "The latest airplane designs evolved from slabcraft." 中会匹配成功。在上述两个例子中，匹配的子字符串是 "abc"。但是在 "Grab crab" 中会匹配失败，因为它虽然包含子字符串 "ab c"，但并不是准确的 "abc"。
            使用特殊字符：
                当你需要搜索一个比直接匹配需要更多条件的匹配时，比如寻找一个或多个 "b"，或者寻找空格，这时可以在模式中使用特殊字符。比如，你可以使用 /ab*c/ 去匹配一个单独的 "a" 后面跟了零个或者多个 "b"，同时后面跟着 "c" 的字符串：*的意思是前一项出现零次或者多次。在字符串 "cbbabbbbcdebc" 中，这个模式匹配了子字符串 "abbbbc"。
            下面的页面与表格列出了一个正则表达式中可以利用的特殊字符的完整列表和描述。
                断言（Assertions）
                    表示一个匹配在某些条件下发生。断言包含先行断言、后行断言和条件表达式。
                边界（Boundaries）
                    表示行和单词的开始和结尾。
                字符类别（Character Classes）
                    区分不同类型的字符，例如区分字母和数字。
                组和范围（Groups and Ranges）
                    表示表达式字符的分组和范围。
                量词（Quantifiers）
                    表示匹配的字符或表达式的数量。
                Unicode 属性转义（Unicode Property Escapes）
                    基于 unicode 字符属性区分字符。例如大写和小写字母、数学符号和标点。
            正则表达式中的特殊字符（元字符）
            字符	    含义

            \	        依照下列规则匹配：
                        在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有 "\" 的 "b" 通常匹配小写字母 "b"，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 "\"，它将不再匹配任何字符，而是表示一个字符边界。
                        在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅下文中的 "转义（Escaping）" 部分。
                        如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。/[a-z]\s/i 和 new RegExp("[a-z]\\s", "i") 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（\s 可看后文）并且在 a-z 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和表达式级别都对它进行转义。例如 /[a-z]:\\/i 和 new RegExp("[a-z]:\\\\","i") 会创建相同的表达式，即匹配类似 "C:\" 字符串。

            ^	        匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。
                        例如，/^A/ 并不会匹配 "an A" 中的 'A'，但是会匹配 "An E" 中的 'A'。
                        当 '^' 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。补充字符集合 一：有详细介绍和示例。

            $	        匹配输入的结束。如果多行标示被设置为 true，那么也匹配换行符前的位置。
                        例如，/t$/ 并不会匹配 "eater" 中的 't'，但是会匹配 "eat" 中的 't'。
                        注：var seg=/^abc$/;//表示只能匹配abc这个字符串，像abcabc都不行，
                        var seg1=/^[abc]$/;//表示3选1，只有是a,或者b或者c这3个字母之一才返回true。

            *	        匹配前一个表达式 0 次或多次。等价于 {0,}。
                        例如，/bo*/ 会匹配 "A ghost boooooed" 中的 'booooo' 和 "A bird warbled" 中的 'b'，但是在 "A goat grunted" 中不会匹配任何内容。

            +	        匹配前面一个表达式 1 次或者多次。等价于 {1,}。
                        例如，/a+/ 会匹配 "candy" 中的 'a' 和 "caaaaaaandy" 中所有的 'a'，但是在 "cndy" 中不会匹配任何内容。

            ?	        匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}。
                        例如，/e?le?/ 匹配 "angel" 中的 'el'、"angle" 中的 'le' 以及 "oslo' 中的 'l'。
                        如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 "123abc" 使用 /\d+/ 将会匹配 "123"，而使用 /\d+?/ 则只会匹配到 "1"。
                        还用于先行断言中，如本表的 x(?=y) 和 x(?!y) 条目所述。

            .	        （小数点）默认匹配除换行符之外的任何单个字符。
                        例如，/.n/ 将会匹配 "nay, an apple is on the tree" 中的 'an' 和 'on'，但是不会匹配 'nay'。
                        如果 s ("dotAll") 标志位被设为 true，它也会匹配换行符。

            (x)	        像下面的例子展示的那样，它会匹配 'x' 并且记住匹配项。其中括号被称为捕获括号。注意括号表示优先级，他表示权重最高
                        模式 /(foo) (bar) \1 \2/ 中的 '(foo)' 和 '(bar)' 匹配并记住字符串 "foo bar foo bar" 中前两个单词。模式中的 \1 和 \2 表示第一个和第二个被捕获括号匹配的子字符串，即 foo 和 bar，匹配了原字符串中的后两个单词。注意 \1、\2、...、\n 是用在正则表达式的匹配环：，详情可以参阅后文的 \n 条目。而在正则表达式的替换环：，则要使用像 $1、$2、...、$n 这样的语法，例如，'bar foo'.replace(/(...) (...)/, '$2 $1')。$& 表示整个用于匹配的原字符串。
                        var reg=/^abc{3}$/;//他表示c重复3次，即只有 abccc才能为true
                        var reg=/^(abc){3}$/;//他表示abc重复3次

            (?:x)	    匹配 'x' 但是不记住匹配项。这种括号叫作非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。
                        看看这个例子 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2} 将只应用于 'foo' 的最后一个字符 'o'。如果使用非捕获括号，则 {1,2} 会应用于整个 'foo' 单词。更多信息，可以参阅下文的 Using parentheses 条目.
            
            x(?=y)	    匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。
                        例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。

            (?<=y)x	    匹配'x'仅仅当'x'前面是'y'.这种叫做后行断言。
                        例如，/(?<=Jack)Sprat/会匹配到' Sprat '仅仅当它前面是' Jack '。/(?<=Jack|Tom)Sprat/匹配‘ Sprat ’仅仅当它前面是'Jack'或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。

            x(?!y)	    仅仅当'x'后面不跟着'y'时匹配'x'，这被称为正向否定查找。
                        例如，仅仅当这个数字后面没有跟小数点的时候，/\d+(?!\.)/ 匹配一个数字。正则表达式/\d+(?!\.)/.exec("3.141")匹配‘141’而不是‘3.141’

            (?<!y)x	    仅仅当'x'前面不是'y'时匹配'x'，这被称为反向否定查找。
                        例如, 仅仅当这个数字前面没有负号的时候，/(?<!-)\d+/ 匹配一个数字。
                                                            /(?<!-)\d+/.exec('3') 匹配到 "3".
                                                            /(?<!-)\d+/.exec('-3') 因为这个数字前有负号，所以没有匹配到。

            x|y	        匹配‘x’或者‘y’。
                        例如，/green|red/匹配“green apple”中的‘green’和“red apple”中的‘red’
                        座机号码验证：010-12345678或者0235-4561237
                            var reg=/^\d{3}-\d{8}$|^\d{4}-\d{7}$/

            {n}	        n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。
                        比如， /a{2}/ 不会匹配“candy”中的'a',但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个'a'。
                        
            {n,}	    n是一个正整数，匹配前一个字符至少出现了n次。
                        例如, /a{2,}/ 匹配 "aa", "aaaa" 和 "aaaaa" 但是不匹配 "a"。

            {n,m}	    n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。
                        例如，/a{1, 3}/ 并不匹配“cndy”中的任意字符，匹配“candy”中的a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。

            [xyz]	    一个字符集合。匹配方括号中的任意字符，包括转义序列。
                        你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。
                        例如，[abcd] 和[a-d]是一样的。他们都匹配"brisket"中的‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\w.]+/与字符串“test.i.ng”匹配。
            
            [^xyz]	    一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。
                        例如，[^abc] 和 [^a-c] 是一样的。他们匹配"brisket"中的‘r’，也匹配“chop”中的‘h’。

            [\b]	    匹配一个退格(U+0008)。（不要和\b混淆了。）

            \b	        匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者没有其他“字”字符在其前面的位置。
                        注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\b]混淆了）
                        使用"moon"举例：
                        /\bm/匹配“moon”中的‘m’；
                        /oo\b/并不匹配"moon"中的'oo'，因为'oo'被一个“字”字符'n'紧跟着。
                        /oon\b/匹配"moon"中的'oon'，因为'oon'是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。
                        /\w\b\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。
                        注意: JavaScript的正则表达式引擎将特定的字符集定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。

            \B	        匹配一个非单词边界。匹配如下几种情况：
                        字符串第一个字符为非“字”字符
                        字符串最后一个字符为非“字”字符
                        两个单词字符之间
                        两个非单词字符之间
                        空字符串
                        例如，/\B../匹配"noonday"中的'oo', 而/y\B../匹配"possibly yesterday"中的’yes‘

            \cX	        当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。
                        例如，/\cM/ 匹配字符串中的 control-M (U+000D)。

            \d	        匹配一个数字。等价于[0-9]。
                        例如， /\d/ 或者 /[0-9]/ 匹配"B2 is the suite number."中的'2'。

            \D          匹配一个非数字字符。等价于[^0-9]。
                        例如， /\D/ 或者 /[^0-9]/ 匹配"B2 is the suite number."中的'B' 。

            \f	        匹配一个换页符 (U+000C)。
            \n	        匹配一个换行符 (U+000A)。
            \r	        匹配一个回车符 (U+000D)。
            \s	        匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。
                        例如, /\s\w*/ 匹配"foo bar."中的' bar'。

            \S	        匹配一个非空白字符。等价于 [^ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。
                        例如，/\S\w*/ 匹配"foo bar."中的'foo'。

            \t	        匹配一个水平制表符 (U+0009)。
            \v	        匹配一个垂直制表符 (U+000B)。
            \w	        匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。
                        例如, /\w/ 匹配 "apple," 中的 'a'，"$5.28,"中的 '5' 和 "3D." 中的 '3'。

            \W	        匹配一个非单字字符。等价于 [^A-Za-z0-9_]。
                        例如, /\W/ 或者 /[^A-Za-z0-9_]/ 匹配 "50%." 中的 '%'。

            \n	        在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。
                        比如 /apple(,)\sorange\1/ 匹配"apple, orange, cherry, peach."中的'apple, orange,' 。

            \0	        匹配 NULL（U+0000）字符， 不要在这后面跟其它小数，因为 \0<digits> 是一个八进制转义序列。
            \xhh	    与代码 hh 匹配字符（两个十六进制数字）
            \uhhhh	    与代码 hhhh 匹配字符（四个十六进制数字）。
            \u{hhhh}	（仅当设置了u标志时）使用 Unicode 值 hhhh 匹配字符（十六进制数字）。
        Escaping（转义）
            如果你需要逐字地使用任何特殊字符（例如，实际上搜索'*'），你必须通过在它前面放一个反斜杠来逃避它。例如，要搜索'a'后跟'*'后跟'b'，你可以使用/ a \ * b /  - 反斜杠“转义”'*'，使其成为文字而非特殊。
            类似地，如果您正在编写正则表达式文字并且需要匹配斜杠（'/'），则需要转义它（否则，它会终止该模式）。例如，要搜索字符串“/ example /”后跟一个或多个字母字符，您需要使用/ \ / example \ / [a-z] + / i-每个斜杠之前的反斜杠使它们成为文字。
            要匹配文字反斜杠，您需要转义反斜杠。例如，要匹配字符串“C：\”，其中“C”可以是任何字母，您将使用/ [AZ]：\\ /  - 第一个反斜杠转义后面的那个，因此表达式搜索单个字面反斜杠。
            如果将RegExp构造函数与字符串文字一起使用，请记住反斜杠是字符串文字中的转义，因此要在正则表达式中使用它，您需要在字符串文字级别转义它。 / a \ * b /和新的RegExp（“a \\ * b”）创建相同的表达式，搜索“a”后跟文字“*”后跟“b”。
            将用户输入转义为正则表达式中的一个字面字符串, 可以通过简单的替换来实现：
                function escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); 
                //$&表示整个被匹配的字符串
                }
        使用插入语：
            任何正则表达式的插入语都会使这部分匹配的副字符串被记忆。一旦被记忆，这个副字符串就可以被调用于其它用途，如同 使用括号的子字符串匹配之中所述。
            比如， /Chapter (\d+)\.\d*/ 解释了额外转义的和特殊的字符，并说明了这部分pattern应该被记忆。它精确地匹配后面跟着一个以上数字字符的字符 'Chapter ' (\d 意为任何数字字符，+ 意为1次以上)，跟着一个小数点（在这个字符中本身也是一个特殊字符；小数点前的 \ 意味着这个pattern必须寻找字面字符 '.')，跟着任何数字字符0次以上。 (\d 意为数字字符， * 意为0次以上)。另外，插入语也用来记忆第一个匹配的数字字符。
            此模式可以匹配字符串"Open Chapter 4.3, paragraph 6"，并且'4'将会被记住。此模式并不能匹配"Chapter 3 and 4"，因为在这个字符串中'3'的后面没有点号'.'。
            括号中的"?:"，这种模式匹配的子字符串将不会被记住。比如，(?:\d+)匹配一次或多次数字字符，但是不能记住匹配的字符。
        使用正则表达式：
            正则表达式可以被用于 RegExp 的 exec 和 test 方法以及 String 的 match、replace、search 和 split 方法。这些方法在 JavaScript 手册中有详细的解释。
            使用正则表达式的方法
            方法	    描述
            exec	    一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。
            test	    一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。
            match	    一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。
            matchAll	一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。
            search	    一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。
            replace	    一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。
                        EG：
                            div.innerHTML=text.value.replace(/基情|gay/g,'**');//replace(),将'基情'和‘gay’替换为**；
            split	    一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。
            当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用 test 或 search 方法；想得到更多的信息（但是比较慢）则可以使用 exec 或 match 方法。如果你使用exec 或 match 方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象（详见下）。如果匹配失败，那么 exec 方法返回 null（也就是false）。
            在接下来的例子中，脚本将使用exec方法在一个字符串中查找一个匹配。
                var myRe = /d(b+)d/g;
                var myArray = myRe.exec("cdbbdbsbz");
            如果你不需要访问正则表达式的属性，这个脚本通过另一个方法来创建myArray：
                var myArray = /d(b+)d/g.exec("cdbbdbsbz");
                // similar to "cdbbdbsbz".match(/d(b+)d/g); however,
                // "cdbbdbsbz".match(/d(b+)d/g) outputs Array [ "dbbd" ], while 
                // /d(b+)d/g.exec('cdbbdbsbz') outputs Array [ "dbbd", "bb", index: 1, input: "cdbbdbsbz" ].
            如果你想通过一个字符串构建正则表达式，那么这个脚本还有另一种方法：
                var myRe = new RegExp("d(b+)d", "g");
                var myArray = myRe.exec("cdbbdbsbz");
            通过这些脚本，匹配成功后将返回一个数组并且更新正则表达式的属性，如下表所示。
            正则表达式执行后的返回信息
            对象	    属性或索引	     描述	                                        在例子中对应的值
            myArray		                匹配到的字符串和所有被记住的子字符串。              ["dbbd", "bb"]
                        index           在输入的字符串中匹配到的以0开始的索引值。	        1
                        input           初始字符串。	                                  "cdbbdbsbz"
                        [0]             匹配到的所有字符串（并不是匹配后记住的字符串）。     "dbbd"
                                        注：原文"The last matched characters."，
                                        应该是原版错误。匹配到的最终字符。       	
            myRe	    lastIndex	    下一个匹配的索引值。（这个属性只有在使用g参数时可
                                        用在 通过参数进行高级搜索 一：有详细的描述.)	    5
                        source	        模式文本。在正则表达式创建时更新，不执行。	        "d(b+)d"
            在这个例子中如第二种形式所示，你可以使用一个正则表达式创建一个没有分配给变量的对象初始化容器。如果你这样做，那么，每一次使用时都好比在使用一个新的正则表达式。因为这个原因，如果你使用这个未分配给一个变量的正则表达式，你将在随后不能访问这个正则表达式的属性。例如，假如你有如下脚本：
                var myRe = /d(b+)d/g;
                var myArray = myRe.exec("cdbbdbsbz");
                console.log("The value of lastIndex is " + myRe.lastIndex);
            这个脚本输出如下：
                The value of lastIndex is 5
            然而，如果你有如下脚本：
                var myArray = /d(b+)d/g.exec("cdbbdbsbz");
                console.log("The value of lastIndex is " + /d(b+)d/g.lastIndex);
            它显示为：
                The value of lastIndex is 0
            当发生/d(b+)d/g使用两个不同状态的正则表达式对象，lastIndex属性会得到不同的值。如果你需要访问一个正则表达式的属性，则需要创建一个对象初始化生成器，你应该首先把它赋值给一个变量。
            使用括号的子字符串匹配:
                一个正则表达式模式使用括号，将导致相应的子匹配被记住。例如，/a(b)c /可以匹配字符串“abc”，并且记得“b”。回调这些括号中匹配的子串，使用数组元素[1],……[n]。
                使用括号匹配的子字符串的数量是无限的。返回的数组中保存所有被发现的子匹配。下面的例子说明了如何使用括号的子字符串匹配。
                下面的脚本使用replace()方法来转换字符串中的单词。在匹配到的替换文本中，脚本使用替代的$ 1,$ 2表示第一个和第二个括号的子字符串匹配。
                var re = /(\w+)\s(\w+)/;
                var str = "John Smith";
                var newstr = str.replace(re, "$2, $1");
                console.log(newstr);
                这个表达式输出 "Smith, John"。
            通过标志进行高级搜索：
                正则表达式有四个可选参数进行全局和不分大小写搜索。这些参数既可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。
                正则表达式标志
                标志	描述
                g	    全局搜索。
                i	    不区分大小写搜索。
                m	    多行搜索。
                s	    允许 . 匹配换行符。
                u	    使用unicode码的模式进行匹配。
                y	    执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。
            为了在正则表达式中包含标志，请使用以下语法：
                var re = /pattern/flags;
            或者
                var re = new RegExp("pattern", "flags");
            值得注意的是，标志是一个正则表达式的一部分，它们在接下来的时间将不能添加或删除。
            例如，re = /\w+\s/g 将创建一个查找一个或多个字符后有一个空格的正则表达式，或者组合起来像此要求的字符串。
                var re = /\w+\s/g;
                var str = "fee fi fo fum";
                var myArray = str.match(re);
                console.log(myArray);
                // ["fee ", "fi ", "fo "]
            这段代码将输出 ["fee ", "fi ", "fo "]。在这个例子中，你可以将：
                var re = /\w+\s/g;
            替换成：
                var re = new RegExp("\\w+\\s", "g");
            并且能获取到相同的结果。
            使用.exec（）方法时，与'g'标志关联的行为是不同的。 （“class”和“argument”的作用相反：在.match（）的情况下，字符串类（或数据类型）拥有该方法，而正则表达式只是一个参数，而在.exec的情况下（），它是拥有该方法的正则表达式，其中字符串是参数。对比str.match（re）与re.exec（str）。）'g'标志与.exec（）方法一起使用获得迭代进展。
            var xArray; while(xArray = re.exec(str)) console.log(xArray);
            // produces: 
            // ["fee ", index: 0, input: "fee fi fo fum"]
            // ["fi ", index: 4, input: "fee fi fo fum"]
            // ["fo ", index: 7, input: "fee fi fo fum"]
            m标志用于指定多行输入字符串应该被视为多个行。如果使用m标志，^和$匹配的开始或结束输入字符串中的每一行，而不是整个字符串的开始或结束。
            总结1：附件参数g的用法 
                表达式加上参数g之后，表明可以进行全局匹配，注意这里“可以”的含义。我们详细叙述： 
                1）对于表达式对象的exec方法，不加入g，则只返回第一个匹配，无论执行多少次均是如此，如果加入g，则第一次执行也返回第一个匹配，再执行返回第二个匹配，依次类推。例如 
                    var regx=/user\d/; 
                    var str=“user18dsdfuser2dsfsd”; 
                    var rs=regx.exec(str);//此时rs的值为{user1} 
                    var rs2=regx.exec(str);//此时rs的值依然为{user1} 
                    如果regx=/user\d/g；则rs的值为{user1}，rs2的值为{user2} 
                    通过这个例子说明：对于exec方法，表达式加入了g，并不是说执行exec方法就可以返回所有的匹配，而是说加入了g之后，我可以通过某种方式得到所有的匹配，这里的“方式”对于exec而言，就是依次执行这个方法即可。 
                2）对于表达式对象的test方法，加入g于不加上g没有什么区别。 
                3）对于String对象的match方法，不加入g，也只是返回第一个匹配，一直执行match方法也总是返回第一个匹配，加入g，则一次返回所有的匹配（注意这与表达式对象的exec方法不同，对于exec而言，表达式即使加上了g，也不会一次返回所有的匹配）。例如： 
                    var regx=/user\d/; 
                    var str=“user1sdfsffuser2dfsdf”; 
                    var rs=str.match(regx);//此时rs的值为{user1} 
                    var rs2=str.match(regx);//此时rs的值依然为{user1} 
                    如果regx=/user\d/g，则rs的值为{user1,user2}，rs2的值也为{user1,user2} 
                4）对于String对象的replace方法，表达式不加入g，则只替换第一个匹配，如果加入g，则替换所有匹配。（开头的三道测试题能很好的说明这一点） 
                5）对于String对象的split方法，加上g与不加g是一样的，即： 
                    var sep=/user\d/; 
                    var array=“user1dfsfuser2dfsf”.split(sep); 
                    则array的值为{dfsf, dfsf} 
                    此时sep=/user\d/g，返回值是一样的。 
                6）对于String对象的search方法，加不加g也是一样的。 
            总结2：附加参数m的用法 
                附加参数m，表明可以进行多行匹配，但是这个只有当使用^和$模式时才会起作用，在其他的模式中，加不加入m都可以进行多行匹配（其实说多行的字符串也是一个普通字符串），我们举例说明这一点 
                1）使用^的例子 
                    var regx=/^b./g; 
                    var str=“bd76 dfsdf 
                    sdfsdfs dffs 
                    b76dsf sdfsdf”; 
                    var rs=str.match(regx); 
                    此时加入g和不加入g，都只返回第一个匹配{bd}，如果regx=/^b./gm，则返回所有的匹配{bd,b7}，注意如果regx=/^b./m，则也只返回第一个匹配。所以，加入m表明可以进行多行匹配，加入g表明可以进行全局匹配，综合到一起就是可以进行多行全局匹配 
                2）使用其他模式的例子，例如 
                    var regx=/user\d/; 
                    var str=“sdfsfsdfsdf 
                    sdfsuser3 dffs 
                    b76dsf user6”; 
                    var rs=str.match(regx); 
                    此时不加参数g，则返回{user3}，加入参数g返回{user3,user6}，加不加入m对此没有影响。 
                3）因此对于m我们要清楚它的使用，记住它只对^和$模式起作用，在这两种模式中，m的作用为：如果不加入m，则只能在第一行进行匹配，如果加入m则可以在所有的行进行匹配。我们再看一个^的例子 
                    var regx=/^b./; 
                    var str=“ret76 dfsdf 
                    bjfsdfs dffs 
                    b76dsf sdfsdf”; 
                    var rs=str.match(regx); 
                    此时rs的值为null，如果加入g，rs的值仍然为null，如果加入m，则rs的值为{bj}（也就是说，在第一行没有找到匹配，因为有参数m，所以可以继续去下面的行去找是否有匹配），如果m和g都加上，则返回{bj,b7}（只加m不加g说明，可以去多行进行匹配，但是找到一个匹配后就返回，加入g表明将多行中所有的匹配返回，当然对于match方法是如此，对于exec呢，则需要执行多次才能依次返回） 
            总结3：在HTML的textarea输入域中，按一个Enter键，对应的控制字符为“\r\n”，即“回车换行”，而不是“\n\r”，即“换行回车”，我们看一个前面我们举过的例子： 
                var regx=/a\r\nbc/; 
                var str=“a 
                bc”; 
                var rs=regx.exec(str); 
                结果：匹配成功，rs的值为：{ }，如果表达式为/a\n\rbc/，则不会被匹配，因此在一般的编辑器中一个”Enter”键代表着“回车换行”，而非“换行回车”，至少在textarea域中是这样的。
        例子：
            以下例子说明了一些正则表达式的用途。
            改变输入字符串的顺序：
                以下例子解释了正则表达式的构成和 string.split() 以及 string.replace()的用途。它会整理一个只有粗略格式的含有全名（名字首先出现）的输入字符串，这个字符串被空格、换行符和一个分号分隔。最终，它会颠倒名字顺序（姓氏首先出现）和list的类型。
                // 下面这个姓名字符串包含了多个空格和制表符，
                // 且在姓和名之间可能有多个空格和制表符。
                    var names = "Orange Trump ;Fred Barney; Helen Rigby ; Bill Abel ; Chris Hand ";
                    var output = ["---------- Original String\n", names + "\n"];
                // 准备两个模式的正则表达式放进数组里。
                // 分割该字符串放进数组里。
                // 匹配模式：匹配一个分号及紧接其前后所有可能出现的连续的不可见符号。
                    var pattern = /\s*;\s*/;
                // 把通过上述匹配模式分割的字符串放进一个叫做nameList的数组里面。
                    var nameList = names.split(pattern);
                // 新建一个匹配模式：匹配一个或多个连续的不可见字符及其前后紧接着由
                // 一个或多个连续的基本拉丁字母表中的字母、数字和下划线组成的字符串
                // 用一对圆括号来捕获该模式中的一部分匹配结果。
                // 捕获的结果稍后会用到。
                    pattern = /(\w+)\s+(\w+)/;
                // 新建一个数组 bySurnameList 用来临时存放正在处理的名字。
                    var bySurnameList = [];
                // 输出 nameList 的元素并且把 nameList 里的名字
                // 用逗号接空格的模式把姓和名分割开来然后存放进数组 bySurnameList 中。
                //
                // 下面的这个替换方法把 nameList 里的元素用 $2, $1 的模式
                // （第二个捕获的匹配结果紧接着一个逗号一个空格然后紧接着第一个捕获的匹配结果）替换了
                // 变量 $1 和变量 $2 是上面所捕获的匹配结果。
                    output.push("---------- After Split by Regular Expression");
                    var i, len;
                    for (i = 0, len = nameList.length; i < len; i++) {
                    output.push(nameList[i]);
                    bySurnameList[i] = nameList[i].replace(pattern, "$2, $1");
                    }
                // 输出新的数组
                    output.push("---------- Names Reversed");
                    for (i = 0, len = bySurnameList.length; i < len; i++){
                    output.push(bySurnameList[i]);
                    }
                // 根据姓来排序，然后输出排序后的数组。
                    bySurnameList.sort();
                    output.push("---------- Sorted");
                    for (i = 0, len = bySurnameList.length; i < len; i++){
                    output.push(bySurnameList[i]);
                    }
                    output.push("---------- End");
                    console.log(output.join("\n"));
            用特殊字符检验输入：
                在以下例子中，我们期望用户输入一个电话号码。当用户点击“Check”按钮，我们的脚本开始检查这些数字是否合法。如果数字合法（匹配正则表达式所规定的字符序列），脚本显示一条感谢用户的信息并确认该数字。如果这串数字不合法，脚本提示用户电话号码不合法。.
                包含非捕获括号 (?: 这个正则表达式寻找三个数字字符\d{3} 或者 | 一个左半括号\(跟着三位数字\d{3}, 跟着一个封闭括号 \), (结束非捕获括号 ))， 后跟着一个短破折号或正斜杠或小数点，随后跟随三个数字字符，当记忆字符 ([-\/\.])捕获并记住，后面跟着三位小数 \d{3}，再后面跟随记住的破折号、正斜杠或小数点 \1，最后跟着四位小数 \d{4}。
                当用户按下 Enter 设置 RegExp.input，这些变化也能被激活。
                    <!DOCTYPE html>
                    <html>  
                    <head>  
                        <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">  
                        <meta http-equiv="Content-Script-Type" content="text/javascript">  
                        <script type="text/javascript">  
                        var re = /(?:\d{3}|\(\d{3}\))([-\/\.])\d{3}\1\d{4}/;  
                        function testInfo(phoneInput) {  
                            var OK = re.exec(phoneInput.value);  
                            if (!OK)  
                            window.alert(phoneInput.value + ' isn\'t a phone number with area code!');  
                            else
                            window.alert('Thanks, your phone number is ' + OK[0]);  
                        }  
                        </script>  
                    </head>  
                    <body>  
                        <p>Enter your phone number (with area code) and then click "Check".
                            <br>The expected format is like ###-###-####.</p>
                        <form action="#">  
                        <input id="phone"><button onclick="testInfo(document.getElementById('phone'));">Check</button>
                        </form>  
                    </body>  
                    </html>
    13.使用JavaScript操作浏览器
            什么是BOM
            浏览器的顶级对象window
            页面加载事件及其注意事项
            两种定时器函数及其区别
            JS执行机制
            使用location对象完成页面之间跳转
            navigator对象涉及的属性
            使用history提供的方法实现页面刷新 
        浏览器对象模型
            JavaScript包含的对象可以分为3种类型
            用户对象：在JavaScript脚本中定义的对象
            内置对象：由系统预定义并内置到JavaScript内的对象。如：object，array，function，date，math，string，number，RegExp等
            宿主对象：捆绑到浏览器内的api组件定义的对象。这些对象与JavaScript语言并没有直接关系，但是在JavaScript脚本中可以访问和操作它们，如：window，document，navigator，screen，location，history，form等
            浏览器对象模型（Browser Object Model (BOM)）允许 JavaScript 与浏览器对话。
            BOM作用：
                弹出新的浏览器窗口，移动，关闭浏览器窗口与调整窗口大小（窗口对象）
                提供浏览器详细信息（导航对象）
                提供装载到浏览器页面的详细信息（定位对象）
                提供用户屏幕分辨率的详细信息（屏幕对象）
                对cookie的支持
            BOM对象         说明
            Window          JavaScript层级中的顶层对象。每当<body></body>或者<framest></framest>标签出现时，window对象就会被自动创建
            Navigator       包含客户端浏览器的详细信息
            Screen          包含客户端屏幕的详细信息
            History         包含浏览器访问过的URL
            Location        包含URL的信息
            Document        包含整个HTML文档，可被用来访问页面中的所有元素
            一. Window：
                window对象是浏览器的顶级模型，他有双重角色
                    它是JS访问浏览器的一个接口
                    它是一个全局对象，定义在全局作用域里的变量、函数都会变成window对象的属性和方法。在调用的时候可以省略window。
                1.window对象的属性
                    属性                含义 
                    closed              当窗口关闭时为真 
                    defaultStatus       窗口底部状态栏显示的默认状态消息 
                    document            窗口中当前显示的文档对象 
                    frames              窗口中的框架对象数组 
                    history             保存有窗口最近加载的URL 
                    length              窗口中的框架数 
                    location            当前窗口的URL 
                    name                窗口名 
                    offscreenBuffering  用于绘制新窗口内容并在完成后复制已存在的内容，控制屏幕更新 
                    opener              打开当前窗口的窗口 
                    parent              指向包含另一个窗口的窗口（由框架使用） 
                    screen              显示屏幕相关信息，如高度、宽度（以像素为单位） 
                    self                指示当前窗口。 
                    status              描述由用户交互导致的状态栏的临时消息 
                    top                 含特定窗口的最顶层窗口（由框架使用） 
                    window              指示当前窗口，与self等效          
                window对象的方法
                    方法                                            功能
                    alert(text)                                     创建一个警告对话框，显示一条信息
                    blur()                                          将焦点从窗口移除
                    clearInterval(interval)                         清除之前设置的定时器间隔
                    clearTimeOut(timer)                             清除之前设置的超时
                    close()                                         关闭窗口
                    confirm()                                       创建一个需要用户确认的对话框
                    focus()                                         将焦点移至窗口
                    open(url,name,[options])                        打开一个新窗口并返回新window对象
                    prompt(text,defaultInput)                       创建一个对话框要求用户输入信息
                    scroll(x,y)                                     在窗口中滚动到一个像素点的位置
                    setInterval(expression,milliseconds)            经过指定时间间隔计算一个表达式
                    setInterval(function,millisenconds,[arguments]) 经过指定时间间隔后调用一个函数
                    setTimeout(expression,milliseconds)             在定时器超过后计算一个表达式
                    setTimeout(expression,milliseconds,[arguments]) 在定时器超过时后计算一个函数
                    print()                                         调出打印对话框
                    find()                                          调出查找对话框
                    window下的属性和方法，可以使用window.属性、window.方法()或者直接属性、方法()的方式调用。例如：window.alert()和alert()是一个意思。
                2.系统对话框
                    浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示信息。系统对话框与浏览器中显示的网页没有关系，也不包含HTML。
                    //弹出警告
                        alert('Lee');//直接弹出警告
                    //确定和取消
                        confirm('请确定或者取消');//这里按哪个都无效
                        if (confirm('请确定或者取消')) {//confirm本身有返回值
                        alert('您按了确定！');//按确定返回true
                        } else {
                        alert('您按了取消！');//按取消返回false
                        }                 
                    //输入提示框
                        var num = prompt('请输入一个数字', 0);//两个参数，一个提示，一个值
                        alert(num);//返回值可以得到                 
                    //调出打印及查找对话框
                        print();//打印
                        find();//查找                 
                        defaultStatus = '状态栏默认文本';//浏览器底部状态栏初始默认值
                        status='状态栏文本';//浏览器底部状态栏设置值                 
                3.新建窗口
                    使用window.open()方法可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。它可以接受四个参数：1.要加载的URL；2.窗口的名称或窗口目标；3.一个特性字符串；4.一个表示新页面是否取代浏览器记录中当前加载页面的布尔值。
                        open('http://www.baidu.com');//新建页面并打开百度
                        open('http://www.baidu.com','baidu');//新建页面并命名窗口并打开百度
                        open('http://www.baidu.com','_parent');//在本页窗口打开百度,_blank是新建                 
                        PS：不命名会每次打开新窗口，命名的第一次打开新窗口，之后在这个窗口中加载。窗口目标是提供页面的打开的方式，比如本页面，还是新建。                 
                    第三字符串参数
                        设置                值                说明
                        width               数值                新窗口的宽度。不能小于100
                        height              数值                新窗口的高度。不能小于100
                        top                 数值                新窗口的Y坐标。不能是负值
                        left                数值                新窗口的X坐标。不能是负值
                        location            yes或no             是否在浏览器窗口中显示地址栏。不同浏览器默认值不同
                        menubar             yes或no             是否在浏览器窗口显示菜单栏。默认为no
                        resizable           yes或no             是否可以通过拖动浏览器窗口的边框改变大小。默认为no
                        scrollbars          yes或no             如果内容在页面中显示不下，是否允许滚动。默认为no
                        status              yes或no             是否在浏览器窗口中显示状态栏。默认为no
                        toolbar             yes或no             是否在浏览器窗口中显示工具栏。默认为no
                        fullscreen          yes或no              浏览器窗口是否最大化，仅限IE
                        //第三参数字符
                            open('http://www.baidu.com','baidu','width=400,height=400,top=200,left=200,toolbar=yes');
                        //open本身返回window对象    
                            var box = open();
                            box.alert('');//可以指定弹出的窗口执行alert();
                        //子窗口操作父窗口
                            document.onclick = function () {
                            opener.document.write('子窗口让我输出的！');
                            }                 
                        3.窗口的位置和大小
                            用来确定和修改window对象位置的属性和方法有很多。IE、Safari、Opera和Chrome都提供了screenLeft和screenTop属性，分别用于表示窗口相对于屏幕左边和上边的位置。Firefox则在screenX和screenY属性中提供相同的窗口位置信息，Safari和Chrome也同时支持这两个属性。                 
                            //确定窗口的位置,IE支持
                                alert(screenLeft);//IE支持
                                alert(typeof screenLeft);//IE显示number，不支持的显示undefined
                            //确定窗口的位置,Firefox支持
                                alert(screenX);//Firefox支持
                                alert(typeof screenX);//Firefox显示number,不支持的同上
                                PS：screenX属性IE浏览器不认识，直接alert(screenX)，screenX会当作一个为声明的变量，导致不执行。那么必须将它将至为window属性才能显示为初始化变量应有的值，所以应该写成：alert(window.screenX)。
                            //跨浏览器的方法
                                var leftX = (typeof screenLeft == 'number') ? screenLeft : screenX;
                                var topY = (typeof screenTop == 'number') ? screenTop : screenY;
                                窗口页面大小，Firefox、Safari、Opera和Chrome均为此提供了4个属性：innerWidth和innerHeight，返回浏览器窗口本身的尺寸；outerWidth和outerHeight，返回浏览器窗口本身及边框的尺寸。
                                alert(innerWidth);//页面长度
                                alert(innerHeight);//页面高度
                                alert(outerWidth);//页面长度+边框
                                alert(outerHeight);//页面高度+边框                         
                                PS：在Chrome中，innerWidth=outerWidth、innerHeight=outerHeight；
                                PS：IE没有提供当前浏览器窗口尺寸的属性；不过，在后面的DOM课程中有提供相关的方法。                         
                                在IE以及Firefox、Safari、Opera和Chrome中，document.documentElement.clientWidth和document.documentElement.clientHeight中保存了页面窗口的信息。
                                PS：在IE6中，这些属性必须在标准模式下才有效；如果是怪异模式，就必须通过document.body.clientWidth和document.body.clientHeight取得相同的信息。                         
                            //如果是Firefox浏览器，直接使用innerWidth和innerHeight
                                var width = window.innerWidth;//这里要加window，因为IE会无效
                                var height = window.innerHeight;                         
                                if (typeof width != 'number') {//如果是IE，就使用document
                                if (document.compatMode == 'CSS1Compat') {
                                width = document.documentElement.clientWidth;
                                height = document.documentElement.clientHeight;
                                } else {
                                width = document.body.clientWidth;//非标准模式使用body
                                height = document.body.clientHeight;
                                }
                                }                         
                                PS：以上方法可以通过不同浏览器取得各自的浏览器窗口页面可视部分的大小。document.compatMode可以确定页面是否处于标准模式，如果返回CSS1Compat即标准模式             
                            //调整浏览器位置
                                moveTo(0,0);//IE有效，移动到0,0坐标
                                moveBy(10,10);//IE有效，向下和右分别移动10像素                         
                            //调整浏览器大小
                                resizeTo(200,200);//IE有效，调正大小
                                resizeBy(200,200);//IE有效，扩展收缩大小                         
                                PS：由于此类方法被浏览器禁用较多，用处不大。
                4.间歇调用和超时调用
                    JavaScript是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。前者在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。
                    超时调用需要使用window对象的setTimeout()方法，它接受两个参数：要执行的代码和毫秒数的超时时间。
                        setTimeout("alert('Lee')", 1000);//不建议直接使用字符串                 
                        function box() {
                        alert('Lee');
                        }
                        setTimeout(box, 1000);//直接传入函数名即可                 
                        setTimeout(function () {//推荐做法
                        alert('Lee');
                        }, 1000);                 
                        PS：直接使用函数传入的方法，扩展性好，性能更佳。                 
                    调用setTimeout()之后，该方法会返回一个数值ID，表示超时调用。这个超时调用的ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。
                    要取消尚未执行的超时调用计划，可以调用clearTimeout()方法并将相应的超时调用ID作为参数传递给它。
                        var box = setTimeout(function () {//把超时调用的ID复制给box
                        alert('Lee');
                        }, 1000);                 
                        clearTimeout(box);//把ID传入，取消超时调用                 
                    间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。设置间歇调用的方法是setInterval()，它接受的参数与setTimeout()相同：要执行的代码和每次执行之前需要等待的毫秒数。
                        setInterval(function () {//重复不停执行
                        alert('Lee');
                        }, 1000);                 
                    取消间歇调用方法和取消超时调用类似，使用clearInterval()方法。但取消间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用将会一直执行到页面关闭。
                        var box = setInterval(function () {//获取间歇调用的ID
                        alert('Lee');
                        }, 1000);                 
                        clearInterval(box);//取消间歇调用                 
                    但上面的代码是没有意义的，我们需要一个能设置5秒的定时器，需要如下代码：
                        var num = 0;//设置起始秒
                        var max = 5;//设置最终秒                 
                        setInterval(function () {//间歇调用
                        num++;//递增num
                        if (num == max) {//如果得到5秒
                        clearInterval(this);//取消间歇调用，this表示方法本身
                        alert('5秒后弹窗！');
                        }
                        }, 1000);//1秒                 
                    一般认为，使用超时调用来模拟间歇调用是一种最佳模式。在开发环境下，很少使用真正的间歇调用，因为需要根据情况来取消ID，并且可能造成同步的一些问题，我们建议不使用间歇调用，而去使用超时调用。
                        var num = 0;
                        var max = 5;
                        function box() {
                        num++;
                        if (num == max) {
                        alert('5秒后结束！');
                        } else {
                        setTimeout(box, 1000);
                        }
                        }
                        setTimeout(box, 1000);//执行定时器                 
                        PS：在使用超时调用时，没必要跟踪超时调用ID，因为每次执行代码之后，如果不再设置另一次超时调用，调用就会自行停止。
            二．location对象
                location是BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。事实上，location对象是window对象的属性，也是document对象的属性；所以window.location和document.location等效。             
                    alert(location);//获取当前的URL             
                location对象的属性            
                    属性            描述的URL内容
                    hash            如果该部分存在，表示锚点部分，包括前导符（#）。例如：“#top”，指定在文档中锚记得名称
                    host            主机名：端口号。例如：“www.mysite.cn:80”
                    hostname        主机名,例如："www.mysite.cn"
                    href            整个URL,声明了当前显示文档的完整URL，与其他location属性只声明部分URL不同，把该属性设置为新的URL会使得浏览器读取并显示新的URL内容
                    pathname        路径名，例如：“news/index.asp”
                    port            端口号,例如：“80”
                    protocol        协议部分，声明了URL的协议部分，包括后缀的冒号。例如：“http：”
                    search          查询字符串，声明了URL的查询部分，包括前导问号。例如：“?id=123&name=location”
                location对象的方法
                    方法                功能
                    assign()            跳转到指定页面，与href等效
                    reload()            重载当前URL
                    repalce()           用新的URL替换当前页面
                location.hash = '#1';            //设置#后的字符串，并跳转
                    alert(location.hash);            //获取#后的字符串
                location.port = 8888;            //设置端口号，并跳转
                    alert(location.port);            //获取当前端口号，
                location.hostname = 'Lee';           //设置主机名，并跳转
                    alert(location.hostname);            //获取当前主机名，
                location.pathname = 'Lee';           //设置当前路径，并跳转
                    alert(location.pathname);            //获取当前路径，
                location.protocal = 'ftp:';          //设置协议，没有跳转
                    alert(location.protocol);            //获取当前协议
                location.search = '?id=5';           //设置?后的字符串，并跳转
                    alert(location.search);          //获取?后的字符串
                location.href = 'http://www.baidu.com';          //设置跳转的URL，并跳转
                    alert(location.href);            //获取当前的URL
                在Web开发中，我们经常需要获取诸如?id=5&search=ok这种类型的URL的键值对，那么通过location，我们可以写一个函数，来一一获取。
                    function getArgs() {
                    //创建一个存放键值对的数组
                        var args = [];
                    //去除?号
                        var qs = location.search.length > 0 ? location.search.substring(1) : '';
                    //按&字符串拆分数组
                        var items = qs.split('&');
                        var item = null, name = null, value = null;
                    //遍历
                        for (var i = 0; i < items.length; i++) {
                        item = items[i].split('=');
                        name = item[0];
                        value = item[1];
                    //把键值对存放到数组中去
                        args[name] = value;
                    }
                    return args;
                    }
                var args = getArgs();
                alert(args['id']);
                alert(args['search']);
                location.assign('http://www.baidu.com');//跳转到指定的URL
                location.reload();//最有效的重新加载，有可能从缓存加载
                location.reload(true);//强制加载，从服务器源头重新加载
                location.replace('http://www.baidu.com');//可以避免产生跳转前的历史记录
            三．history对象
                history对象是window对象的属性，它保存着用户上网的记录，从窗口被打开的那一刻算起。
                    history对象的属性
                        属性                描述URL中的哪部分
                        length              history对象中的记录数             
                    history对象的方法
                        方法            功能
                        back()            前往浏览器历史条目前一个URL，类似后退
                        forward()            前往浏览器历史条目下一个URL，类似前进
                        go(num)            浏览器在history对象中向前或向后
                function back() {//跳转到前一个URL
                    history.back();
                }
                function forward() {//跳转到下一个URL
                    history.forward();
                }
                function go(num) {//跳转指定历史记录的URL
                    history.go(num);
                }
                PS：可以通过判断history.length == 0，得到是否有历史记录。
            四. Navigator
                Navigator对象包含了浏览器的基本信息（如：名称，版本和系统等），通过window.Navigator方式可以访问。
                Navigator对象属性
                    属性            说明
                    appName         web浏览器的名称
                    appVersion      浏览器的版本号和其它版本信息。
                    userAgent       浏览器在它的USER-AGENT HTTP标题中发送的字符串。该属性通常包含appname和appversion属性的所有信息。
                    appCodeName     浏览器的代码名。Netscape使用Mozilla作为代码名，为了兼容，IE也采用这种方式。
                    platform        浏览器所在的操作系统
                下面的方法能够检测出当前主流的浏览器类型，包括IE,Opera,Safari,Chrome和FireFox
                    var ua=navigator.userAgent.toLowerCase();   //获取用户端信息
                    var info={
                        ie:/msie/.test(ua)&&!/opera/.teat(ua),  //匹配IE浏览器
                        op:/opera/.test(ua),                    //匹配Opera浏览器
                        sa:/version.*safari/.test(us),          //匹配Safari浏览器
                        ch:/chrome/.test(ua),                   //匹配Chrome浏览器
                        ff:/gecko?.test(ua)&&!/webkit/.test(ua) //匹配Firefox浏览器
                    };
                    然后调用该对象的属性，如果相应的属性为true，这说明对应该浏览器。否则就返回false。
                        (info.ie)&&alert("IE浏览器");
                        (info.op)&&alert("Opera浏览器");
                        (info.sa)&&alert("Safari浏览器");
                        (info.ch)&&alert("Chrome浏览器");
                        (info.ff)&&alert("Firefox浏览器");
            五.备注：
                1.窗口加载事件
                    window.onload=function(){}
                    或者
                    window.addEventListener('load',function(){});
                    window.onload是窗口（页面）加载事件，当文档内容完全加载完成就会触发该事件（包括图像、脚本文档、css文件等），就调用处理函数。
                    注意：
                        有了window.onload就可以把js代码写到页面元素的上方，因为onload就是等页面加载完毕才去执行处理函数。
                        window。onload传统注册事件只能写一次，如果有多个，会以最后一个window.onload为准。
                    附：
                        document.addEventListener('DOMCntenLoaded',function(){})
                        DOMCntenLoaded事件触发时，仅当DOM加载完毕，不包括样式表，图片，flash等，ie9以上才支持。
                        如果页面要加载的图片很多，从用户访问到onload触发可能要较长时间的等待，交互效果就不能实现，必然会影响用户体验。此时使用DOMContentload事件就比较合适，加载多少就能使用到JS脚本，标签加载完就能执行JS了，JS里的交互效果是不受影响的。
                    load和DOMContentload区别
                        load 等页面内容全部加载完毕才会执行。（包括页面DOM元素 flash css等 ）。
                        DOMCntenLoaded 只要DOM元素加载完毕就能执行，不用等待flash css 图片啊加载完成。加载速度更快。
                2.调整窗口大小事件
                    window.onresize=function(){}
                    window.addEventListener('resize',function(){});
                    窗口大小发生变化就会触发。
                    经常用来处理响应式布局。window.innerWidth当前浏览器窗口屏幕宽度。
                3.两种定时器
                    setTimeout()
                        window.setTimeout(调用函数，[延迟的毫秒数]);
                        setTimeout()方法用于设置一个定时器，该定时器在到期后执行调用函数。
                        //这个window在调用的时候可以省略
                        //这个延迟时间单位是毫秒比如（3000）注：写的时候不要写ms 但是这个参数可以省略 省略就默认是0，立即执行。
                        //调用函数可以调用外部函数名方法调用functionName或者'functionName()'调用函数。
                        //经常给定时器取个名 直接 var TimeName = setTimeout(*,*)；即可。
                        setTimeout()这个调用函数我们也称为回调函数callback
                            普通函数是按照代码顺序直接调用，这个函数需要的等待时间，到时才去调用。
                        停止setTimeout()定时器
                            window.clearTimeout(timeOutID);
                    setInterval()
                        window.setInterval(回调函数，[间隔的毫秒数])；
                        setInterval()方法重复调用一个函数，每隔一个间隔时间就调用一次回调函数。
                        暂停定时器
                            window.clearInterval(intervalID);
                            clearInterval()方法取消了先前调用的setinterval()建立的定时器
                        var begin=document.querySelector('.begin');
                        var stop=document.querySelector('.stop.');
                        var timer=null;
                        begin.addEventListener('click',function(){
                            timer=setInterval(function(){
                                console.log('000');
                            },1000);
                        })
                        stop.addEventListener('click',function(){
                            clearInterval(timer);
                        })
                4.JS执行队列
                    JS是单线程
                        JavaScript是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。前者在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。JavaScript最大的特点就是单线程。
                    同步和异步
                        同步任务
                            所有的同步任务都放在主线程上执行，形成一个执行栈。
                        异步任务
                            JS的异步任务是通过回调函数实现的。
                            一般而言，异步任务有以下3中类型。
                            1.普通事件，比如click resize
                            2.资源加载,比如load，error等
                            3.定时器，包括setIntval和setTimeout等。
                            异步任务相关的回调函数添加到任务队列中（任务队列也称之为消息队列）
                    JS执行机制
                        1.先将任务分为同步任务和异步任务，同步任务会被放到执行栈中，先执行执行栈中的同步任务
                        2.遇到回调函数或者异步任务会将其提交给异步进程来进行处理，异步进程等待你的鼠标点击，时间计时结束等异步事件的触发条件，事件触发后会将其放到消息队列中。等待同步任务执行完毕。
                        3.继续执行同步任务
                        4.一旦执行栈中的所有同步任务执行完毕，系统就会开始按序读取任务队列中的异步任务，于是被执行的异步任务结束等待状态，进入执行栈，开始执行。
                        5.主线程不断重复上面的第4步。主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。
                5.location对象
                    url:
                        url是统一资源定位符，对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。
                        下面是一些URL的示例：
                            https://developer.mozilla.org
                            https://developer.mozilla.org/en-US/docs/Learn/
                            https://developer.mozilla.org/en-US/search?q=URL
                        一个URL由不同的部分组成，其中一些是必须的，而另一些是可选的。让我们以下面这个URL为例看看其中最重要的部分：
                            http://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
                            Protocol
                                http:// 是协议。它表明了浏览器必须使用何种协议。它通常都是HTTP协议或是HTTP协议的安全版，即HTTPS。Web需要它们二者之一，但浏览器也知道如何处理其他协议，比如mailto:（打开邮件客户端）或者 ftp:（处理文件传输），所以当你看到这些协议时，不必惊讶。
                            Domaine Name（host）
                                www.example.com 是域名。 它表明正在请求哪个Web服务器。或者，可以直接使用IP address, 但是因为它不太方便，所以它不经常在网络上使用。.
                            Port
                                :80 是端口。 它表示用于访问Web服务器上的资源的技术“门”。如果Web服务器使用HTTP协议的标准端口（HTTP为80，HTTPS为443）来授予其资源的访问权限，则通常会被忽略。否则是强制性的。
                            Path to the file
                                path/to/myfile.html 是网络服务器上资源的路径。在Web的早期阶段，像这样的路径表示Web服务器上的物理文件位置。如今，它主要是由没有任何物理现实的Web服务器处理的抽象。
                            Parameters（query,以键值对方式提交）
                                ?key1=value1&key2=value2 是提供给网络服务器的额外参数。 这些参数是用 & 符号分隔的键/值对列表。在返回资源之前，Web服务器可以使用这些参数来执行额外的操作。每个Web服务器都有自己关于参数的规则，唯一可靠的方式来知道特定Web服务器是否处理参数是通过询问Web服务器所有者。
                            Anchor（fragment拼段）
                                #SomewhereInTheDocument 是资源本身的另一部分的锚点. 锚点表示资源中的一种“书签”，给浏览器显示位于该“加书签”位置的内容的方向。例如，在HTML文档上，浏览器将滚动到定义锚点的位置;在视频或音频文档上，浏览器将尝试转到锚代表的时间。值得注意的是，＃后面的部分（也称为片段标识符）从来没有发送到请求的服务器。
                    属性            描述的URL内容
                    hash            如果该部分存在，表示锚点部分，包括前导符（#）。例如：“#top”，指定在文档中锚点部分
                    host            主机名：端口号。例如：“www.mysite.cn:80”
                    hostname        主机名,例如："www.mysite.cn"
                    href            整个URL,声明了当前显示文档的完整URL，与其他location属性只声明部分URL不同，把该属性设置为新的URL会使得浏览器读取并显示新的URL内容
                    pathname        路径名，例如：“news/index.asp”
                    port            端口号,例如：“80”
                    protocol        协议部分，声明了URL的协议部分，包括后缀的冒号。例如：“http：”
                    search          查询字符串，声明了URL的查询部分，包括前导问号。例如：“?id=123&name=location”
                        


        DOM
            DOM是针对XML但经过扩展用于HTML的应用程序编程接口，文档对象模型。
            可以这样理解：DOM可以把HTML页面中的元素转成一个对象树，并且DOM定义了其他语言如何通过其规定的方式来访问HTML中的元素，以及修改HTML页面中的元素 
            换言之，HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准 
            在 HTML DOM 中，所有事物都是：点。DOM 是被视为：点树的 HTML 
            可以这么说：DOM是链接HTML和javaScript语言之间的桥梁，没有DOM javaScript无法访问HTML元素，也就无法创建动态HTML页面
            javaScript 和DOM的关系
            要改变页面的某个东西，JavaScript 就需要获得对 HTML 文档中所有元素进行访问的入口。这个入口，连同对 HTML 元素进行添加、移动、改变或移除的方法和属性，都是通过文档对象模型来获得的（DOM）
            DOM把整个页面映射成一个多层：点结构，HTML页面中的每一个组成部分都是某种类型的：点，这些点也包含这不同类型的数据 
            当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model） 
            HTML DOM 模型被构造为对象的树（就是HTML各个元素构成的树状结构）
            dom：点类型
                元素：点            　　Node.ELEMENT_NODE(1)
                属性：点            　　Node.ATTRIBUTE_NODE(2)
                文本：点            　　Node.TEXT_NODE(3)
                CDATA：点               Node.CDATA_SECTION_NODE(4)
                实体引用名称：点    　　 Node.ENTRY_REFERENCE_NODE(5)
                实体名称：点        　　Node.ENTITY_NODE(6)
                处理指令：点        　　Node.PROCESSING_INSTRUCTION_NODE(7)
                注释：点            　 Node.COMMENT_NODE(8)
                文档：点            　 Node.DOCUMENT_NODE(9)
                文档类型：点        　　Node.DOCUMENT_TYPE_NODE(10)
                文档片段：点        　　Node.DOCUMENT_FRAGMENT_NODE(11)
                DTD声明：点            Node.NOTATION_NODE(12)
二.web API
    document.getElementById
        Document的方法 getElementById()返回一个匹配特定 ID的元素. 由于元素的 ID 在大部分情况下要求是独一无二的，这个方法自然而然地成为了一个高效查找特定元素的方法。
        如果需要查找到那些没有ID 的元素，你可以考虑通过CSS选择器使用 querySelector()。
        语法：
            var element = document.getElementById(id);
        参数：
            element是一个 Element 对象。如果当前文档中拥有特定ID的元素不存在则返回null.
            id是大小写敏感的字符串，代表了所要查找的元素的唯一ID.
        返回值：
            返回一个匹配到 ID 的 DOM Element 对象。若在当前 Document 下没有找到，则返回 null。 （返回的是一个元素对象）  
            console.dir();//打印元素对象，更好的查看元素里面的函数和方法和属性。
        示例：
        HTML：
            <!DOCTYPE html>
            <html>
            <head>
            <title>getElementById example</title>
            </head>
            <body>
            <p id="para">Some text here</p>
            <button onclick="changeColor('blue');">blue</button>
            <button onclick="changeColor('red');">red</button>
            </body>
            </html>
        JavaScript：
            function changeColor(newColor) {
            ​  var elem = document.getElementById('para');
            elem.style.color = newColor;
            }
        注意：
            对 “Id” 的拼写一定要正确。无论看起来多么合情合理，getElementByID() 都是不合理的且永远都不会工作的。
            不同于其他 Element 查找方法（如Document.querySelector() 以及 Document.querySelectorAll()），getElementById() 只有在作为 document 的方法时才能起作用，而在DOM中的其他元素下无法生效。这是因为 ID 值在整个网页中必须保持唯一。因此没有必要为这个方法创建所谓的 “局部” 版本。
        示例：
            <!doctype html>
            <html>
            <head>
                <meta charset="UTF-8">
                <title>Document</title>
            </head>
            <body>
                <div id="parent-id">
                    <p>hello word1</p>
                    <p id="test1">hello word2</p>
                    <p>hello word3</p>
                    <p>hello word4</p>
                </div>
                <script>
                    var parentDOM = document.getElementById('parent-id');
                    var test1=parentDOM.getElementById('test1');
                    //抛出错误
                    //（这是一条错误信息）Uncaught TypeError: parentDOM.getElementById is not a function
                </script>
            </body>
            </html>
            如果没有查找到对应的元素，方法会返回null。注意ID参数是大小写敏感的，所以document.getElementById("Main")无法获取到元素<div id="main">，因为'M'和'm'是不一样的。
            getElementById方法不会搜索不在文档中的元素。当创建一个元素，并且分配ID后，你必须要使用insertBefore或其他类似的方法把元素插入到文档中，之后才能使用 getElementById 获取到:
                var element = document.createElement("div");
                element.id = 'testqq';
                var el = document.getElementById('testqq'); // el 是个 null
            非HTML文档（Non-HTML documents）。 DOM的实现必须说明哪个属性是ID类型。只有DTD定义了'id'是ID属性时’id‘才会被认为是ID属性。在 XHTML, XUL或者其他文档中，'id'通常被定义为ID类型的属性。不知道哪个属性是ID类型的实现中，这会返回null结果。
    element.getElementsByTagName
        Element.getElementsByTagName() 方法返回一个动态的包含所有指定标签名的元素的HTML集合HTMLCollection。指定的元素的子树会被搜索，不包括元素自己。返回的列表是动态的，这意味着它会随着DOM树的变化自动更新自身。所以，使用相同元素和相同参数时，没有必要多次的调用Element.getElementsByTagName() .（返回的是元素集合，以伪数组存储）
        如果是HTML文档中的某个元素调用了getElementsByTagName函数， 运行前会将参数转为小写字母形式。故不建议在驼峰式命名的SVG元素中使用。 Element.getElementsByTagNameNS() 适用于那种情况.
        Element.getElementsByTagName 和 Document.getElementsByTagName()类似，除了它的搜索被限制为指定元素的后代。
        语法：
            elements = element.getElementsByTagName(tagName)
            elements 搜索到的元素的动态HTML集合HTMLCollection，它们的顺序是在子树中出现的顺序。 如果没有搜索到元素则这个集合为空。
            element 搜索从element开始。请注意只有element的后代元素会被搜索，不包括元素自己。
            tagName 要查找的限定名。 字符 "*" 代表所有元素。 考虑到兼容XHTML，应该使用小写。
        实例：
            // check the alignment on a number of cells in a table. 
            var table = document.getElementById("forecast-table"); 
            var cells = table.getElementsByTagName("td"); 
            for (var i = 0; i < cells.length; i++) { 
                var status = cells[i].getAttribute("data-status"); 
                if ( status == "open" ) { 
                    // grab the data 
                }
            }
        补充：
            参数是字符串，所以需要加引号d
            得到的是对象的集合，可以用遍历来获取所有对象
            得到的是动态的 例子: 获取ol里面的li
            <ol>
            <li>123一二三四五</li>
            <li>123上山打老虎</li>
            <li>123老虎有几只</li>
            <li>123快来数一数</li>
            <li>123一二三四五</li>
            </ol>
            <script>
            var ol = document.getElementsByTagName('ol');
            //伪数组不能做父元素
            var list = ol[0].getElementsByTagName('li');
            console.log(list);
            console.dir(list);
    通过HTML5新增的方法获取
        Document.getElementsByClassName()
            返回一个包含了所有指定类名的子元素的类数组对象。当在document对象上调用时，会搜索整个DOM文档，包含根：点。你也可以在任意元素上调用getElementsByClassName() 方法，它将返回的是以当前元素为根：点，所有指定类名的子元素。
            语法：
                var elements = document.getElementsByClassName(names); // or:
                var elements = rootElement.getElementsByClassName(names);
                elements 是一个实时集合，包含了找到的所有元素。
                names 是一个字符串，表示要匹配的类名列表；类名通过空格分隔
                getElementsByClassName 可以在任何元素上调用，不仅仅是 document。 调用这个方法的元素将作为本次查找的根元素.
            示例：
                获取所有 class 为 'test' 的元素:
                    document.getElementsByClassName('test');
                获取所有 class 同时包括 'red' 和 'test' 的元素.
                    document.getElementsByClassName('red test');
                在id 为'main'的元素的子：点中，获取所有class为'test'的元素
                    document.getElementById('main').getElementsByClassName('test');
                我们还可以对任意的  HTMLCollection 使用 Array.prototype 的方法，调用时传递  HTMLCollection 作为方法的参数。这里我们将查找到所有       class为 'test' 的 div 元素:
                        var testElements = document.getElementsByClassName('test');
                        var testDivs = Array.prototype.filter.call(testElements, function(testElement){
                        return testElement.nodeName === 'DIV';
                        });
                获取类名为test的元素列表：
                这是 getElementsByClassName() 的通常用法：
                    <html>
                    <body>
                        <div id="parent-id">
                            <p>hello world 1</p>
                            <p class="test">hello world 2</p>
                            <p>hello world 3</p>
                            <p>hello world 4</p>
                        </div>
                        <script>
                            var parentDOM = document.getElementById("parent-id");
                            var test = parentDOM.getElementsByClassName("test"); // 匹配类名的元素集合，不是元素本身
                            console.log(test); //HTMLCollection[1]
                            var testTarget = parentDOM.getElementsByClassName("test")[0]; // 我们想要取到的第一个元素
                            console.log(testTarget); //<p class="test">hello world 2</p>
                        </script>
                    </body>
                    </html>
        document.querySelector()
            文档对象模型Document引用的querySelector()方法返回文档中与指定选择器或选择器组匹配的第一个 html元素Element。 如果找不到匹配项，则返回null。
            提示: 匹配是使用文档：点的深度优先预先遍历遍历从文档标记中的第一个元素开始，并按子：点数量的顺序迭代顺序：点。
            语法：
                element = document.querySelector(selectors);
            参数：
                selectors
                包含一个或多个要匹配的选择器的 DOM字符串DOMString。 该字符串必须是有效的CSS选择器字符串；如果不是，则引发SYNTAX_ERR异常。请参阅使用选择器定位DOM元素以获取有关选择器以及如何管理它们的更多信息。
                提示:必须使用反斜杠字符转义不属于标准CSS语法的字符。 由于JavaScript也使用退格转义，因此在使用这些字符编写字符串文字时必须特别小心。 有关详细信息，请参阅Escaping special characters。
            返回值：
                表示文档中与指定的一组CSS选择器匹配的第一个元素的 html元素Element对象。
                如果您需要与指定选择器匹配的所有元素的列表，则应该使用querySelectorAll() 。
            异常：
                SYNTAX_ERR
                指定selectors的语法无效。
            注意：
                如果选择器是一个 ID，并且这个 ID 在文档中错误地使用了多次，那么返回第一个匹配该 ID 的元素。
                CSS 伪类不会返回任何元素，见 Selectors API 中的相关规定。
            转义特殊字符：
                如果要匹配的ID或选择器不符合 CSS 语法（比如不恰当地使用了冒号或者空格），你必须用反斜杠将这些字符转义。由于 JavaScript 中，反斜杠是转义字符，所以当你输入一个文本串时，你必须将它转义两次（一次是为 JavaScript 字符串转义，另一次是为 querySelector 转义）：
                    <div id="foo\bar"></div>
                    <div id="foo:bar"></div>
                    <script>
                    console.log('#foo\bar')               // "#fooar"
                    document.querySelector('#foo\bar')    // 不匹配任何元素
                    console.log('#foo\\bar')              // "#foo\bar"
                    console.log('#foo\\\\bar')            // "#foo\\bar"
                    document.querySelector('#foo\\\\bar') // 匹配第一个div元素
                    document.querySelector('#foo:bar')    // 不匹配任何元素
                    document.querySelector('#foo\\:bar')  // 匹配第二个div
                    </script>
            示例：
                查找第一个匹配 class属性的html元素：
                这个例子中，会返回当前文档中第一个类名为 "myclass" 的元素：
                    var el = document.querySelector(".myclass");
            一个更复杂的选择器：
                选择器也可以非常强大，如以下示例所示.
                这里, 一个class属性为"user-panel main"的div元素<div>(<div class="user-panel main">)内包含一个name属性为"login"的input元素<input> (<input name="login"/>) ，如何选择，如下所示:
                    var el = document.querySelector("div.user-panel.main input[name='login']");
        Document.querySelectorAll
            概述：
                返回与指定的选择器组匹配的文档中的元素列表 (使用深度优先的先序遍历文档的：点)。返回的对象是 NodeList 。
                注意：此方法基于ParentNode mixin的querySelectorAll() 实现。
            语法：
                elementList = parentNode.querySelectorAll(selectors);
                Parameters：
                selectors
                    一个 DOMString 包含一个或多个匹配的选择器。这个字符串必须是一个合法的 CSS selector 如果不是，会抛出一个 SyntaxError 错误。有关使用选择器标识元素的更多信息，请参阅 Locating DOM elements using selectors 可以通过使用逗号分隔多个选择器来指定它们。
                    注意： 必须使用反斜杠字符转义不属于标准CSS语法的字符。 由于JavaScript也使用反斜杠转义，因此在使用这些字符编写字符串文字时必须特别小心。 有关详细信息，请参阅 Escaping special characters
            返回值：
                一个静态 NodeList，包含一个与至少一个指定选择器匹配的元素的Element对象，或者在没有匹配的情况下为空NodeList
                注意： 如果selectors参数中包含 CSS伪元素，则返回的列表始终为空。
            另外：
                SyntaxError
                    如果指定的 选择器 不合法，会抛出错误。如$("##div")
            例子：
                获取匹配列表：
                要获取文档中所有<p>元素的NodeList
                    var matches = document.querySelectorAll("p");
                此示例返回文档中所有<div>元素的列表，其中class包含"note"或"alert"：
                    var matches = document.querySelectorAll("div.note, div.alert");
                在这里，我们得到一个<p>元素的列表，其直接父元素是一个class为"highlighted"的div，并且位于ID为"test"的容器内。
                    var container = document.querySelector("#test");
                    var matches = container.querySelectorAll("div.highlighted > p");
                此示例使用属性选择器返回文档中属性名为"data-src"的iframe元素列表：
                    var matches = document.querySelectorAll("iframe[data-src]");
                这里，属性选择器用于返回ID为"userlist"的列表中包含值为"1"的"data-active"属性的元素
                    var container = document.querySelector("#userlist");
                    var matches = container.querySelectorAll("li[data-active='1']");
            访问匹配项：
                一旦返回匹配元素的NodeList，就可以像任何数组一样检查它。 如果数组为空（即，其length属性为0），则找不到匹配项。
                否则，您只需使用标准数组方法来访问列表的内容。 您可以使用任何常见的循环语句，例如：
                    var highlightedItems = userList.querySelectorAll(".highlighted");
                    highlightedItems.forEach(function(userItem) {
                    deleteUser(userItem);
                    });
            用户备注：
                querySelectorAll() 的行为与大多数常见的JavaScript DOM库不同，这可能会导致意外结果。
                HTML：
                    考虑这个HTML及其三个嵌套的<div>块
                    <div class="outer">
                    <div class="select">
                        <div class="inner">
                        </div>
                    </div>
                    </div>
                JavaScript：
                    var select = document.querySelector('.select');
                    var inner = select.querySelectorAll('.outer .inner');
                    inner.length; // 1, not 0!
                在这个例子中，当在<div>上下文中选择带有"select"类的".outer .inner"时，仍然会找到类".inner"的元素，即使.outer不是基类的后代 执行搜索的元素（".select"）。 默认情况下，querySelectorAll()仅验证选择器中的最后一个元素是否在搜索范围内。
                    :scope 伪类符合预期的行为，只匹配基本元素后代的选择器：
                    var select = document.querySelector('.select');
                    var inner = select.querySelectorAll(':scope .outer .inner');
                    inner.length; // 0
    获取特殊元素
        获取body元素
            document.body       //返回body元素对象
        获取HTML元素
            document.documentElement        //返回HTML元素对象
    HTMLElement.innerText
        innerText 属性表示一个：点及其后代的“渲染”文本内容，它近似于用户使用光标突出显示元素内容然后将其复制到剪贴板时将获得的文本。
            //当我们点击了按钮，div里面的文字会发生变化。
            //1.获取元素
                var btn=document.querySelector('button');
                var div=document.querySelector('div');
            //2.事件注册
                btn.onclick =function(){
                    div.innerText='2019-8-21';
                }
            //元素可以不用绑定事件
                var p=document.querySelector('p');
                p.innerText='5555116';
        例子：
            这个示例对比了 innerText 和 Node.textContent. 这时 innerText 代表的含义就像 <br> 标签, 并且忽略了隐藏的元素.
            HTML：
                <h3>Source element:</h3>
                <p id="source">
                <style>#source { color: red; }</style>
                Take a look at<br>how this text<br>is interpreted
                    below.
                <span style="display:none">HIDDEN TEXT</span>
                </p>
                <h3>Result of textContent:</h3>
                <textarea id="textContentOutput" rows="6" cols="30" readonly>...</textarea>
                <h3>Result of innerText:</h3>
                <textarea id="innerTextOutput" rows="6" cols="30" readonly>...</textarea>
            JavaScript：
                const source = document.getElementById('source');
                const textContentOutput = document.getElementById('textContentOutput');
                const innerTextOutput = document.getElementById('innerTextOutput');
                textContentOutput.innerHTML = source.textContent;
                innerTextOutput.innerHTML = source.innerText;
    Element.innerHTML
        从起始位置到终止位置的全部内容，包括Html标签，同时保留空格和换行
        能识别HTML标签
        可读写的，可以获取元素里面的内容
    document 对象中有innerHTML和innerText 两个属性， 这两个属性都是获取document对象的文本内容的，这两个属性间有哪些区别呢？通过几个例子来看一下。
        示例1
            <html>
                <head><title>innerHTML</title></head>
                <body>
                    <p id="p1">hello world </p>
                    <script>
                        var content = document.getElementById("p1");
                        alert(content.innerHTML);
                        alert(content.innerText)
                    </script>
                </body>
            </html>
            通过IE浏览器打开，弹出内容为 "hello world" 和 "hello world"
            通过 Firefox 浏览器打开，弹出内容为 "hello world" 和 "undefined"
            通过 chrome 浏览器打开，弹出内容为 "hello world" 和 "hello world"
        示例2
            <html>
                <head><title>innerHTML</title></head>
                <body>
                    <div id="d1"><p id="p1">hello world </p></div>
                    <script>
                        var content = document.getElementById("d1");
                        alert(content.innerHTML);
                        alert(content.innerText)
                    </script>
                </body>
            </html>
            通过IE浏览器打开，弹出内容为 <p id="p1">hello world </p> 和 hello world
            通过 Firefox 浏览器打开，弹出内容为 <p id="p1">hello world </p> 和 undefined
            通过 chrome 浏览器打开，弹出内容为 <p id="p1">hello world </p> 和 hello world
        通过上面两个示例，可以看出：
            innerHTML   指的是从对象的起始位置到终止位置的全部内容,包括Html标签。
            innerText   指的是从起始位置到终止位置的内容,但它去除Html标签。
            同时，innerHTML 是所有浏览器都支持的，innerText 是IE浏览器和chrome 浏览器支持的，Firefox浏览器不支持。其实，innerHTML 是W3C 组织规定的属性；而innerText 属性是IE浏览器自己的属性，不过后来的浏览器部分实现这个属性罢了。
        outerHTML
            说到innerHTML，顺便说一下跟innerHTML相对的outerHTML属性。
            继续看上面的代码，将alert(content.innerText) 修改为 alert(content.outerHTML)
            通过浏览器可以看到弹出框为<p id="p1">hello world </p>
            和 <divid="d1"><p id="p1">hello world</p></div>
            outerHTML指的是除了包含innerHTML的全部内容外, 还包含对象标签本身。
        总结说明
            　　innerHTML是符合W3C标准的属性，而innerText只适用于IE浏览器（现在也适应chrome浏览器），因此，尽可能地去使用 innerHTML，而少用innerText，如果要输出不含HTML标签的内容，可以使用innerHTML取得包含HTML标签的内容后，再用正则表达式去除HTML标签，下面是一个简单的符合W3C标准的示例：
            <html>
                <head><title>innerHTML</title></head>
                <body>
                    <div id="d1"><p id="p1">hello world </p></div>
                    <script>
                        var content = document.getElementById("p1");
                        alert(content.innerHTML.replace(/& lt;.+?>/gim,''));
                    </script>
                </body>
            </html>
            弹出的为去掉了html标签之后的内容，这是个在所有浏览器均可使用的方法。
        insertAdjacentHTML() 将指定的文本解析为HTML或XML，并将结果节点插入到DOM树中的指定位置。它不会重新解析它正在使用的元素，因此它不会破坏元素内的现有元素。这避免了额外的序列化步骤，使其比直接innerHTML操作更快。
            语法：
                element.insertAdjacentHTML(position, text);
                    position是相对于元素的位置，并且必须是以下字符串之一：
                'beforebegin'
                    元素自身的前面。
                'afterbegin'
                    插入元素内部的第一个子节点之前。
                'beforeend'
                    插入元素内部的最后一个子节点之后。
                'afterend'
                    元素自身的后面。
                text是要被解析为HTML或XML,并插入到DOM树中的字符串。
                    EG：
                        // <div id="one">one</div> 
                        var d1 = document.getElementById('one'); 
                        d1.insertAdjacentHTML('afterend', '<div id="two">two</div>');
                        // 此时，新结构变成： // <div id="one">one</div><div id="two">two</div>
                        // ES6 version
                        // let html = `<div id="two">two</div>`;
                        // div.insertAdjacentHTML(`beforeend`, html);
    表单元素属性操作：
        利用DOM可以操作如下表单元素属性。
            type value checked selected disabled
            disabled 让某个表单被禁用，不能被点击， 用法：
                btn.onclick = function () {
                    btn.disabled = true;
                    //或者写成下面这种
                    this.disabled = true;
                    //this指向的是时间函数的调用者
                }
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta http-equiv="X-UA-Compatible" content="ie=edge">
                <title>Document</title>
                <style>
                    .box{
                        position: relative;
                        width: 400px;
                        border-bottom: 1px solid #ccc;
                        margin: 100px auto;
                    }
                    .box input{
                        width: 368px;
                        height: 32px;
                        border: 0;
                        outline: none;
                    }
                    .box img{
                        position: absolute;
                        top: 6px;
                        right: 2px;
                        width: 20px;
                    }
                </style>
            </head>
            <body>
                <div class="box">
                    <label for="">
                        <img src="/png/yanjing-bi.png" alt="" id="eye">
                    </label>
                    <input type="password" name="" id="psw">
                </div>
                <script>
                    var eye=document.getElementById('eye');
                    var psw=document.getElementById('psw');
                    var flag=true;
                    eye.onclick=function(){
                        if(flag==true){
                            psw.type='text';
                            eye.src='/png/yanjing-shi.png';
                            flag=false;
                            return;
                        }
                        else{
                            psw.type='password';
                            eye.src='/png/yanjing-bi.png';
                            flag=true;
                            return;
                        }
                    }
                </script>
            </body>
            </html>
    修改样式属性
        element.style
            行内样式操作，修改元素样式，如果样式比较少或者功能简单的情况下使用 注意：
            里面的属性是驼峰命名法
            JS修改的是行内样式，权重比CSS的高
        element.className
            类名样式操作，适合样式比较多的情况下使用 修改了元素的类名
            **注意：**这个方法直接修改了类名，也就是说会覆盖原来的类名，原来的就不生效了 如果想要保留原先的类名，这样做：
            //假设first 是原来的类名，change是想加入的
            this.className = 'first change';
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>Document</title>
            <style>
                .box{
                    position: relative;
                    width: 400px;
                    border-bottom: 1px solid #ccc;
                    margin: 100px auto;
                }
                .box input{
                    width: 368px;
                    height: 32px;
                    border: 0;
                    outline: none;
                }
                .box img{
                    position: absolute;
                    top: 6px;
                    right: 2px;
                    width: 20px;
                }
                .box2{
                    width: 300px;
                    margin: 100px auto;
                }
                .box2 li{
                    float: left;
                    width:48px;
                    height: 48px;
                    margin: 2px;
                    background: url(/png/2019.png) no-repeat;
                    list-style-type:none;
                }
            </style>
        </head>
        <body>
            <div class="box">
                <label for="">
                    <img src="/png/yanjing-bi.png" alt="" id="eye">
                </label>
                <input type="password" name="" id="psw">
            </div>
            <div class="box2">
                <ul>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                </ul>
            </div>
            
            <script>
                var eye=document.getElementById('eye');
                var psw=document.getElementById('psw');
                var flag=true;
                eye.onclick=function(){
                    if(flag==true){
                        psw.type='text';
                        eye.src='/png/yanjing-shi.png';
                        flag=false;
                        return;
                    }
                    else{
                        psw.type='password';
                        eye.src='/png/yanjing-bi.png';
                        flag=true;
                        return;
                    }
                }
                var lis=document.querySelectorAll('li');
                for(var i=0;i<lis.length;i++){
                    var y=i*(-48);
                    var stringP='0'+' '+y.toString()+'px';
                    lis[i].style.backgroundPosition=stringP;
                }
            </script>
        </body>
        </html>
    操作元素
        获取属性值
            var div=document.querySelector('div');
            element.属性 获取内置属性值（元素自带的属性）
                console.log(div.id);
            element.getAttribute('属性')	主要获取自定义的属性（标准），我们定义的属性
                console.log(div.getAttribute('id')); 
        设置属性值
            element.属性 = '值'；
            element.setAttribute('属性', '值')	主要更改自定义的属性
        移除属性值
            element.removeAttribute('属性')	主要移除自定义的属性（标准）
        tab栏demo：
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta http-equiv="X-UA-Compatible" content="ie=edge">
                <title>Document</title>
                <style>
                    body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,select,p,blockquote,th,td{
                        margin:0;
                        padding:0;
                    }
                    ul li{
                        list-style-type:none;
                    }
                    .tab{
                        width: 700px;
                        margin: 100px auto;
                    }
                    .tab .tab_list{
                        height: 30px;
                        position: relative;
                        border-bottom: 2px solid rgb(146, 28, 7);
                        text-align: center;
                        line-height:30px;
                        background: rgb(228, 228, 228);
                    }
                    .tab_list li{
                        width: 130px;
                        height: 30px;
                        float: left;
                        cursor: pointer;
                    }
                    .tab_list .current{
                        background: rgb(146, 28, 7);
                        color: azure;
                    }
                    .item{
                        display: none;
                    }
                </style>
            </head>
            <body>
                <div class="tab">
                    <div class="tab_list">
                        <ul>
                            <li class="current">商品介绍</li>
                            <li>规格与包装</li>
                            <li>售后与保障</li>
                            <li>商品评价</li>
                            <li>手机社区</li>
                        </ul>
                    </div>
                    <div class="tab_con">
                        <div class="item" style="display: block">
                            商品介绍模块内容Lorem ipsum dolor sit amet.
                        </div>
                        <div class="item">
                            规格与包装Lorem ipsum dolor sit amet consectetur adipisicing elit. A, vero.
                        </div>
                        <div class="item">
                            Lorem ipsum, dolor sit amet consectetur adipisicing elit. Accusantium corrupti eveniet praesentium tenetur neque quasi officiis ducimus doloribus. Dignissimos, neque.lorem12 Lorem ipsum dolor sit amet consectetur, adipisicing elit. Placeat neque repudiandae debitis cumque magnam.
                        </div>
                        <div class="item">
                            Lorem ipsum dolor sit amet consectetur adipisicing elit. Similique soluta, nulla at facilis libero molestiae. Lorem ipsum dolor, sit amet consectetur adipisicing elit. Rem temporibus dolor voluptates nostrum repellat asperiores in veniam architecto alias maxime.
                        </div>
                        <div class="item">
                            Lorem ipsum dolor sit amet consectetur adipisicing elit. Lorem ipsum dolor sit amet consectetur adipisicing elit. Id, iure! Dicta dolor quod totam?
                        </div>
                    </div>
                </div>
                <script>
                    var tab_list=document.querySelector('.tab_list');
                    var lit=tab_list.querySelectorAll('li');
                    var items=document.querySelectorAll('.item')
                    for(var i=0;i<lit.length;i++){
                        lit[i].setAttribute('index',i);
                        lit[i].onclick=function(){
                            for(var i=0;i<lit.length;i++){
                                lit[i].className='';
                            }
                            this.className='current';
                            var index=this.getAttribute('index');
                            for(var i=0;i<lit.length;i++){
                                items[i].style.display='none';
                            }
                            items[index].style.display='block';
                        }
                    }
                </script>
            </body>
            </html>
    H5自定义属性
        自定义属性目的：为了保存并使用数据，有些数据保存到页面中，为不是数据库中
        设置H5自定义属性
            但是有些自定义属性容易引以歧义，不容易判断是内置属性还是自定义属性，所以H5给我们新增了自定义属性 H5规定自定义属性以 “data-” 开头
        获取H5自定义属性
            兼容性：element.getAttribute('属性')
            H5新增：element.dataset.index 或者 element.dataset[ 'index' ]
        注意：
            //如果自定义属性里面有多个-连接的单词，我们获取的时候采取 驼峰命名法输入属性。
            <div data-list-name="andy"></div>
            <script>
            var div = document.querySelector('div');
            console.log(div.getAttribute('data-list-name'));
            //上下三种方法都可以，但是如果用下面这两种方法的话，要用驼峰命名法
            console.log(div.dataset.listName);
            console.log(div.dataset['listName']);
            </script>
    节点操作
        利用DOM提供的方法获取元素 （逻辑性不强，繁琐）
            document.getElementById()
            document.getElementByTagName()
            document.querySelector 等等
        利用节点（简单、符合逻辑）
            利用父子兄的节点关系获取元素
            逻辑性强，但是兼容性差
        节点
            DOM树
            页面中所有的内容（标签、属性、文本、注释等）都是节点。节点用node表示。
            HTML DOM树中的所有节点均可通过JavaScript 进行访问，所有HTML节点均可被修改，也可以创建或删除。
            一般的，节点至少由nodeType（节点类型）、 nodeName（节点名称）、 nodeValue（节点值）这三个基本属性。
                元素节点 nodeType 为1
                属性节点 nodeType 为2
                文本节点 nodeType 为3 （文本节点包括文字、空格、换行等等）
                在实际开发中，节点操作主要操作的是元素节点。
            节点层级
                最常见的是父子兄层级关系。
                父级节点
                    node.parentNode
                    注意：得到的离元素最近的父级节点（亲爸爸），如果找不到就返回null
                子级节点
                    parentNode.childNodes (标准)
                    返回包含指定节点的子节点的集合，该集合为即时更新的集合 包含的子节点包含元素节点、文本节点等等
                    所以用 nodeType 判断，用for循环遍历
                parentNode.children (非标准，但是是工程上常用写法)
                    得到所有的子元素节点，虽然是非标准的，但是得到了浏览器的支持，所以以后大量使用这个
                    parentNode.firstChild
                        返回第一个子节点，找不到返回null,不管是文本节点还是元素节点都能找到
                    parentNode.firstElementChild
                        返回第一个子元素节点，找不到返回null,只返回元素节点（IE9以上才支持）
                    parentNode.lastChild
                        返回最后一个子节点，找不到返回null,不管是文本节点还是元素节点都能找到
                    parentNode.lastElementChild
                        返回最后一个子元素节点，找不到返回null,只返回元素节点（IE9以上才支持）
                    实际开发中的办法：
                        parentNode.children[0]
                        parentNode.children[parentNode.children.length-1]
        下拉菜单demo
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta http-equiv="X-UA-Compatible" content="ie=edge">
                <title>Document</title>
                <style>
                    *{
                        margin: 0;
                        padding: 0;
                    }
                    a{
                        font-size: 12px;
                        color: rgb(39, 39, 39);
                        text-decoration:none;
                    }
                    ul li{
                        list-style-type:none;
                    }
                    .nav{
                        width: 400px;
                        margin: 100px auto;
                    }
                    .nav>li{
                        text-align: center;
                        position: relative;
                        margin: 10px auto;
                        height:30px;
                        width: 100px;
                        float: left;
                        color: black;
                        background: rgb(0, 79, 116);
                        line-height: 30px;
                    }
                    .nav>li>a{
                        font-size: 14px;
                        color: rgb(255, 255, 255);
                    }
                    .nav>li>a:hover{
                        background-color: rgba(0, 0, 0, 0.089);
                    }
                    .nav ul{
                        display: none;
                        width: 100%;
                        background-color: rgb(235, 251, 255);
                    }
                    .nav>li>ul>li:hover{
                        animation: right_move 0.2s linear;
                        animation-fill-mode:forwards; 
                    }
                    @keyframes right_move{
                        form{
                            padding-left: 0;
                            background-color: rgba(0, 73, 141,0);
                        }
                        to{
                            padding-left: 20px;
                            background-color: rgba(0, 73, 141, 0.5);
                        }
                    }
                </style>
            </head>
            <body>
                <ul class="nav">
                    <li>
                        <a href="#">微博</a>
                        <ul>
                            <li>
                                <a href="">私信</a>
                            </li>
                            <li>
                                <a href="">评论你</a>
                            </li>
                            <li>
                                <a href="">@我</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="#">相册</a>
                        <ul>
                            <li>
                                <a href="">风景</a>
                            </li>
                            <li>
                                <a href="">海报</a>
                            </li>
                            <li>
                                <a href="">喜欢</a>
                            </li>
                            <li>
                                <a href="">留言</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="#">动态</a>
                        <ul>
                            <li>
                                <a href="">上传</a>
                            </li>
                            <li>
                                <a href="">下载</a>
                            </li>
                            <li>
                                <a href="">浏览</a>
                            </li>
                            <li>
                                <a href="">活跃</a>
                            </li>
                            <li>
                                <a href="">僵尸粉</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="#">关于</a>
                        <ul>
                            <li>
                                <a href="">姓名</a>
                            </li>
                            <li>
                                <a href="">资料</a>
                            </li>
                            <li>
                                <a href="">地址</a>
                            </li>
                        </ul>
                    </li>
                </ul>
                <script>
                    var nav = document.querySelector('.nav');
                    var lis = nav.children;
                    for(var i=0;i<lis.length;i++){
                        lis[i].onmouseover = function(){
                            this.children[1].style.display='block';
                        }
                        lis[i].onmouseout=function(){
                            this.children[1].style.display='none';
                        }
                    }
                </script>
            </body>
            </html>
    兄弟节点
        node.nextSibling 得到下一个兄弟节点，包括元素节点和文本节点 node.previousSibling 得到上一个兄弟节点，包括元素节点和文本节点
            //下面两个方法只有IE9以上才能兼容 node.nextElementSibling 得到下一个兄弟元素节点，只有元素节点 node.previousElementSibling 得到上一个兄弟元素节点，只有元素节点
    创建节点
        document.createElement('tagName')
            这个方法创建由tagName指定的 HTML 元素，因为这些元素原先不存在，是根据我们的需求动态生成的，所以也称为动态创建元素节点。
        node.appendChild(child);
            它是追加元素，是在指定父节点的子节点的末尾添加。
        node.insertBefore(child, 指定元素);
    留言板案例
        分析：
            页面组成：一个文本域，一个提交按钮，一个留言板
            当点击提交按钮的时候，先判断文本域内容是不是空，如果是空，就警告
            如果不是空，就新建一个li，然后把文本域的内容赋值给li，然后在ul里面的前面添加li
            <!-- 
                在留言板案例的基础上添加功能
            当把文本域的内容幅值给 li 的时候，多添加一个删除的链接，
            循环把所有的链接获取过来，当我们点击一个链接的时候，删除当前链接所在的 li
            阻止链接跳转需要添加javascript:void(0);或者 javascript:;
            -->
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta http-equiv="X-UA-Compatible" content="ie=edge">
                <title>Document</title>
                <style>
                    ul li{
                        list-style-type: none;
                    }
                    *{
                        margin: 0;
                        padding: 0;
                    }
                    .box{
                        position: relative;
                        text-align: center;
                    }
                    #texta{
                        position: relative;
                        width: 300px;
                        height: 200px;
                        margin: 100px auto;
                        margin-bottom: 0;
                        display: inline-block;
                        border: 10px solid rgb(0, 136, 118);
                        color: rgb(255, 242, 219);
                        background-color: rgb(0, 85, 81);
                    }
                    #btu{
                        width: 50px;
                        margin: 20px auto;
                        display: block;
                    }
                    .box>ul{
                        display: block;
                        margin: 0 auto;
                        width: 400px;
                        height: 600px;
                        color: aliceblue;
                        text-align: left;
                        background-color: rgb(0, 136, 118);
                    }
                    .box>ul>li{
                        margin: 10px auto;
                        background-color: rgba(240, 248, 255, 0.2);
                        height: auto;
                        width: 360px;
                        max-height: 200px;
                        padding-left: 40px;
                        padding-right: 40px;
                    }
                </style>
            </head>
            <body>
                <div class="box">
                    <textarea name="" id="texta"></textarea>
                    <button id="btu">发布</button>
                    <ul>
                    </ul>
                </div>
                <script>
                    var btn=document.querySelector('#btu');
                    var text=document.querySelector('textarea');
                    var ul=document.querySelector('ul');
                    btu.onclick=function(){
                        if(text.value==''){
                            alert('请输入文本');
                            return;
                        }
                        else{
                            var li=document.createElement('li');
                            li.innerHTML=text.value+"<a href='javascript:;'>删除</a>"; //除了添加文本，同时还附带一个删除的连接，实现删除留言的作用。
                            //ul.appendChild(li);href里面写javascript:;或者javascript：void(0);作用，阻止连接跳转。
                            ul.insertBefore(li,ul.children[0]);
                            //删除元素，删除当前连接的li
                            var as=document.querySelectorAll('a');
                            for(var i=0;i<as.length;i++){
                                as[i].onclick=function(){
                                    ul.removeChild(this.parentNode);//node.removeChild(child; 删除的li 是当前a所在的li 即this.parentNode;然后该li的父亲结点是ul，所以找到ul去删除子节点li即可
                            }
                        }
                    }
                }
                </script>
            </body>
            </html>
    删除节点
        node.removeChild(child);
            从DOM中删除一个子节点，返回删除的节点
    复制节点（克隆节点）
        node.cloneNode() 这个方法返回一个节点的副本
        注意：
            如果括号里面的参数为空或者为false，那么只是浅拷贝，即只复制节点本身，不克隆里面的子节点内容
            如果括号里面的参数为true，那么是深拷贝，复制标签并且复制里面的内容
    三种动态创建元素区别
        document.write()
            文档流执行完毕之后，他会导致页面全部重绘
        document.innerHTML()
            将内容写入某个DOM节点，不会导致页面全部重绘
            拼接字符串的效率低
            创建多个元素效率更高，（不要拼接字符串，采取数组形式拼接），结构稍显复杂
        document.createElement()
            创建多个元素效率稍低一点点，但是结构更清晰
        总结：不同浏览器下，innerHTML比createElement效率高
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>Document</title>
            <style>
                *{
                    margin: 0;
                    padding: 0;
                }
                .box{
                    margin: 100px auto;
                    text-align: center;
                    width: 500px;
                    background-color: rgb(248, 244, 238);
                }
                table{
                    width: 500px;
                }
                table td{
                    font-size: 12px;
                    height: 30px;
                }
                table thead{
                    color: aliceblue;
                    height: 50px;
                    line-height: 50px;
                    background-color: rgb(138, 70, 70);
                }

            </style>
        </head>
        <body>
            <div class="box">
                <table>
                    <thead>
                        <tr>
                            <th>姓名</th>
                            <th>科目</th>
                            <th>成绩</th>
                            <th>操作</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
            <script>
                var dates=[
                {
                    name: '法维安',
                    subject:'css',
                    score:98,
                },{
                    name: '哈辛达',
                    subject:'css',
                    score:95,
                },{
                    name: '帕奇',
                    subject:'css',
                    score:68,
                },{
                    name: '菲奥那',
                    subject:'css',
                    score:92,
                },{
                    name: '巴尔三世',
                    subject:'css',
                    score:78,
                },{
                    name: '希蒂',
                    subject:'css',
                    score:88,
                },{
                    name: '撒卡',
                    subject:'css',
                    score:65,
                },{
                    name: '格伦魔里',
                    subject:'css',
                    score:86,
                }];
                //创建行
                var tbody=document.querySelector('tbody');
                for(var i=0;i<dates.length;i++){
                    var tr=document.createElement('tr');
                    tbody.appendChild(tr);
                    //往行里创建单元格
                    //遍历dates里的每个对象里的数据
                    /*
                        for(var s in obj){
                            s得到的是属性名
                            obj[s]得到的是属性值
                        }
                    */
                    for(var s in dates[i]){
                        var td=document.createElement('td');
                        td.innerHTML=dates[i][s];
                        tr.appendChild(td);

                    }
                    var tdd=document.createElement('td');
                    tdd.innerHTML='<a href="javascript:;">删除</a>';
                    tr.appendChild(tdd);
                }
                var sc=document.querySelectorAll('a');
                for(var i=0;i<sc.length;i++){
                    sc[i].onclick=function(){
                        tbody.removeChild(this.parentNode.parentNode);
                    }
                }
            </script>
        </body>
        </html>
    DOM重点核心
        文档对象模型
        增
            appendChild
            insertBefore
        删
            removeChild
        改
            修改DOM元素的属性，DOM元素的内容、属性、表单的值等
            修改元素属性：src、href、title等
            修改普通元素内容：innerHTML、innerText
            修改表单元素：value、type、disable等
            修改元素样式：style、className
        查
            DOM提供的API方法：getElementById、getElementByTagName古老用法不太推荐
            H5提供的新方法：querySelecter、querySelectorAll提倡使用
            利用节点操作获取元素：父（parentNode）、子（children）、兄（previousElementSibling、nextElementSibling）提倡使用
        属性操作
            setAttribute ： 设置DOM的属性
            getAttribute ： 得到DOM的属性
            removeAttribute ： 移除属性
        事件操作
            鼠标事件	    触发条件
            onclick	        鼠标点击左键触发
            onmouseover	    鼠标经过触发
            onmouseout	    鼠标离开触发
            onfocus	        获得鼠标焦点触发
            onblur	        失去鼠标焦点触发
            onmousemove	    鼠标移动触发
            onmouseup	    鼠标弹起触发
            onmousedown	    鼠标按下触发
三.事件
    事件由三部分组成：
        事件源 事件被触发的对象 比如按钮
        事件类型 如何触发 比如鼠标点击、鼠标经过、键盘按下、滚动滚轮
        事件处理程序 通过函数赋值的方式完成
        <button id="btn">按钮</button>
        <script>
            var btn = document.getElementById('btn');
            btn.onclick = function () {
                alert('触发事件');
            }
        </script>
        鼠标事件	     触发条件
        onclick	        鼠标点击左键触发
        onmouseover	    鼠标经过触发
        onmouseout	    鼠标离开触发
        onfocus	        获得鼠标焦点触发
        onblur	        失去鼠标焦点触发
        onmousemove	    鼠标移动触发
        onmouseup	    鼠标弹起触发
        onmousedown	    鼠标按下触发
    事件高级
        元素注册事件的两种方式
        删除事件的两种方式
        DOM事件流的3个阶段
        利用事件对象完成鼠标跟随案例
        封装阻止冒泡的兼容函数
        事件委托原理
        常用的鼠标和键盘事件
    注册事件（绑定事件）
        给元素添加事件，称为注册时间或者绑定事件。
            注册事件有两种方式：传统方式和方法监听注册方式
        传统注册方式
            利用on开头的事件onclick
            btn.onclick = function () {}
            特点：注册事件的唯一性
            同一个元素同一个事件著能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数
        监听注册方式
            W3C标准推荐方式
            addEventListener() 它是一个方法
            IE9之前的IE浏览器不支持此方法，可使用attachEvent()代替
            特点: 同一个元素同一个事件可以注册多个监听器
        addEventListener() 方法
            eventTarget.addEventListener(type, listener[, useCapture])
            eventTarget.addEventListener(type, listener[, useCapture]) 方法将指定的监听器注册到eventTarget 上，当该对象触发指定的事件时，就会执行事件处理函数。
            该方法接收三个参数：
                type : 事件类型字符串，比如click、mouseover，注意这里不要带on，是字符串，带引号
                listener ： 事件处理函数，事件发生时，会调用该监听函数
                useCapture : 可选函数，是一个布尔值，默认是false 。学完DOM事件流之后，再进一步学习
        attachEvent
            该特性非标准，请尽量不要在生产环境中使用它
                eventTarget.attackEvent(eventNameWithon, callback)
                eventTarget.attackEvent方法将指定的监听器注册到eventTarget 上，当该对象触发指定的事件时，指定的回调函数将会被执行。
            该方法接收两个参数：
                ventNameWithon ： 事件类型字符串，比如onclick，onmouseover， 这里要带on
                callback : 事件处理函数，当目标触发事件时回调函数将被调用
        注册事件的兼容性解决方案
            <button>点击我</button>
            <script>
                var btn = document.querySelector('button');
                function alertWarn () {
                    alert ('warning');
                }
                function addEventListener(element, eventName, fn) {
                    //判断浏览器是否支持addEventListener方法
                    if (element.addEventListener) {
                        element.addEventListener (eventName, fn);   //第三个参数，默认是false
                    } else if (element.attachEvent) {
                        element.attachEvent ('on' + eventName, fn);
                    } else {
                        //相当于element.onclick = fn;
                        element['on' + eventName] = fn;
                    }
                }
                addEventListener(btn, 'click', alertWarn);
            </script>
    删除事件（解绑事件）
        删除事件的方式
        传统注册方式
            eventTarget.onclick = null;
        方法监听注册方式
            divs[1].removeEventListener('click', alertWarn);
            function alertWarn () {
                alert('warning');
                divs[1].removeEventListener('click', alertWarn);
            }
        attach 方式（尽量不要使用，只支持ie9以前的ie浏览器）
            divs[2].attachEvent('onclick', alertWarn1);
            function alertWarn1 () {
                alert('warning');
                divs[1].detachEvent('click', alertWarn1);
            }
        兼容性方案 参考上面的注册事件的兼容性方式。
    DOM事件流
        事件流描述的是从页面中接收事件的顺序。
        事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流。
        包括三个阶段：
            事件捕获阶段（事件从最顶层元素 window 一直传递到目标元素的父元素.
            处于目标阶段（事件到达目标元素. 如果事件指定不冒泡. 那就会在这里中止.
            事件冒泡阶段（事件从目标元素父元素向上逐级传递直到最顶层元素 window. 及捕获阶段的反方向.
        注意:
            JS代码只能执行捕获或者冒泡其中的一个阶段
            onclick 和 attachEvent 只能得到冒泡阶段
            addEventListener (type, listener[, useCapture]) 第三个参数如果是true，表示在事件捕获阶段调用事件处理程序；如果是false（不写默认就是false），表示在事件冒泡阶段事件处理程序。
            在实际开发中，我们很少使用事件捕获，我们更关注事件冒泡
            有些事件是没有冒泡的，比如onblur、onfocus、onmouseover、onmouseleave
            虽然事件冒泡有时候会带来麻烦，但是有时候又会巧妙的做某些事情，我们后面讲解
    事件对象（重点）
        event 就是一个事件对象，写道我们的侦听函数的小括号里面，当形参来看
        事件对象只有有了事件才会存在，他是系统给我们自动创建的，不需要我们传递参数
        事件对象是我们的事件的一系列相关数据的集合，比如鼠标点击里面就包含了鼠标的相关信息
        这个事件对象我们可以自己命名，比如 event、evt 、e 等
        事件对象也有兼容性问题。 IE 6、7、8通过 window.event 实现
        兼容性写法：
            event = event || window.event;
        事件对象常见的属性和方法
            事件对象属性方法	    说明
            e.target	            返回触发事件的对象 标准
            e.scrElement	        返回触发事件的对象 非标准 IE 6 7 8 使用
            e.type	                返回事件的类型，比如click、mouseover等，不带 on
            e.cancelBubble	        该属性阻止冒泡，非标准，IE 6 7 8 使用
            e.returnValue	        该属性阻止默认事件（默认行为）非标准 ，IE 6 7 8 使用，比如不让链接跳转
            e.preventDefaule()	    该方法阻止默认事件（默认行为）标准 ，比如不让链接跳转
            e.stopPropagation()	    阻止冒泡，标准
        e.target 和 this 的区别
            this 返回的是绑定事件的对象（元素）
            e.target 返回的是点击的那个对象，就是谁触发了这个事件
                var ul = document.querySelector('ul');
                ul.addEventListener('click', function (e) {
                    console.log(this);
                    console.log(e.target);
                })
                // <ul>...</ul>
                // <li>123</li>
        阻止对象默认行为
            三种方法：
            e.preventDefaule(); 是一个方法，适合普通浏览器
            e.returnValue;      是一个属性，适用于 IE 6 7 8
            return false;       没有兼容性问题，但是需要注意后面的语句就不执行了，直接跳出
    阻止事件冒泡
        event.stopPropagation(); // 一般浏览器停止冒泡
        event.cancelBubble; // IE 6 7 8 的停止冒泡
            var father = document.querySelector('.father');
            var son = document.querySelector('.son');
            father.addEventListener('click', alertName, false);
            son.addEventListener('click', alertName, false);
            document.addEventListener('click',function () {
                alert('document');
            }, false);
            function alertName (event) {
                alert(this.getAttribute("class"));
                event.stopPropagation();    // 停止冒泡
                event.cancelBubble;         // IE 6 7 8 的停止冒泡
            }
        mouseover(鼠标覆盖)
        mouseenter(鼠标进入)
            二者的本质区别在于,mouseenter不会冒泡,简单的说,它不会被它本身的子元素的状态影响到.但是mouseover就会被它的子元素影响到,在触发子元素的时候,mouseover会冒泡触发它的父元素.(想要阻止mouseover的冒泡事件就用mouseenter)
        mouseenter：当鼠标移入某元素时触发。
        mouseleave：当鼠标移出某元素时触发。
        mouseover：当鼠标移入某元素时触发，移入和移出其子元素时也会触发。
        mouseout：当鼠标移出某元素时触发，移入和移出其子元素时也会触发。
        mousemove：鼠标在某元素上移动时触发，即使在其子元素上也会触发。
        mouseout、mouseover和mouseleave、mouseenter最大的区别，在于子元素连带触发。    
    事件委托（代理和委托）
        事件委托的原理
            事件委托的原理：不给每个子节点单独设置事件监听器，而是设置在其父节点上，然后利用冒泡原理设置每个子节点。
        **例如：**给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li ，然后事件冒泡到 ul 上， ul 有注册事件，就会触发事件监听器。
        事件委托的作用
            只操作了一次 DOM ，提高了程序的性能。
    常用的鼠标事件
        鼠标事件	    触发条件
        onclick	        鼠标点击左键触发
        onmouseover	    鼠标经过触发
        onmouseout	    鼠标离开触发
        onfocus	        获得鼠标焦点触发
        onblur	        失去鼠标焦点触发
        onmousemove	    鼠标移动触发
        onmouseup	    鼠标弹起触发
        onmousedown	    鼠标按下触发
            document.addEventListener('click', function (e) {
                console.log(e);
            });
        //禁用右键菜单
            document.addEventListener('contextmenu',function(e){
                e.preventDefault();
            })
        //禁用文本选中
            document.addEventListener('selectstart',function(e){
                e.preventDefault(); //从文本开始被选中的时候就开始设置函数禁用选中
            })
        鼠标事件对象	说明
        e.clientX	    返回鼠标相对于浏览器窗口可视区域的X坐标
        e.clientY	    返回鼠标相对于浏览器窗口可视区域的Y坐标
        e.pageX	        返回鼠标相对于文档页面的X坐标 IE9+ 支持
        e.pageY	        返回鼠标相对于文档页面的Y坐标 IE9+ 支持
        e.screenX	    返回鼠标相对于电脑屏幕的X坐标
        e.screenY	    返回鼠标相对于电脑屏幕的Y坐标
        案例:
            跟随鼠标的小鸟:
            案例分析
                鼠标不断的移动,使用鼠标移动事件: mousemove
                在页面中移动,所以给 document 注册事件
                图片要移动距离,而且不占位置,我们使用绝对定位即可
                核心原理,每次鼠标移动,我们都会获得最新的鼠标坐标,把这个 X 和 Y 的坐标做为图片的 top 和 left 值就可以移动图片
    常用键盘事件
        常用键盘事件
        键盘事件	触发条件
        onkeyup	        某个键盘按键被松开时触发（松开的时候触发）
        onkeydown	    某个键盘按键被按下时触发（按下之后一直触发）
        onkeypress	    某个键盘按键被按下时触发（按下之后一直触发），但是它不能识别功能键，比如 ctrl、shift 等
            当按下的时候，keydown 执行在 keypress 之前。
        键盘事件对象
            键盘事件对象属性	     说明
            keyCode	                返回该键的 ASCII 值
        注意：
            keyup 和 keydown 事件不区分字母大小写， a 和 A 得到的都是65
            keypress 区分大小写，a 得到的是97，A 得到的是 65
        案例1:
            京东按下 s 键定位到搜索框:
            检测用户是否按下了 s 键盘，如果按下 s 键，就把光标定位到搜索框里面。
            案例分析
                利用键盘事件对象里面的 keyCode 判断用户是否按下的是 s 键
                搜索框获得焦点的方法: 利用 js 里面的 focus() 方法
                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <title>京东搜索框</title>
                    </head>
                    <body>
                        <input type="text" name="" id="">
                        <script>
                            var input = document.querySelector('input');
                            document.addEventListener('keyup', function (e) {
                                if (e.keyCode == 83) {
                                    input.focus();
                                }
                            });
                        </script>
                    </body>
                    </html>
四.pc端网页特效
        常见的offset系列属性的作用
        常见client系列属性的作用
        常见scroll系列属性的作用
        封装简单动画函数
        网页轮播图
    元素偏移量offset系列
        使用offset相关属性可以动态的获得该元素的位置（偏移），大小等
            获得元素距离带有定位父元素的位置
            获取元素自身的大小（返回的数值不带单位）
        offset常用属性：
            offsetParent 
                offsetParent属性返回一个对象的引用，这个对象是距离调用offsetParent的元素最近的（在包含层次中最靠近的），并且是已进行过CSS定位的容器元素。 如果这个容器元素未进行CSS定位, 则offsetParent属性的取值为根元素的引用。
            　　总的来说两条规则：
            　　1、如果当前元素的父级元素没有进行CSS定位（position为absolute或relative），offsetParent为body。
            　　2、如果当前元素的父级元素中有CSS定位（position为absolute或relative），offsetParent取最近的那个父级元素。
            offsettop
                返回作为该元素带有定位的父级元素上方的偏移
            offsetLeft
                返回元素相对带有父元素左边边框的偏移
            offsetWidth
                返回自身包括padding、边框、内容区的宽度
            offsetHeight
                返回自身包括padding、边框、内容区的高度  
        offset与style的区别 
                offset	                                    style
        可以得到任意样式表中的样式值	            只能得到行内样式的样式值
        获取到的数值是没有单位的	                获得到的值是由单位的
        offsetWidth包含padding+border+width	      style.width获得不包含padding和border的值
        只能获取(只读)属性，不能设置属性或赋值	     可以读写任何行内样式属性
        如果只想要获取大小位置，用offset更合适	     如果想要给元素更改值，则要使用style来改变

    元素可视区client系列
        clientWidth:    可视区域的宽(没有边框),边框内部的宽度
        clientHeight:   可视区域的高(没有边框),边框内部的宽度
        clientLeft:     左边边框的宽度
        clientTop:      上边边框的宽度
        clientX(clientY):到顶部左部的可视距离
    元素滚动scroll系列
        scrollWidth:元素中内容的实际的宽(没有边框,包含内边距),如果没有内容就是元素的宽
        scrollHeight:元素中内容的实际的高(没有边框,包含内边距),如果没有内容就是元素的高
        scrollTop:向上卷曲出去的距离
        scrollLeft:向左卷曲出去的距离
        //获取浏览器向上向左卷曲出去距离的值
            function getScroll(){
                    return {
                        left : window.pageXOffset || document.documentElement.scrollLeft 
                            || document.body.scrollLeft || 0,
                        top :  window.pageYOffset || document.documentElement.scrollTop 
                            || document.body.scrollTop || 0
                    };
                    
                }
            //测试
            window.onscroll = function(){
                console.log(getScroll().top);  
            };
            }
            兼容性问题
            一、未声明 DTD（谷歌只认识他）
                document.body.scrollTop
            二、已经声明DTD（IE678只认识他）
               document.documentElement.scrollTop
            三、火狐/谷歌/ie9+以上支持的
               window.pageYOffset
            兼容写法
                var aaa = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
                var aaa = document.documentElement.scrollTop + document.body.scrollTop;
            案例：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <meta http-equiv="X-UA-Compatible" content="ie=edge">
                    <title>Document</title>
                    <style>
                        *{
                            margin: 0;
                            padding: 0;
                        }
                        .cebianlan-box{
                            width: 50px;
                            position: absolute;
                            left: 95%;
                            top: 300px;
                            z-index: 1000;
                        }
                        .lan{
                            font-family: 'Microsoft Yahei';
                            letter-spacing: 2px;
                            cursor: pointer;
                            text-align: center;
                            width: 40px;
                            height: 40px;
                            color: aliceblue;
                            font-size: 12px;
                            padding: 7px;
                            line-height: 20px;
                            background-color: rgb(247, 107, 142);
                            margin: 10px 0;
                            word-wrap:break-word; 
                            border-radius: 8px;
                            box-shadow: 2px 2px 10px rgba(247, 107, 142, 0.527);
                        }
                        .lan:hover{
                            animation: change-color 0.1s linear;
                            animation-fill-mode:forwards; 
                        }
                        @keyframes change-color{
                            from{
                                box-shadow: 2px 2px 10px rgba(247, 107, 142, 0.527); 
                            }
                            to{
                                box-shadow: 2px 2px 15px rgba(230, 37, 69, 0.788);
                                width: 41px;
                                height: 41px;
                            }
                        }
                        #go-top{
                            display: none;
                            margin-top: 100px;
                            position:relative;
                            overflow:hidden;
                            text-align: center;
                        }
                        #go-top>img{
                            position:relative;
                            width: 20px;
                            height: 20px;
                            margin: 10px;
                            border-left:50px transparent solid;
                            -webkit-filter:drop-shadow(rgb(255, 255, 255) -50px 0);
                            filter:drop-shadow(rgb(255, 255, 255) -50px 0); 
                        }
                        #kefu{
                            display: none;
                            position:relative;
                            overflow:hidden;
                            text-align: center;
                        }
                        #kefu>img{
                            width: 30px;
                            height: 30px;
                            margin: 5px 5px;
                            border-left:50px transparent solid;
                            -webkit-filter:drop-shadow(rgb(255, 255, 255) -50px 0);
                            filter:drop-shadow(rgb(255, 255, 255) -50px 0); 
                        }
                        #old{
                            background-color: white;
                            color: rgb(31, 31, 31);
                        }
                        #mini{
                            display: none;
                            letter-spacing: 0;
                        }
                        .main-box{
                            font-size: 50px;
                            text-align: center;
                            color: rgba(233, 61, 84, 0.521);
                            position: relative;
                            width: 100%;
                            height: 300px;
                            background-color: rgb(243, 231, 231);
                            z-index: 0;
                            margin: 20px 0;
                        }
                        #header-box{
                            height: 100px;
                            background-color: rgb(244, 245, 225);
                        }
                        #play-box{
                            height: 600px;
                            background-color: rgb(243, 231, 231);
                        }
                        #speack-box{
                            height: 700px;
                            background-color: rgb(233, 243, 231);
                        }
                        #mini-box{
                            height: 1400px;
                            background-color: rgb(231, 243, 242);
                        }
                        #footer-box{
                            height: 800px;
                            background-color: rgb(243, 231, 231);
                        }

                    </style>
                </head>
                <body>
                    <div class="cebianlan-box">
                        <div class="lan" id="fankui-box">试用反馈</div>
                        <div class="lan" id="old">返回旧版</div>
                        <div class="lan" id="go-top">
                            <img src="/png/箭头上.png" alt="top">
                        </div>
                        <div class="lan" id="mini">
                            <p id="mini">mini</p>
                            <P id="off">OFF</P>
                        </div>
                        <div class="lan" id="kefu">
                            <img src="/png/客服.png" alt="kefu">
                        </div>
                    </div>
                    <div class="main-box" id="header-box">试用反馈</div>
                    <div class="main-box" id="play-box">返回旧版</div>
                    <div class="main-box" id="speack-box">内容区1</div>
                    <div class="main-box" id="mini-box">迷你板块</div>
                    <div class="main-box" id="footer-box">联系客服</div>
                    <script>
                        var sliderBar=document.querySelector('.cebianlan-box');
                        var play=document.querySelector('#play-box');
                        var speack=document.querySelector('#speack-box');
                        var mini=document.querySelector('#mini-box');
                        var kefu=document.querySelector('#footer-box');

                        var gobackbar=document.querySelector('#go-top');
                        var minibar=document.querySelector('#mini');
                        var kefubar=document.querySelector('#kefu');
                        
                        var playTop=play.offsetTop;
                        var sliderBarTop=sliderBar.offsetTop-playTop;
                        var speackTop=speack.offsetTop;
                        var miniTop=mini.offsetTop;
                        var kefuTop=kefu.offsetTop;
                        document.addEventListener('scroll',function(){
                            var sliderBarTopTop=sliderBar.style.top;
                            //页面被卷曲的头部window.pageYOffset
                            if(window.pageYOffset>=playTop){
                                sliderBar.style.position='fixed';
                                sliderBar.style.top=sliderBarTop+'px';
                            }
                            else{
                                sliderBar.style.position='absolute';
                                sliderBar.style.top=300+'px';
                            }
                            if(window.pageYOffset>=speackTop){
                                gobackbar.style.display='block';
                            }
                            else{
                                gobackbar.style.display='none';
                            }
                            if(window.pageYOffset>=miniTop){
                                minibar.style.display='block';
                            }
                            else{
                                minibar.style.display='none';
                            }
                            if(window.pageYOffset>=kefuTop){
                                kefubar.style.display='block';
                            }
                            else{
                                kefubar.style.display='none';
                            }  
                        })
                    </script>
                </body>
                </html>
    动画函数封装
        节流阀
            防止轮播图按钮点击过快造成播放过快
            节流目的
                当上一个函数动画执行完毕再去执行下一个函数动画，让事件无法连续触发
            核心实现原理：
                利用回调函数，添加一个变量来控制，锁住函数和解锁函数
                开始先声明变量
                    var flag=true;
                    if(flag){
                        flag=false;
                        do something; //关闭水龙头
                    }
                    利用回调函数，动画执行完毕，flag=true；//打开水龙头
        动画实现核心原理：
            通过定时器setInterval（）不断移动盒子位置。使用javascript实现动画时一般是使用requestAnimationFrame,我们可能经常也会用setInterval和setTimeout来实现动画，但是它们实现的动画都不会与屏幕的刷新率同步，并且很可能出现抖动和跳帧，例如jQuery就是采用setInterval来实现动画，所以jQuery动画的帧率会偏低
        在网页上创建动画一般有两种方式：。CSS和JavaScript的它们在创建动画的时间和性能上是不一样的，各有利弊选择哪种方法实际上取决于项目，以及想要实现什么类型的动画。
        一般使用css动画来实现比较简单的“一次性转换”，为UI元素转换比较小的独立状态。例如从侧面引入导航栏菜单，模太框弹出等。要实现高级效果时，例如弹跳，加速，减速等比较复杂的动画，则使用Java脚本动画。现在有很多比较好的JS动画框架，例如TweenMax，速度，animo.js，jQuery的。
        不管是CSS还是JavaScript的来创建动画，我们都会听到一个词“缓动”。自然界中没有东西从一点呈线性的移动到另一点，一般可能需要加速或减速。在经典动画中，经常会出现“缓入“，”缓出“，”缓入缓出“效果。缓动使动画不再那么尖锐或生硬.css中，我们要想达到这些效果，只需要使用一些关键字：
            线性        linear
            缓入        ease-in
            缓出        ease-out
            缓入缓出    ease-in-out
        动画封装：
            //obj,target动画执行对象，和执行条件，具体参数看动画效果而定
            function animate(obj,target,callback){
                clearInterval(obj.timer);
                obj.timer=setInterval(function(){
                    var step=(target-obj.offsetLeft)/10;
                    step=step>0? Math.ceil(step):Math.floor(step);
                    if(obj.offsetLeft==target){
                        //等于移动距离，停止定时器
                        clearInterval(obj.timer);
                        if(callback)//判断是否添加回调函数，有就调用。
                        {
                            callback();
                        }
                    }
                    obj.style.left=obj.offsetLeft+1+'px';
                },30);
            }
            var document.querySelector('div');
            animate(div,500,function(){
                div.style.backgroundColor='red';
            });//调用动画函数即可
        常见运动
            匀速运动
                让小球在2s内向右匀速移动200px
                时间： t = T * p
                位移: St = S * p = v * t
                速度: v = St / t = S / T
                加速度: a = 0
                circle.on('click', function() {
                    var self = this;
                    var startTime = Date.now();
                    var distance = 200;
                    var T = 2000;
                    requestAnimationFrame(function step() {
                        var p = Math.min(1.0, (Date.now() - startTime) / T);
                        self.style.transform = 'translateX(' + (distance * p) + 'px)';
                        if(p < 1.0){
                            requestAnimationFrame(step);
                        }
                    })
                })
            2.匀加速运动
                让小球在2s内向右匀加速向右移动200px, 速度从0开始
                    时间: t = T * p
                    位移: St = S * p^2 = (S * t^2) / T^2
                    速度: v = (2*S / T^2) * t = 2Sp/T
                    加速度 a = 2*S / T^2
                        circle.on('click', function() {
                                var self = this;
                                var startTime = Date.now();
                                var distance = 200;
                                var T = 2000;
                                requestAnimationFrame(function step() {
                                    var p = Math.min(1.0, (Date.now() - startTime) / T);
                                    self.style.transform = 'translateX(' + (distance * p * p) + 'px)';
                                    if(p < 1.0){
                                        requestAnimationFrame(step);
                                    }
                                })
                            })
            3.匀减速运动
                让小球在2s内向右匀减速向右移动200px, 速度从最大减为0
                    时间: t = T * p
                    位移: St = (2*S / T) * t - (S / T^2) * t^2 = Sp * (2 - p)
                    速度: v = 2S / T - 2S / t^2 * t
                    加速度 a = -2*S / T^2
                        circle.on('click', function() {
                                var self = this;
                                var startTime = Date.now();
                                var distance = 200;
                                var T = 2000;
                                requestAnimationFrame(function step() {
                                    var p = Math.min(1.0, (Date.now() - startTime) / T);
                                    self.style.transform = 'translateX(' + (distance * p * (2 - p)) + 'px)';
                                    if(p < 1.0){
                                        requestAnimationFrame(step);
                                    }
                                })
                            })
            4.抛物线运动
                circle.on('click', function() {
                    var self = this;
                    var startTime = Date.now();
                    var disX = 200, disY = 200;
                    var T = 1000 * Math.sqrt(2 * disY / 98);
                    requestAnimationFrame(function step() {
                        var p = Math.min(1.0, (Date.now() - startTime) / T);
                    
                        var tx = disX * p;
                        var ty = disY * p * p;
                        self.style.transform = 'translate(' + tx + 'px, ' +ty +  'px)';
                        if(p < 1.0){
                            requestAnimationFrame(step);
                        }
                    })
            5.简谐摆动
                circle.on('click', function() {
                    var self = this;
                    var startTime = Date.now();
                    var distance = 100;
                    var T = 2000;
                    requestAnimationFrame(function step() {
                        var p = Math.min(1.0, (Date.now() - startTime) / T);
                        var tx = distance * Math.sin(2 * Math.PI * p);
                        self.style.transform = 'translateX(' + tx + 'px)';
                        if(p < 1.0){
                            requestAnimationFrame(step);
                        }
                    })
                })
            6.正弦线
                circle.on('click', function() {
                    var self = this;
                    var startTime = Date.now();
                    var distance = 100;
                    var T = 2000;
                    requestAnimationFrame(function step() {
                        var p = Math.min(1.0, (Date.now() - startTime) / T);
                        var ty = distance * Math.sin(2 * Math.PI * p);
                        var tx = 2 * distance * p;
                        self.style.transform = 'translate(' + tx + 'px,'+ ty +'px)';
                        if(p < 1.0){
                            requestAnimationFrame(step);
                        }
                    })
                })
            7.圆周运动
                circle.on('click', function() {
                    var self = this;
                    var startTime = Date.now();
                    var distance = 100;
                    var T = 2000;
                    var r = 100;
                    requestAnimationFrame(function step() {
                        var p = Math.min(1.0, (Date.now() - startTime) / T);
                        var rotation = p * 360;
                        self.style.transformOrigin = 'r' + 'px ' + r + 'px';
                        self.style.transform = 'rotate(' + rotation +'deg)';
                        if(p < 1.0){
                            requestAnimationFrame(step);
                        }
                    })
        
    常见网页特效案列
五.移动端常见特效
    触屏事件
        手机端html5触屏事件(touch事件)
            touchstart：    触摸开始的时候触发
            touchmove：     手指在屏幕上滑动的时候触发
            touchend：      触摸结束的时候触发
            而每个触摸事件都包括了三个触摸列表，每个列表里包含了对应的一系列触摸点（用来实现多点触控）：
                touches：           当前位于屏幕上的所有手指的列表。
                targetTouches：     位于当前DOM元素上手指的列表。
                changedTouches：    涉及当前事件手指的列表。手指状态发生改变的列表
            每个触摸点由包含了如下触摸信息（常用）：
                identifier：    一个数值，唯一标识触摸会话（touch session）中的当前手指。一般为从0开始的流水号（android4.1，uc）
                 target：        DOM元素，是动作所针对的目标。
                pageX/pageX/clientX/clientY/screenX/screenY：一个数值，动作在屏幕上发生的位置（page包含滚动距离,client不包含滚动距离，screen则以屏幕为基准）。
                radiusX/radiusY/rotationAngle：画出大约相当于手指形状的椭圆形，分别为椭圆形的两个半径和旋转角度。
六.本地存储
    WEB应用的快速发展，那么前端对于本地存储一些数据也成为一种重要的需求，例如保存账户登录的用户名、密码等，既提高了用户体验，也省去了跟后端交互所需的步骤，还不影响网站的性能。
    因此呢，推出了cookie、userData、flash、sessionStorage、localStorage、应用缓存等等方案
    cookie是一种会话跟踪技术，用于在进行网页访问的时候，存储页面中的客户端的用户信息。
    1.cookie
        cookie在使用中还有几个注意点：
        001 使用cookie来进行数据存储的大小有限制，4KB
        002 每个网页中存储cookie的个数（最多50）和每个网站中存储cookie的个数都有限制（200）
        003 各个不同的浏览器对cookie的数量也不相同
        IE6.0：每个域为20个，大小为4095个字节
        IE7.0/8.0：每个域为50个 ，大小为4095个字节
        Opera：每个域为30个 ，4096个字节
        Firefox：每个域为50个  ，大小为4097个字节
        Safari：没有个数限制，大小为4097个字节
        Chrome：每个域为53个，大小为4097个字节
        004 cookie数据的过期时间
        a）默认情况下，cookie存储的内容是一次性的，它的有效期间是当前会话（需要把整个浏览器都关闭会话就结束）
        b）设置过期时间：通过expires=time;的格式来进行指定, 设置了之后只要没有超过过期时间，那么数据将一直都在
        005 cookie是不可以跨浏览器的(例如在IE中保存的cookie, 不可以在火狐中使用)
        006 cookie是不可以跨域的(跨域名)
        因此，cookie对于目前的技术发展来说，已经显得力不从心了。于是H5推出了sessionStorage和localStorage。
    2.使用sessionStorage、localStorage 
        localStorage： 
            是一种你不主动清除它，它会一直将存储数据存储在客户端的存储方式，即使你关闭了客户端（浏览器)，属于本地持久层储存 
        sessionStorage： 
            用于本地存储一个会话（session）中的数据，一旦会话关闭（关闭浏览器），那么数据会消失，刷新不会消失。 
        有时候，我们需要将数据存储到sessionStorage和localStorage中，这样做的好处有： 
            1 缓存数据 
            2 减少对内存的占用 
            但是，storage只能存储字符串的数据，对于JS中常用的数组或对象却不能直接存储。 
            它能保存更大的数据（IE8上是10MB，Chrome是5MB），同时保存的数据不会再发送给服务器，避免带宽浪费。
        localStorage存储方法（sessionStorage类似） 
            localStorage.name =’vanida； 
            localStorage[“name”]=’vanida’； 
            localStorage.setItem(“name”,”vanida”); 
            //这三种设置值方式是一样的； 
        localStorage获取值方法 
            var name = localStorage[“name”] 
            var name= localStorage.name 
            var name＝ localStorage.getItem(“name”); 
        //这三种获取值方式是一样的； 
            localStorage清除特定值方法 
        //清除name的值 
            localStorage.removeItem(“name”); 
            localStorage.name＝”; 
        localStorage清除所有值方法 
            localStorage.clear() 
        localStorage只能存储字符串，如果需要存储对象，首先要转化为字符串。利用JSON.stringify()； 
            var person = {name:”vanida”,”sex”:”girl”,”age”:25}; 
            localStorage.setItem(“person”,JSON.stringify(person)); 
            // localStorage.person=”{“name”:”vanida”,”sex”:”girl”,”age”:25}” 
            注意：JSON.stringify()中不要忘了“i”,stringify而不是stringfy！ 
                然后取出person的对象你可以用JSON.parse(); 
                person = JSON.parse(localStorage.getItem(“person”));
七.移动端页面布局开发
    
八.JavaScript高级面向对象-原型原型链函数高级ES6类
    类：
        class star{
            constructor(uname,age){
                this.uname=uname;
                this.age=age;
            }
        }
        var ldh=new star('刘得花',20);
        注：
        constructor 方法（构造函数）
            constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。可以接收传递过来的参数，返回实类对象；
        通过class 关键字创建类，类名习惯首字母大写；
        语法规范：创建类，类名后面不要跟小括号；构造函数不需要加function;
    类的继承:
        Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。
            class Point {
            }
            class ColorPoint extends Point {
            }
        上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。
            class ColorPoint extends Point {
            constructor(x, y, color) {
                super(x, y); // 调用父类的constructor(x, y)
                this.color = color;
            }
            toString() {
                return this.color + ' ' + super.toString(); // 调用父类的toString()
            }
            }
        上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。
        子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。
            class Point { /* ... */ }
            class ColorPoint extends Point {
                constructor() {
                }
            }
            let cp = new ColorPoint(); // ReferenceError
        上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。
            子类在构造函数中使用super，必须先调用父类构造函数，再调用子类的构造方法。
                class Father{
                    constructor(x,y){
                        this.x=x;
                        this.y=y;
                    }
                    sum(){
                        return(this.x+this.y);
                    }
                }
                //子类继承父类加法方法，同时子类扩展减法方法
                class Son extends Father{
                    constructor(x,y){
                        //利用super关键字调用父类的构造函数
                        //注：super关键字必须在子类的this之前调用；
                        super(x,y);
                        this.x=x;
                        this.y=y;
                    }
                    subtract(){
                        return(this.x-this.y);
                    }
                }
                var son=new Son(5,3);
                son.subtract();     //2
                son.sum();      //8
        注：
            在ES6中，类没有变量提升，所以必须先定义类才能通过类实例化对象（即：类的定义必须写在实例化句子之前）
            类里面的共有属性和方法一定要加this使用。
                <button>点击</button>
                <script>
                var button;
                    clss Star{
                        //constructor里面的this指向的是创建的实例对象
                        constructor(uname,age){
                            button=this;
                            this.uname=uname;
                            this.age=age;
                            this.btu=document.querySelector('button');
                            this.btu.onclick=this.sing;     //注意这里调用函数，不要加小括号，因为加了小括号就标志立即调用sing方法。
                        }
                        //（方法）函数的this指向的是这个（方法）函数的调用者
                        sing(){
                            alert(this.uname);      //这种写法返回的是Undefind，因为这里的this指向的函数的调用者，上面的btu,btu是没有这个属性（uname）的，所以undefined。
                            alert(button.uname);    //在上面将constructor的this指向button，即这里的button指向的是constructor，就可以调用该方法了
                        }
                    }
                    var ldh=new Star('刘德华',25);
                </script>
            类里面的this指向问题：
               . 全局中的this，都指向window
               . 什么是事件，当前这个函数，在addEventListener中被传入第二个参数,当前这个函数有且仅有一个参数，是e，并且这个e是基于event的对象在事件中，this永远指向的是e currentTarget，就是被侦听的对象
               . 混入的this，就是使用call、apply和bind方法，代替掉原有函数中的this，所以混入的this，就是代表这个混入的对象
               . 对象中的this也很明显，就是指的这个对象
               . 无论是在ES5还是ES6中，类中的this都是指向的这个类，也可以说是指向的通过类实例化的对象
    构造函数和原型：
        在Es6之前,由于javascript没有对类的支持,也就是说它并不具备如传统后台语言(比如java)拥有类的功能,所谓类就是用来描述事物中的属性和行为的,类的特征是由成员组成的,而属性对应的就是类中的成员变量,而方法对应的就是类中的成员方法,这是传统oop语言的描述,然而在javascript中,虽没有类的概念,但是它往往是通过构造函数和原型对象来给对象模拟与类相似的功能,但是这些相似的功能并不一定表现的与类完全一致,其实创建构造函数的过程,就是创建模板的过程,类一定程度上与此相似,创建多个共享的特定的属性和方法,用于生成对象的饼干工具,主要目的是提高代码的可复用性,也提高了代码的性能,有时候,在我们无意间就已经在使用了这些特性,什么构造函数,原型,个人觉得,初次理解起来很是抽象,也稀里糊涂的觉得实际开发中到底有什么卵用,也许后者在不涉及复杂的功能需求时,平时用得不多,显然Es6中已新增了类class的功能,越来越严格,越来越像后端语言,Es6,Es7,Es8新增的诸多方法也越来越强大,标准也越来越完善,但是理解构造函数与原型对象是必须的,是js面向对象编程的基础。
        构造函数：
            构造函数就是你用new关键字创建对象时调用的函数
            构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋值，他总是与new一起使用，我们可以吧对象中的一些公共方法和属性抽取出来，然后封装到这个函数里。
            缺点:当实例化多个对象时,会重复的创建对象,造成内存空间的浪费,增大CPU的开销，并没有消除代码的冗余,(原型正好解决了此类问题)
            new在执行的时候会做4件事：
                在内存中创建一个新的空对象
                让this指向这个新的对象
                执行构造函数里的代码，给这个新对象添加属性和方法
                返回这个对象（所以构造函数里面不需要return）
        静态成员和实例成员：
            实例成员就是构造函数内部通过this添加的成员，实例成员只能通过实例化对象来访问，不可以通过构造函数来访问。
            在构造函数本身上添加的成员就是静态成员，静态成员只能通过构造函数来访问，不能通过对象来访问。
        构造函数原型prototype
            构造函数通过原型分配的函数是所有对象所共享的。JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype就是一个对象，这个对象的所有属性和方法都会被构造函数所拥有。
            我们可以把那些不变的方法，直接定义在prototype对象上，这项所有的对象实例就可以直接共享这些方法。
            一般情况下公共属性定义到构造函数里面，公共方法放到原型对象身上。
                function Star(name,age){
                    this.uname=uname;
                    this.age=age;
                    //普通写法
                   // this.sing=functionS(){
                    //    console.log('我会唱歌');
                   // }
                }
                //原型写法
                Star.prototype.sing(){
                    console.log('我会唱歌');
                }
                var ldh=new Star('刘德华',25);
                var zxy=new Star('张学友',32);
                ldh.sing();
                zxy.sing();

            作用1：共享方法。去改写对象下面公用的方法或者属性,让公用方法或者属性在内存中存在一份(也就是更改构造器函数底下属性和方法,解决了不会重复创建构造的过程,目的是提高性能),可以看作是对象的基类
            作用2: 在原有的对象基础上上,通过prototype进行额外的,封装,拓展
            原型是基于构造函数的(也就是说原型是挂载在构造函数下的,先有构造函数,才会有原型)
            // 未用原型写法,普通写法求和
                var arr1 = [1,2,3,4,5,6,7,8,9,10];
                var arr2 = [2,4,6,8,10,12,14,16]
                arr1.sum = function(){
                    var result = 0;
                    for(var i = 0;i<arr1.length;i++){ // 这里也可以换成this.length
                    result += this[i];
                    }
                    return result;   // 返回结果
                }
                arr2.sum = function(){
                var result = 0;
                for(var i = 0;i<arr2.length;i++){
                    result += this[i];
                }
                return result;   // 返回结果
                }
                console.log("数组arr1和为",arr1.sum()); // 55
                console.log("数组arr2和为",arr2.sum()); // 72
             // 原型写法
                var arr1 = [1,2,3,4,5,6,7,8,9,10];
                var arr2 = [2,4,6,8,10,12,14,16]
                Array.prototype.sum = function(){
                var result = 0;
                for(var i = 0;i<this.length;i++){
                    result += this[i];
                }
                    return result;
                }
                console.log("数组arr1的和为",arr1.sum()); // 数组arr1的和为55 
                console.log("数组arr2的和为",arr2.sum()); // 数组arr2的和为72
                console.log(arr1.sum === arr1.sum);       // true
            //普通函数封装写法,也就是闭包写法
                var arr1 = [1,2,3,4,5,6,7,8,9,10];
                var arr2 = [2,4,6,8,10,12,14,16]
                function AddResult(arr){
                    arr.sum = function(){
                    var result = 0;
                    for(var i = 0;i<this.length;i++){ // 这里也可以换成this.length
                        result += this[i];
                    }
                    return result;   // 返回结果
                }
                return arr.sum();
                }
                console.log("数组arr1和为",AddResult(arr1)); // 数组arr1和为55
                console.log("数组arr2和为",AddResult(arr2)); // 数组arr2和为72
        函数原型：
            __proto__
            对象身上系统自己添加一个__proto__指向我们构造函数的原型对象。之所以我问可以使用构造函数prototype原型对象和方法，就是因为对象有__proto__的存在。
                __proto__对象原型和原型对象prototype是等价的。
                即上例：ldh.__proto__===Star.prototype;//true
            方法的查找规则：首先先看ldh对象身上是否有sing，如果没有这个方法，因为有__ptoto__的存在，就去构造函数原型对象prototype身上查找sing方法。
                __proto__对象原型存在的作用就是为了对象查找机制提供一个方向，或者说一条线路，但是他是一格非标准的属性，因此实际中，不要使用这个属性，他只是内部指向原型对象prototype。
        constructor构造函数
            很多情况下，我们需要手动利用constructor这个属性来指回原来的构造函数
                Star.prototype={
                    //如果我们修改了原来的对象原型，给原型对象赋值的是一个对象，则必须手动利用constructor指向原来的构造函数
                    constructor:Star,
                    sing:function(){
                        console.log('唱歌');
                    }
                    movie:function(){
                        console.log("电影");
                    }
                }
        构造函数、实例、原型对象三者的关系
            Star构造函数            通过Star.prototype指向              Star原型对象prototype
            Star原型对象prototype   通过Star.prototype.constructor指回  Star构造函数
            ldh对象实例             通过ldh.__proto__指向               Star原型对象prototype
            ldh对象实例             通过ldh.__proto__.constructor指向   Star构造函数
        原型链：
            我们Star原型对象里的__proto__原型指向的是Object.prototype
            Object.prototype里面的原型__proto__指向的是空null；
        JavaScript的成员查找机制
            当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有这个属性
            如果没有就去查找它的原型（也就是__proto__指向的prototype原型对象）
            如果还没有就去找他原型对象的原型（Object的原型对象）
            以此类推一直找到Object为止（null）
        原型对象的this指向问题
            在构造函数中，this指向的是对象实例
            原型对象函数里面的this指向的也是实例对象
        原型对象应用：扩展内置对象
            可以通过原型对象，对原来的内置对象进行扩展自定义方法，比如给数组添加只是难以求偶数和的功能
                Array.prototype.sum=function(){
                    var sum=0;
                    for(var i=0;i<this.length;i++){
                        sum+=this[i];
                    }
                    return sum;
                }
                var arr=[1,2,3];
                console.log(arr.sum);//6
    继承
        ES6之前并没有提供extends继承，我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承
        call()
            调用这个函数，并且修改函数的this指向
            fun.call(thisArg,arg1,arg2...)
            thisArg:当前调用函数的this指向
            arg1...普通参数
                function fn(x ,y){
                    console.log('在想皮尺');
                    console.log(this);
                    console.log(x+y);
                }
                var o={
                    name:'andy';
                };//定义一个对象
                //fn();
                //call()调用函数。
                fn.call();
                //call()可以改变这个函数的this指向
                fn.call(o,1,5);//this就指向了o这个对象。
            利用构造函数继承父类属性
                核心原理：通过call()把父类的this指向子类的this，这样就可以实现子类继承父类的属性。
                //父亲构造函数
                function Father(uname,age){
                    //this指向父亲构造函数对象实例
                    this.uname=uname;
                    this.age=age;
                }
                //子构造函数
                function Son(uname,age，score){
                    //this指向子构造函数的对象实例
                    Father.call(this);//调用父亲构造函数。然后将父亲构造函数里的this指针利用call变为子构造函数的this，实现使用父亲构造函数的属性。
                    this.score=score;
                }
                var son=new Son('刘德华',15,55);
            利用原型对象继承父类方法
                //父亲构造函数
                function Father(uname,age){
                    //this指向父亲构造函数对象实例
                    this.uname=uname;
                    this.age=age;
                }
                //将公共方法添加到原型对象里
                Father.prototype.money=function(){
                    console.log(1000);
                }
                //子构造函数
                function Son(uname,age，score){
                    //this指向子构造函数的对象实例
                    Father.call(this);//调用父亲构造函数。然后将父亲构造函数里的this指针利用call变为子构造函数的this，实现使用父亲构造函数的属性。
                    this.score=score;
                }
                //Son.prototype=Father.prototype;/这样直接赋值会有问题，如果修改了子原型对象，符原型对象也会一起跟着改变。
                Son.prototype=new Father();
                //将实例化的Father赋值给Son的原型对象，通过原型链来实现继承父类的原型对象
                //如果利用了对象修改原型对象，别忘了利用constructor指回原来的构造函数
                Son.prototype.constructor=Son;
                //子构造函数的专门的方法
                Son.prototype.exam=function(){
                    console.log('孩子需要考试');
                }
                var son=new Son('刘德华',15,55);
    类的本质
        ES6之前通过 构造函数+原型实现面向对象编程（继承）
        （1）构造函数有原型对象prototype
        （2）构造函数原型对象prototype里面有constructor指向构造函数本身
        （3）构造函数可以通过原型对象添加方法
        （4）构造函数创建实例对象有__proto__原型指向构造函数的原型对象
        ES6通过类实现面向对象编程
        类的本质其实还是一个函数，我们可以简单地理解为构造函数的另一种写法
            （1）类有原型对象prototype
            （2）类原型对象prototype里面有constructor指向构造函数本身
            （3）类可以通过原型对象添加方法
            （4）类创建实例对象有__proto__原型指向构造函数的原型对象
        所以ES6的类其实就是语法糖，语法糖就是一种便捷写法
    ES5中新增的方法
        数组方法
            迭代（遍历方法）: forEach() map() filter() some() every()
                forEach()
                    arry.forEach(function(currentValue,index,arr));
                    currentValue
                        数组当前项的值
                    index
                        数组当前项的索引
                    arr
                        数组对象本身
                    var arr=[1,2,3];
                    var sum=0;
                    arr.forEach(function(value,index,arr){
                        console.log('每个数组元素'+value);
                        console.log('每个数组元素的索引号'+index);
                        console.log('数组本身'+arr);
                        sum+=value;
                    })
                filter()
                    filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中的符合条件的所有元素，主要用于筛选数组
                    arry.filter(function(currentValue,index,arr));
                    注意他直接返回一个新数组
                    var arr=[22,10,66,52,14];
                    var newarr=arr.filter(function(value,index,arr){
                        return value>=20;
                    })
                    console.log(newarr);//[22,66,52]
                some()
                    arry.some(function(currentValue,index,arr))
                    some()方法用于检测数组中是否有满足指定条件的元素
                    注意：它的返回值是一个布尔值，如果找到返回true否则false
                在foreach里的return不会终止迭代，some里的return会终止迭代，效率更高。
        字符串方法：
            trim():
                trim()方法会从一个字符串的两端删除空白字符串。但是不会去除字符串中间的空格。
                str.trim()
                trim()方法不会影响字符串本身，他返回的是一个新的字符串。
        Object.defineProperty() 
            Object.defineProperty() 定义新的属性或者修改原有属性
            原始的给对象新增(修改)属性方法：
                var obj={
                    id:1,
                    pname:'小米',
                    price:500
                }
                obj.num=1000; 
                obj.price=2000;
            ES5新增方法
                Object.defineProperty(obj,prop,descriptor) ;
                obj:必须，目标对象
                prop:必须，需要定义或者修改的属性名
                descriptor:必须，目标属性所拥有的特性
                            以对象形式书写{};
                            value:设置属性的值，默认为undefined
                            writable:值是否可以重写，true或者false，默认为false
                            enumerable:目标属性是否可以被枚举，true或者false，默认为false
                            configurable:目标属性是否可以被删除或者再次修改特性，true或者false，默认false
                var obj={
                    id:1,
                    pname:'小米',
                    price:500
                }
                Object.defineProperty(obj,'num',{
                    value:1000
                })
                Object.defineProperty(obj,'id',{
                    writable:false;//设置id值不允许修改
                })
                Object.defineProperty(obj,'address',{
                    value:'中国山东',
                    enumerable:false, //设置该属性不能被枚举（不能被遍历，用户不可见）
                    configurable:false  //设置该属性不能被删除，而且不能再次设置该属性第三个参数的特性
                })
                delete obj.address; //删除失败，因为address属性被设置不允许删除
        对象方法
            Object.keys(obj);
                效果类似于for...in
                返回的是一个由属性名组成的数组
    函数进阶
        函数的定义和调用
            //1.自定义函数（命名函数）
            function fn(){};
            //2.函数表达式（匿名函数）
            var fun=function(){};
            //3.利用new Function('参数1','参数2','函数体');
            var f=new Function('x','y','console.log(x+y)');
            f(5,12);//17
            所有函数都是Function对象的实例（对象），所以所有的函数都是对象，所有的对象都有原型（__proto__）
            函数的调用：
                1.普通函数
                    function fn(){
                        console.log('JavaScript');
                    }
                    fn();//或者
                    fn.call();
                2.对象和方法
                    var o={
                        sayhi:function(){
                            console.log('JavaScript');
                        }
                    }
                    o.sayhi();
                3.构造函数
                    function str(){
                        console.log('JavaScript');
                    };
                    var s=new star();
                4.绑定事件函数
                    tbn.onclick=function(){
                        console.log('JavaScript');
                    }
                    鼠标点击按钮调用该函数
                5.定时器函数
                    setInterval(function(){
                        console.log('JavaScript');
                    },1000)
                    定时器自动调用每1秒
                6.立即执行函数
                    (function(){
                        console.log('JavaScript');
                    })();
                    //立即执行函数立即调用（自动调用）
        this
            函数内的this指向
                这些this指向，当我们调用函数的时候确定的，调用方式的不同决定了this的指向不同，一般指向函数的调用者
                    1.普通函数
                        this指向 window
                    2.对象和方法
                        this指向 该方法所属的对象
                    3.构造函数
                        this指向 实例对象，原型对象里的方法也指向实例对象
                    4.绑定事件函数
                        this指向 绑定事件对象
                    5.定时器函数
                        this指向 window
                    6.立即执行函数
                        this指向 window
                改变函数内部的this指向
                    call()
                        call 可以调用函数，还可以改变函数内的this指向
                        call的主要作用可以实现继承
                        var o={
                            name:'andy'
                        }
                        function fn(x,y){
                            console.log(this);
                            console.log(x+y);
                        }
                        fn.call(o,1,2);//o,3
                        function Father(uname,age,sex){
                            this.uname=uname;
                            this.age=age;
                            this.sex=sex;
                        }
                        function Son(){
                            Father.call(this,uname,age,sex);
                        }
                        var son=new Son('刘德华',25,'男');
                        console.log(son);
                    bind()
                        bind()方法不会调用函数，但是能改变函数内部的this指向
                            fun.bind(thisArg,arg1,arg2....);
                            thisArg:在fun函数运行时指定的this值；
                            arg1,2..:传递的其他参数
                            返回值由指定的this值和初始化的参数改造的原函数拷贝,返回的是原函数改变this之后产生的新函数
                            var o={
                                name:'andy'
                            };
                            function fn(x,y){
                                console.log(this);
                                console.log(x+y);
                            };
                            var f=fn.bind(o,1,5);
                            f();    //o 6
                            //典型应用：如果有的函数我们不要立即调用，但是又想改变这个函数内部的this指向时，这时候用bind（）最合适。
                                比如：我们有一个按钮，点击了之后，禁用这个按钮，秒后重新开启这个按钮
                                var btn=document.querySelector('button');
                                btn.onclick=function(){
                                    this.disabled=true;
                                    //setTimeout(function(){
                                    //    this.disabled=false;//定时器的///this指向的是window，所以这里是错误的
                                    //},3000)
                                    setTimeout(function(){
                                        this.disabled=false;//此时这里的this因为被bind（）改变了this指向，指向的就是btn这个按钮元素
                                    }.bind(this),3000);//这个this指向的是btn这个元素对象
                                }
                    apply()
                        apply()方法调用一个函数，简单理解为调用函数的方式，但是他可以改变函数内的this指向。
                            fun.apply(thisArg,[argArray]);
                            thisArg:在fun函数运行时指定的this值
                            argsArray:传递的值，必须包含在数组(或者伪数组)里面
                            返回值就是函数的返回值，因为他就是调用函数
                        var o={
                            name:'andy'
                        };
                        function fn(arr){
                            console.log(this);
                            console.log(arr);
                        };
                        fn.apply(o,['2','sdf','3']);//Object 2 sdf 3 注意他打印的时候不是按照数组形式打印，而是拆分成字符串打印
                        apply的主要运用
                            比如利用apply()借助数学内置对象求数组的最大值
                            var arr=[0,22,15,33,12,8];
                            var max=Math.max.apply(null,arr);//这里不需要改变this指向，所以将第一个参数设置为null，但是直接设置为null不太合适，应该将this指向它的调用者，即Math,所以这样写更合适var max=Math.max.apply(Math,arr);
                            console.log(max);//33

        严格模式
            严格模式消除了JavaScript语法中的一些不合理不严谨之处，减少了一些怪异行为
            严格模式修复了一些导致 JavaScript引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。
            严格模式禁用了在ECMAScript的未来版本中可能会定义的一些语法。
            开启严格模式：
                为整个脚本开启严格模式：
                    在所有js语句之前放一个特定语句："use stuict";(或者'use strict';)
                为函数开启严格模式：
                    function fn(){
                        'use strict';//fn开启严格模式
                    }
                    function fun(){

                    }
            严格模式中的变化：
                变量变化：
                    在正常模式中，如果一个变量没有声明就赋值，默认是全局变量，严格模式禁止这种用法，变量都必须先用var 声明，然后再使用。
                    严禁删除已经声明的变量。delete会报错
                严格模式下this指向问题  
                    以前在全局作用域下的this指向的是window;
                    严格模式全局作用域下的this指向的是undefined。 
                    以前构造函数不加new也可以调用，当普通函数调用this指向全局对象 
                    严格模式下，如果构造函数不加new调用，this会报错。
                    new实例化的构造函数指向创建的对象实例。
                    定时器里的this还是指向window这点没有变化。
                    事件对象还是指向调用者
                函数变化
                    函数不能有重名的参数
                    函数声明必须在顶层，不允许在非函数的代码块声明函数
                        "use strict";
                        if (true) {
                        function f() { } // !!! 语法错误
                        f();
                        }
                        for (var i = 0; i < 5; i++) {
                        function f2() { } // !!! 语法错误
                        f2();
                        }
                        function baz() { // 合法
                        function eit() { } // 同样合法
                        }
        高阶函数
            高阶函数是对其他函数进行操作的函数，他接收的函数作为参数或者将函数作为返回值输出
            function fn(callback){
                callback&&callback();
            }
            fn(function(){
                alert('hi');
            })
            fn 就是一个高阶函数
            function fn(){
                return function(){};
            }
            fn();
            fn也是一个高阶函数
        闭包（closure）
            变量作用域
                函数内部可以使用全局变量
                函数外部不可以使用局部变量
                当函数执行完毕，本作用域内的局部变量会被销毁
            闭包：就是指有权访问另一个函数作用域中的函数。简单理解就是一个作用域可以访问另一个作用域的局部变量所在的函数。
            闭包的主要作用：
                延伸了变量的作用范围
            function fn (){
                var num=10;
                function fun(){
                    console.log(num);
                }
                fun();
            }
            fn();
            我们fun这个函数的作用域访问了另一个函数fn里面的局部变量num
            fn外部的作用域可以访问fn内部的局部变量
            function fn (){
                var num=10;
                function fun(){
                    console.log(num);
                }
                return fun;
            }
            var f=fn();
            f();//10
            //类似于 var f=function fun(){
                    console.log(num);
                }
            闭包应用：点击当前小li打印当前索引号
                var lis=document.querySelector('nav').querySelectorAll('li');
                //方法1:利用动态添加属性index的方法
                for(var i=0;i<li.length;i++){
                    lis[i].index=i;
                    lis[i].onclick=function(){
                        console.log(this.index);
                    }
                }
                //方法2：利用闭包的方法得到当前小li的索引号
                for(var i=0;i<=lis.length;i++){
                    //利用for循环创建lis.length个立即执行函数
                    //立即执行函数也称为小闭包
                    (function(i){
                        lis[i].onclick=function(){
                        console.log(i);
                    }
                    })(i)
                }
            闭包应用：3秒后打印所有小li元素的内容
                var lis=document.querySelector('nav').querySelectorAll('li');
                for(var i=0;i<lis.length;i++){
                    (function(a){
                        setTimeout(function(){
                            console.log(lis[a].innerHTML);
                    },3000)
                    })(i);
                }
            闭包应用：计算打车价格
                打车起步价13（3公里内），之后每多跑1公里会增加5元，用户输入公里数就能得到打车价格
                如果有拥堵情况，总价格多收10元拥堵费
                var car=(function(){
                        var star=13
                        var total=0;
                        return{
                            price:function(n){
                                if(n<=3){
                                    total=star;
                                }else{
                                    total=star+((n-3)*5);
                                }
                                return total;
                            }
                            //拥堵之后的费用
                            yongdu:function(flag){
                                return flag?true=total+10:total;
                            }
                        }
                    })();
                    console.log(car.price(5));//23
                    console.log(car.yongdu(true));//33

        递归
            var num=1;
            function fn(){
                console.log('2565');
                if(num==6){
                    return;
                }
                num++;
                fn();
            }
            fn();
            利用递归求n的阶层
                function fn(n){
                    if(n==1){
                        return;
                    }
                    return n*fn(n-1);
                    
                }
                console.log(fn(3));//6
            利用递归求斐波那契序列 1 1 2 3 5 8 13 21
                function fn(n){
                    if(n==1||n==2){
                        return 1;
                    }
                    return fn(n-2)+fn(n-1);
                }
            利用递归遍历数据
                var date=[
                    {
                        id:1,
                        name:'家电'
                        goods:[
                            {
                                id:11,
                                gname:'冰箱'
                                goods:[
                                    {
                                        id:111,
                                        gname:'海尔'
                                    },{
                                        id:112,
                                        gname:'美的'
                                    },{
                                        id:113,
                                        gname:'格力'
                                    }
                                ]
                            },{
                                id:12,
                                gname:'洗衣机'
                            }
                        ]
                    },{
                        id:2,
                        name:'服饰'
                    }
                ];
                输入id号，就可以返回对应的数据对象
                1利用foreach去遍历
                function getID(Json,id){
                    var o=null;
                    Json.forEach(function(item){
                        if(item.id==id){
                            console.log(item);
                            o=item;
                        }
                        else if(item.goods&&item.goods.length>0){
                           //利用递归函数来查找深层id号
                            o=getID(item.goods,id); 
                        }
                    })
                    return o;
                }
                console.log(getID(date,112));//id:112 gname:'美的'
            浅拷贝和深拷贝
                浅拷贝只是拷贝一层，更深层次的对象只是拷贝引用。
                    ES6新增浅拷贝语法糖
                        Object.assign(target,...source);
                        target:拷贝给谁
                        source：拷贝的对象
                深拷贝拷贝多层，每一层每一级的数据都会被拷贝
                    浅拷贝：
                        var obj={
                            //浅层数据
                            id:1,
                            name:'andy',
                            //深层数据，复杂数据类型，对象
                            msg:{
                                age:18
                            }
                        };
                        var o={};
                        for(var k in obj){
                            //k是属性名 obj[k]是属性值
                            o[k]=obj[k];
                            //这样拷贝有个问题，他拷贝的是msg的地址。因为msg是一个对象，既然是一个对象，他就会在内存中新开辟一个内存空间，来存放我们的age:18;如果用这种拷贝方式，他属于浅拷贝，他只是将这个对象的地址拷贝给o，o里面存放的是msg的地址，即存放的还是原来obj里存放的数据。此时修改obj里面的msg数据，同样会影响o里面的数据。因为他们指向的数同一个地址。
                        }
                        console.log(o);
                        使用es6新增方法实现浅拷贝：
                            Object.assign(o,obj);
                    深拷贝：
                        深拷贝，在拷贝对象的时候，是将内存空间里的复杂数据类型（对象）在内存空间进行了一次拷贝，将拷贝的对象赋值给新的拷贝。
                        var obj={
                            //浅层数据，普通数据类型，简单数据类型
                            id:1,
                            name:'andy',
                            //深层数据，复杂数据类型，对象
                            msg:{
                                age:18
                            };
                            color:['black','red','white','pink']
                        };
                        var o={};
                        //使用函数递归实现深拷贝
                        //封装函数
                        function deepcopy(newobj,oldobj){
                            for(var k in oldobj){
                                //判断属性值属于那种数据类型
                                //1获取数据属性值 oldobj[k]
                                var item=oldobj[k];
                                //2判断这个值是否属于数组
                                //这里为什么要先把数组的深拷贝放到object前面：因为数组也属于object，如果先将object放到前面，就会把数组当成obj解析，这样是不对的。
                                if(item instanceof Array){
                                    newobj[k]=[];
                                    deepcopy(newobj[k],item);
                                }
                                //3判断这个值是否属于对象
                                else if(item instanceof Object){
                                    newobj[k]={};
                                    deepcopy(newobj[k],item);
                                }
                                //4这个值属于简单数据类型
                                else{
                                    newobj[k]=item;
                                }
                            }
                        }
                        deepcopy(o,obj);
                        console.log(o);

题目：
    JS中使用typeof能得到哪些类型
        typeof undefined; //undefined
        typeof 'abc' //string
        typeof 123 //number
        typeof true //boolean
        typeof {} //object
        typeof [] //object
        typeof null //object
        typeof console.log //function
    如何使用===和==
        if(obj.a==null){
            //这里相当于obj.a===null||obj.a===undefined 简写形式
            //这里是JQuery源码中推荐的写法
        }
        一、概念 == 和 === 
            (1)  "=="叫做相等运算符，"==="叫做严格运算符。
            (2) ==，equality -> 等同  的意思， 两边值类型不同的时候，要先进行类型转换为同一类型后，再比较值是否相等。 
            ===，identity -> 恒等 的意思，不做类型转换，类型不同的结果一定不等。 
            (3) "=="表示只要值相等即可为真，而"==="则要求不仅值相等，而且也要求类型相同。
            对于明确数据类型的用===更为可靠，JavaScript是一门弱类型语言，表达式运算赋值等操作都会导致类型转换。而一些隐式转换会带来一些意想不到的后果。
            编程建议：尽量使用严格运算符 ===。因为"=="不严谨，可能会带来一些违反直觉的后果。
        二、严格运算符 === 的运算规则
            严格运算符===的运算规则如下，
            (1)不同类型值
            如果两个值的类型不同，直接返回false。
            (2)同一类的原始类型值
            同一类型的原始类型的值（数值number、字符串string、布尔值boolean）比较时，值相同就返回true，值不同就返回false。
            (3)同一类的复合类型值/高级类型
            两个复合类型（对象Object、数组Array、函数Funtion）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。即“地址指针”是否相等。
            (4)undefined和null
                //undefined 和 null 与自身严格相等。
                null === null  //true
                undefined === undefined  //true
                undefined === null  //true
    js中有哪些内置函数
        object
        array
        boolean
        number
        string 
        function
        Date
        RegExp
        Error
    JS变量按存储方式区别为哪些类型，并描述其特点
    如何理解JSON

知识点：
    变量类型和变量计算：
        值类型（基本类型）：字符串（string）、数值（number）、布尔值（boolean）、undefined、null  （这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值）
            值类型
            var a=100;
            var b=a;
            a=200;
            console.log(b);//100
        引用类型：对象（Object）、数组（Array）、函数（Function）
            var a={age:20};
            var b=a;
            b.age=23;
            console.log(a.age);//23
        2.值类型和引用类型的区别
            （1）值类型：
                    1、占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）
                    2、保存与复制的是值本身
                    3、使用typeof检测数据的类型
                    4、基本类型数据是值类型
            （2）引用类型：
                    1、占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）
                    2、保存与复制的是指向对象的一个指针
                    3、使用instanceof检测数据类型
                    4、使用new()方法构造出的对象是引用型
    typeof运算符
        typeof只能区分出值类型，引用类型区分不出来，但是可以区分出引用类型中的函数
        typeof undefined; //undefined
        typeof 'abc' //string
        typeof 123 //number
        typeof true //boolean
        typeof {} //object
        typeof [] //object
        typeof null //object
        typeof console.log //function
    变量计算-强制类型转换
        字符串拼接
            var a=100+10 //110
            var b=100+'10'//10010
        ==运算符
            100=='100'//true
            0=='' //true 
            null==undefined //true
        if语句
            var a=true
            if(a){
                //true,进入
            }
            var b=100
            if(b){
                //true，进入
            }
            var c=''
            if(c){
                //false
            }
        逻辑运算
            console.log(10 && 0) //0
            console.log(''||'abc') //'abc'
            console.log(!window.abc) //true
            //判断一个变量会被当做true还是false
            var a=100
            con.log(!!a)
九、js面试
    开发环境
    开发环境 - babel

一、js中布尔值为false的六种情况
    下面6种值转化为布尔值时为false，其他转化都为true

    1、undefined（未定义，找不到值时出现）

    2、null（代表空值）

    3、false（布尔值的false，字符串"false"布尔值为true）

    4、0（数字0，字符串"0"布尔值为true）

    5、NaN（无法计算结果时出现，表示"非数值"；但是typeof NaN==="number"）

    6、""（双引号）或''（单引号） （空字符串，中间有空格时也是true）

    注意空数组空对象，负值转的布尔值时都为true

        不同数据类型转化为布尔值的结果
        数据类型	    转为true的值	转为false的值
        Boolean	        true	        false
        String	        任何非空字符串	''（空字符串）
        Number	        任何非零数字值（包括无穷大）	0和NaN
        Object	        任何对象	    null
        Undefined	    n/a	            undefined
 

        对于0, '', null, undefined, NaN，{}, [], Infinity求布尔值，分别是false false false false false true true true.

        因此我们知道的一点是：对象的布尔值是true，即使是对象{}。

 

        "!!"将表达式进行强制转化为bool值的运算，运算结果为true或者false。

        例如 array=[1,2,3]      array.num=undefind   !array.num=true   !!array.num=false

 

二、出现undefind的中情况
    1、未初始化的变量

        变量未定义 或 变量定义了没有赋值  或者 函数形参未赋值

    2、不返回任何结果的函数的调用结果

        函数return没有值 

        function show(){
        return;
        };
        console.log(show());   // undefined
        函数没有return

        function show(){
                    
        };
        console.log(show());  // undefined
    3. 不存在的对象属性或方法

        let favoriteMovie = {
        title: 'Blade Runner'
        };
        favoriteMovie.actors; // => undefined
    4.越界索引数组元素

        const colors = ['blue', 'white', 'red'];
        colors[5];  // => undefined
        colors[-1]; // => undefined
 

三、出现null的几种情况
    1.在JS的DOM元素获取中，如果没有获取到指定的元素对象，结果一般是null。

    2.Object.prototype._proto_的值也是null。

    3.在正则捕获的时候，如果没有捕获到结果，默认也是null。

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments

 


            

    
                        
        