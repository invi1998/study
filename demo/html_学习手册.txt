快捷操作：
    <!-- Alt+shift+向下箭头 实现复制上一次操作 -->
    Lorem+数字 快速生成一段指定长度的字符串
    Alt + Shift + A 块注释
    单行注释
        Ctrl + /
        或 先按CTRL+K，再按CTRL+U
    取消单行注释：
        Ctrl + /
        或 先按CTRL+U，再按CTRL+K
    Visual Studio Code同时选中多行输入，Alt + Shift + 鼠标左键选取多行 （连续多行）
    同时选中多行输入，Alt+左键选中多行(跳行)
    使用鼠标中键（滚轮键按压）进行列选择
    vs code格式化代码的快捷键如下：（来源于这里）
        On Windows Shift + Alt + F
        On Mac Shift + Option + F
        On Ubuntu Ctrl + Shift + I

    IE:Trident（IE8->IE8:Jscript->Chakra)

    Edge:EdgeHTML

    FF：Gecko

    Safari:KHTML->Webkit(WebCore+JSCore)->Webkit2

    Chrome:Webkit->Chromium(V8)->Chromium(Blink+V8)

    Opera:Presto->Chromium(V8)->Chromium(Blink+V8)
    
一、什么是HTML语义化标签

    语义化的标签，说明让标签有自己的含义。

    <p>一行文字</p>

    <span>一行文字</span>

    如上代码，p 标签与 span 标签都区别之一就是，p 标签的含义是：段落。而 span 标签责没有独特的含义。

二、语义化标签的特点

    代码结构清晰，方便阅读，有利于团队合作开发。

    方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。

    有利于搜索引擎优化（SEO）。

    便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。

三、常见的语义化标签

    因此我们在写页面结构时，应尽量使用有 语义的HTML 标签

    <title>：页面主体内容。

    <hn>：h1~h6，分级标题，<h1> 与 <title> 协调有利于搜索引擎优化。

    <ul>：无序列表。

    <ol>：有序列表。

    <header>：页眉通常包括网站标志、主导航、全站链接以及搜索框。

    <nav>：标记导航，仅对文档中重要的链接群使用。

    <main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。

    <article>：定义外部的内容，其中的内容独立于文档的其余部分。

    <section>：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。

    <aside>：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。

    <footer>：页脚，只有当父级是body时，才是整个页面的页脚。

    <small>：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。

    <strong>：和 em 标签一样，用于强调文本，但它强调的程度更强一些。

    <em>：将其中的文本表示为强调的内容，表现为斜体。

    <mark>：使用黄色突出显示部分文本。

    <figure>：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。

    <figcaption>：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。

    <cite>：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。

    <blockquoto>：定义块引用，块引用拥有它们自己的空间。

    <q>：短的引述（跨浏览器问题，尽量避免使用）。

    <time>：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。

    <abbr>：简称或缩写。

    <dfn>：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。

    <del>：移除的内容。

    <ins>：添加的内容。

    <code>：标记代码。

    <meter>：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）

    <progress>：定义运行中的进度（进程）。
一.HTML
    1.文档结构标签
        <html>...</html> 标识HTML文档的起始和终止
        <head>...</head> 标识HTML文档的头部区域
        <body>...</body> 标识HTMl文档的主体区域
    2.HTML元信息
        注：<meta>标签的属性主要分两组：
            1.name和content属性 设置网页的描述信息，检索关键字和搜索引擎的检索权限等
            eg:
                <meta name="description" content="标准网页设计技术资讯"/> 定义网页的描述信息
                <meta name="keywords" content="HTML,DHTML,CSS,XML,XHTML,JavaScript,VBScript"/> 定义网页页面关键字
                <meta name="author" content="invi1998"/> 设置网页作者
                <meta name="copyright" content="https://www.invi1998.top"/> 设置网页版权
                <meta name="date" content="2019-08-02T08:34:00+00:00"/> 设置创建时间
                <meta name="robots" content="none"/> 设置禁止搜索引擎搜索
                <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"> 设置视口宽度为设备宽度，初始化缩放比例为1，最大缩放为1，不允许用户缩放（怎么样让一个页面适配移动端：指定viewport）
            2.http-equiv和content属性 http-equiv属性声明http响应报文（即：MIME文档头）content对http-equiv进行详细描述 设置字符编码，刷新时间，是否缓存等基本信息
            eg:
                <meta http-equiv="content-type" content="text/html;charset=UTF-8"/> 设置UTF-8(国际化编码)
                <meta http-equiv="content-type" content="text/html;charset=gb2312"/> 设置gb2312编码
                <meta http-equiv="content-language" content="zh-CN"/> 使用content-language属性设置中文版语言
                <meta http-equiv="refresh" content="5"/> 使用refresh属性值设置页面刷新时间或者跳转（重定向）页面,这里是设置5秒后刷新页面
                <meta http-equiv="refresh" content="5" url=https://www.baidu.com/> 设置5秒后跳转到百度页面
                <meta http-equiv="expires" content="Sunday 20 Octorber 2009 01:00 GMT"/> 使用expires属性值设置网页缓存时间（即过期时间）
                <meta http-equiv="expires" content="no-cache"/> 设置页面不缓存
        在HTML5中，可以对<meta>元素直接追加charset属性来指定字符编码 <meta charset="UTF-8">    
        <base href="/">

    3.HTML常见元素
        head:
            meta
            title
            style
            link
            Script
            base
        body:
            div/section/article/aside/header/footer
            段落
                p
            行内元素
                span/em（默认斜体）/strong（默认粗体）
            表格元素
                table(定义表格结构)/thead/tbody/caption(定义表格标题)/th（表头元素）/tr（行）/td（单元格）/
                <td colspan="2">数据1</td> td元素的colspan属性值定义了该单元格占据多少列单元格
                <td rowspan="2">数据20</td> td元素的rowspan属性的值定义了该单元格占据多少行单元格

            列表元素
                ul（标识无序列表）/ol（标识有序列表）/li（标识列表项目）/dl（标识定义列表）/dt（标识词条）/dd（标识解释）
            链接
                a   <a href="http://baidu.com",target="_self">百度</a> 在当前窗口打开链接（默认）
                    <a href="http://baidu.com",target="_blank">百度</a> 在新建页面打开链接
                    <a href="#btm">跳转到底部</a>
                    <span id="btm"></span>
            
            多媒体标签
                img(嵌入图像)/embed（嵌入多媒体）/object（嵌入多媒体）
                <img src="输入图片路径或者链接",alt="输入替换资源（图片无法正常显示时显示）">
                alt属性和title属性的区别是前者是在图片无复法加载的时候才会显示的其值，而title是在图片正常加载鼠标划上去显示的值，虽然alt也有后者的功能制，但是只是在低版本的ie浏览器才支持，高版本及标准浏览器不支持这个 功能了。
            
            表单元素
                <form>..</form>（定义表单结构）
                    <form target="表单要提交到哪里",method="表单的提交方式（GET(默认是GET方式，参数跟在地址栏后面，以?隔开。多个参数之间以&符号分隔，安全性低。提交的数据有大小限制，不能超过1kb)和POST(参数在地址栏是不可见的，安全性更高。提交的数据是没有大小限制的)）",enctype="要使用哪种编码，主要是针对POST（"multipart/form-data"和"application/x-www-form-urlencoded"）">/
                    一、application/x-www-form-urlencoded:
                        1、表单中的enctype值如果不设置，则默认是application/x-www-form-urlencoded，它会将表单中的数据变为键值对
                        的形式
                        2、如果action为get，则将表单数据编码为(name1=value1&name2=value2…)，然后把这个字符串加到url后面，中间
                        用?分隔
                        3、如果action为post，浏览器把form数据封装到http body中，然后发送到服务器。
                    二、text/plain：
                        表单以纯文本形式进行编码
                    三、multipart/form-data：
                        1、当我们上传的含有非文本内容，即含有文件（txt、MP3等）的时候，需要将form的enctype设置为multipart/form-
                        data。
                        2、将表单中的数据变成二进制数据进行上传，所以这时候这时如果用request是无法直接获取到相应表单的值的
                <input/>（定义文本域、按钮和复选框）
                    type="text" 定义单行文本框。这时input元素可以有以下特殊属性
                        value 定义文本框包含的默认字符串
                        size 定义文本框的字符数，即文本框的宽度，（该属性可以通过css设置，一般不需要html设置）
                        maxlength 定义文本框能够接受的最大字符数
                    type="password" 定义密码域
                    type="hidden" 定义隐藏域。（因为在实际应用中很多数据不需要用户输入，但是需要作为参数传给服务器，于是使用该属性可以传递各种固定参数）
                    type="checkbox" 定义复选框。复选框主要包含value和checked属性，value设置复选框的传递值，checked可以设置复选框在默认状态下是否为选中状态
                    type="radio" 定义单选框。单选框的name属性一样时，表示这些单选框属于同一个组（一组里只能单选一个），同一组的单选框name属性相同，id属性不同
                        <p>
                            <input type="radio" name="radio1" id="radio1-1"/>
                            <lable for="radio1-1">单选框1</lable>
                            <input type="radio" name="radio1" id="radio1-2"/>
                            <lable for="radio1-2">单选框2</lable>
                        </p>
                    type="file" 定义文件域。当表单中包含文件域时，form元素的method属性必须设置为"post",enctype属性必须设置为"multipart/form-data" ，否者操作将会失败
                    type="submit" 定义提交按钮。负责提交表单到服务器
                    type="reset" 定义重设按钮。清空用户输入的数据，恢复到默认状态
                    type="image" 定义图像按钮。他是普通按钮的自定义形式，该按钮没有动作，需要用户通过脚本为其定义动作
                    type="button" 定义普通按钮。该按钮没有动作，需要用户通过脚本为其定义动作
                <textarea>..<textarea/>（定义多行文本框）/
                    cols和rows 设置文本区域的字符宽度和行数(因为这两个属性不属于语义属性，仅用来设置样式，故不推荐使用)
                    wrap 属性定义用户输入内容大于文本域宽度时的显示方式
                        soft:在表单提交时，textarea中的文本不换行（默认）
                        hard在表单提交时，textarea中的文本换行（包括换行符），当使用hard时，必须规定cols属性 
                <select>..</select>（定义下拉列表）/
                    <select name="select">
                        <option value="1">选项1</option>
                        <option value="2">选项2</option>
                    </select>
                    当为select元素定义了size属性后，select元素就会由下拉菜单的形式转换为列表框形式，size的值如果大于等于select元素包含的option元素时，列表框就不会出现滚动条
                    当select定义了size属性后，就可以为select定义multiple属性，设置列表框是否允许多选，multiple取值固定为multiple
                    <select name="seelct" size="3" multiple="multiple">
                        <option value="1">选项1</option>
                        <option value="2">选项2</option>
                    </select>
                    select选项分区
                        使用optgroup元素吧下拉列表选项进行分组，然后使用lable属性为分组定义一个标签
                        <p>
                            <select name="">
                                <optgroup lable="数字">
                                    <option value="1">1</option>
                                    <option value="2">2</option>
                                </optgroup>
                                <optgroup lable="字母">
                                    <option value="a">a</option>
                                    <option value="s">s</option>
                                </optgroup>
                            </select>
                        </p>
                <option>..<option/>(定义下拉列表里的选择项目)/
                表单分组 
                    使用fieldest和legend元素，他相当于一个容器，将这些表单收容在一起。fieldest默认是显示边框的，而legend默认位于右上角，所有这些样式都可以通过css来设置，legend必须包含在fieldest内且紧邻fieldest元素
                    <h1>用户注册表单分组</h1>
                    <form action="action.asp" name="register" id="login">
                        <fieldest>
                        <legend>用户基本信息（必填）</legend>
                        <ul>
                            <li>用户名<input id="" maxlength="12" size="30" name="username"/><span>注册用户长度限制为3~12字节</span></li>
                            <li>论坛密码<input type="password" maxlength="19" size="30" value="" name="password"/></span></li>
                        </ul>
                        </fieldest>
                        <fieldest>
                        <legend>参考资料（选填）</legend>
                        <ul>
                            <li>个人网站<input maxlength="80" size="44" name="homepage"/></li>
                            <li>QQ号码<input maxlength="20" size="44" name="QICQ"/><span>填写您的QQ号码</span></li>
                        </ul>
                        </fieldest>
                        <p><input name="" type="submit" value="提交"/></p>
                    </form>
                绑定提示标签 
                    当用户点击标签文本时，系统会自动把输入焦点定位到对应的表单域中对于快速输入有很大帮助
                    <h1>绑定提示标签到表单域</h1>
                    <form action="action.asp" name="register" id="login">
                        <fieldest>
                        <legend>用户基本信息（必填）</legend>
                        <ul>
                            <li>
                                <lable for="username">用户名</lable>
                                <input id="" maxlength="12" size="30" name="username"/><span>注册用户长度限制为3~12字节</span>
                            </li>
                            <li>
                                <lable for="password">论坛密码</lable>
                                <input type="password" maxlength="19" size="30" value="" name="password"/></span>
                            </li>
                        </ul>
                        </fieldest>
                        <fieldest>
                        <legend>参考资料（选填）</legend>
                        <ul>
                            <li>
                                <lable for="homepage">个人网站</lable>
                                <input maxlength="80" size="44" name="homepage"/>
                            </li>
                            <li>
                                <lale for="QICQ">QQ号码</lale>
                                <input maxlength="20" size="44" name="QICQ"/><span>填写您的QQ号码</span>
                            </li>
                        </ul>
                        </fieldest>
                        <p><input name="" type="submit" value="提交"/></p>
                    </form>
                    也可以使用lable元素嵌套整个表单域对象
                    <lable for="username">用户名<input type="text" id="username" name="username"/><span>注册用户长度限定为3~12字节</span></lable>      
                
                
    4.HTML5语法
        html4中，DOCTYPE声明方法如下：
            <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w5.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
        在HTML5中，不在使用版本声明，一份文档将会适用于所有版本的HTML。HTML5中的DOCTYPE声明如下（不区分大小写）：
            <!DOCTYPE html>
        HTML5中不允许写结束标记的元素：area,base,br,col,command,embed,hr,img,input,keygen,link,meta,param,source,track,wbr


    5.html元素分类
        1.按照默认样式分类
            1.行内元素(inline element)
                行内元素最常使用的就是span，其他的只在特定功能下使用，修饰字体<b>和<i>标签，还有<sub>和<sup>这两个标签可以直接做出平方的效果，而不需要类似移动属性的帮助，很实用。
                行内元素特征：
                    (1)设置宽高无效
                    (2)对margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间,行内元素尺寸由内含的内容决定，盒模型中 padding, border 与块级元素并无差异，都是标准的盒模型，但是 margin 却只有水平方向的值，垂直方向并没有起作用。行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。padding设置上下左右都有效，即会撑大空间但是不会产生边距效果。
                    (3)不会自动进行换行
            2.块状元素（block element）
                块状元素代表性的就是div，其他如p、nav、aside、header、footer、section、article、ul-li、address等等，都可以用div来实现。不过为了可以方便程序员解读代码，一般都会使用特定的语义化标签，使得代码可读性强，且便于查错。
                块状元素特征：
                    (1)能够识别宽高
                    (2)margin和padding的上下左右均对其有效
                    (3)可以自动换行
                    (4)多个块状元素标签写在一起，默认排列方式为从上至下
            3.行内块状元素（inline-block element）
                行内块状元素综合了行内元素和块状元素的特性，但是各有取舍。因此行内块状元素在日常的使用中，由于其特性，使用的次数也比较多。
                行内块状元素特征：
                    (1)不自动换行
                    (2)能够识别宽高
                    (3)默认排列方式为从左到右
                    在HTML5中，程序员可以自定义标签，在任意定义标签中，加入display:block;即可，当然也可以是行内或行内块状。　
                        值	                描述
                        none	            此元素不会被显示。
                        block	            此元素将显示为块级元素，此元素前后会带有换行符。
                        inline	            默认。此元素会被显示为内联元素，元素前后没有换行符。
                        inline-block	    行内块元素。（CSS2.1 新增的值）
                        list-item	        此元素会作为列表显示。
                        run-in	            此元素会根据上下文作为块级元素或内联元素显示。
                        compact	CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。
                        marker	CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。
                        table	            此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。
                        inline-table	    此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。
                        table-row-group	    此元素会作为一个或多个行的分组来显示（类似 <tbody>）。
                        table-header-group	此元素会作为一个或多个行的分组来显示（类似 <thead>）。
                        table-footer-group	此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。
                        table-row	        此元素会作为一个表格行显示（类似 <tr>）。
                        table-column-group	此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。
                        table-column	    此元素会作为一个单元格列显示（类似 <col>）
                        table-cell	        此元素会作为一个表格单元格显示（类似 <td> 和 <th>）
                        table-caption	    此元素会作为一个表格标题显示（类似 <caption>）
                        inherit	            规定应该从父元素继承 display 属性的值。　　
        2.HTML5中，元素主要分为7类：
            Metadata
            Flow
            Sectioning
                Sectioning意指定义页面结构的元素，具体包含以下四个：article, aside, nav, section
            Heading
                所有标题元素属于Heading，也即以下6个元素：h1, h2, h3, h4, h5, h6
            Phrasing
            Embedded
                所有用于在网页中嵌入外部资源的元素均属于Embedded元素，具体包含以下9个：audio, video, img, canvas, svg, iframe, embed, object, math
            Interactive
    6.html元素的嵌套关系
        1.块级元素可以包含行内元素
        2.块级元素不一定可以包含块级元素　
            p不能包含块级元素div
        3.行内元素一般不能包含块级元素
            <a><div></div></a>可以包含块级元素　　
    7.html元素默认样式
        css Reset (去除浏览器默认html样式)  
        eg1:
            <style>
                *{
                    margin:0;
                    panding:0;
                }
            </style> 
    8.各种补充
        nav
            HTML5中的新元素标签<nav>用来将具有导航性质的链接划分在一起，使代码结构在语义化方面更加准确，同时对于屏幕阅读器等设备的支持也更好。
            一直以来，我们习惯于使用形如<div id="nav">或<ul id="nav">这样的代码来写页面的导航；在HTML5中，我们可以直接将导航链接列表放到<nav>标签中：
            <nav>
            <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="/about/">About</a></li>
            <li><a href="/blog/">Blog</a></li>
            </ul>
            </nav>
            根据W3C的定义规范：
            nav元素是一个可以用来作为页面导航的链接组；其中的导航元素链接到其他页面或当前页面的其他部分。并不是所有的链接组都要被放进<nav>元素；例如，在页脚中通常会有一组链接，包括服务条款、首页、版权声明等；这时使用<footer>元素是最恰当的，而不需要<nav>元素。
            一个页面中可以拥有多个<nav>元素，作为页面整体或不同部分的导航；下面是W3C给出的一个代码示例：
            <body>
            <h1>The Wiki Center Of Exampland</h1>
            <nav>
            <ul>
            <li><a href="/">Home</a></li>
            <li><a href="/events">Current Events</a></li>
            ...more...
            </ul>
            </nav>
            <article>
            <header>
            <h1>Demos in Exampland</h1>
            <p>Written by A. N. Other.</p>
            </header>
            <nav>
            <ul>
            <li><a href="#public">Public demonstrations</a></li>
            <li><a href="#destroy">Demolitions</a></li>
            ...more...
            </ul>
            </nav>
            <div>
            <section id="public">
            <h1>Public demonstrations</h1>
            <p>...more...</p>
            </section>
            <section id="destroy">
            <h1>Demolitions</h1>
            <p>...more...</p>
            </section>
            ...more...
            </div>
            <footer>
            <p><a href="?edit">Edit</a> | <a href="?delete">Delete</a> | <a href="?Rename">Rename</a></p>
            </footer>
            </article>
            <footer>
            <p><small>© copyright 1998 Exampland Emperor</small></p>
            </footer>
            </body>
            在这个示例中，我们可以看到<nav>不仅可以用来作为页面全局导航，也可以放在<article>标签内，作为单篇文章内容的相关导航链接到当前页面的其他位置。 　
    8.面试真题
        1.doctype的意义是什么？
            让浏览器以标准模式渲染
            让浏览器知道元素的合法性
        2.html,xhtml和HTML5的关系？
            html属于SGML的一个应用
            XHTML属于XML，是HTML进行XML严格化的结果
            HTML5不属于SGML或者XML，是一个独立的规范，比XHTML宽松  
        3.HTML5有什么变化？
            （HTML5带来的变化更大的不在于标签层面而在于接口层面）
            新的语义化元素
            表单增强
            新的API（离线，音视频，图形，实时通信，本地存储，设备能力）
            分类和嵌套规则的变更  
        4.em和i有什么区别？
            （都是斜体样式）
            em是语义化的标签，表强调
            i是一个纯样式的标签，表斜体
            HTML5中i不推荐使用
        5.语义化的意义是什么？
            开发者更容易理解HTML文档
            机器容易理解结构（搜索引擎，读屏软件）
            有助于SEO（搜索引擎优化）
            semantic microdata
        6.那些元素可以自闭和？
            (自闭和在HTML和HTML5中是没有要求一定要加'/'的，但是在XHTML要求加'/'，注意区分)
            表单元素input
            图片img
            换行br
            分割线hr
            meta
            link
        7.HTML和DOM的关系
            DOM全称为The Document Object Model，应该理解为是一个规范，定义了HTML和XML文档的逻辑结构和文档操作的编程接口。
            HTML是死的，HTML文档需要浏览器进行解析成DOM，JS维护的是DOM
            我们用JavaScript对网页（HTML）进行的所有操作都是通过DOM进行的。DOM属于浏览器，而不是JavaScript语言规范里的规定的核心内容，所以如果你下载一个JavaScript语言的参考帮助文档来查的话，就连妇孺皆知的document.write方法也找不到。
        8.property和attribute的区别
            写在HTML中的是attribute,它是死的
            HTML经过解析之后，每个DOM元素都有一个property特性，它是活的
        9.form的作用有哪些？
            直接提交表单
            可以使用submit/reset按钮
            便于浏览器保存表单
            第三方库可以直接整体提取表单值（JQuey的alert($("form").serialize());）
            第三方库可以进行表单验证

二.CSS（Cascading Style Sheet层叠样式表）[1]
    浏览器的解析css选择器的顺序，从右往左解析，使解析能更快速的匹配到HTML元素，提升css解析性能
        选择器分类
            元素选择器 a{}
            伪元素选择器 ::before{}
            类选择器 .link{}
            属性选择器 [type="radio"]{}
            伪类选择器 :hover{}
            ID选择器 #id{}
            组合选择器 [type="checkbox"]+label{}
            否定选择器 :not(){}
            通用选择器 *{}
    1.简单选择器
        .标签选择器（元素选择器） p{font-size:12px;color:#ffffff}
        .类选择器 .font18px{font-size:18px;}
        .指定类选择器 p.font18px{font-size:18px;}
        .ID选择器 #box{width:200px;height:auto;}
        .指定ID选择器 div#box{width:200px;height:auto;}
        .通配选择器 *{margin:0;padding:0;}
    2.复合选择器
        .子选择器 div>span{font-size:18px;} 父级选择名 子选择标识符 子级选择符名 {属性：属性值；}
        .相邻选择器 div+span{font-size:18px;}
        .包含选择器 div span{font-size:18px;}
        .多层选择器嵌套 div p span{font-size:18px;}
        .属性选择器 
            匹配属性值选择器 div[id="header"]{font-size:18px;}
            匹配多个属性选择器 div[ID][class]{font-size:18px;}
        .伪类选择器和伪元素选择器
        （伪类是元素的一种转态，比如hover）
            a:link{color:#FF0000;} /*正常链接状态下样式*/
            a:visited{color:#0000FF;} /*被访问之后的样式*/
            a:hover{color:#00FF00;} /*鼠标经过时的样式*/
            a:active{color:#F0F0F0;} /*超链接被激活时的样式*/
            CSS3新增选择器：伪元素选择器
            （伪元素是页面中真实存在的元素）
                ::first-letter 第一个字
                ::first-line 第一行（以浏览器为准的第一行）
                ::selection 被选中的字行（鼠标选中的字段）只能向 ::selection 选择器应用少量 CSS 属性：color、background、cursor 以及 outline。
                ::before 和 ::after
                    1. 必须带一个属性content
                    2.在内部内容的前面或者后面插入内容
                    HTML：
                        <div>必须带一个属性content</div>
                    css：
                        div::before 
                        {
                            content: "我是插入的内容";
                            background: #572eb8;
                        }
                    3.当插入的内容定义宽高和其他属性时，其实就是一个盒子（必须通过display转换，因为默认是一个行内元素）。
                        HTML：
                            <body>
                                <div>盒子1</div>
                            </body>
                        css：
                            div{
                                width: 500px;
                                height: 500px;
                                border: 1px solid #000;
                            }
                            div::before{
                                content: "插入的盒子";
                                display: block;
                                width: 200px;
                                height: 200px;
                                background: rgb(211, 29, 29);
                            }
        .否定选择器
            :not(){}表示否定选择器
                input:not([type="submit"]){
                    border:1px solid:red;
                } 在表单设计中，为form中的所有input添加border边框样式，但是又不希望提交按钮添加样式，此时就可以使用:not()选择器
    3.选择器权重
        1.ID选择器 #id{} +100
        2.类 属性 伪类选择器 +10
        3.元素 伪元素 +1
        4.其他选择器 +0

        !important优先级最高
            eg:
            .test{
                color:red!important;
            }
        元素属性 优先级高（写在HTML文档里的style属性里的样式权重高于写在外部样式表里的样式权重）
        相同权重 后写的生效
    4.非布局样式
        .字体、字重、颜色、大小、行高
            字体族（font-family）
            字体族不是一个特定的字体，所以在样式表中不应该用引号。
                衬线字体：serif(比如宋体)
                无衬线字体：sans-serif（比如黑体）
                草体：cursive（比如手写体）
                奇异字体：fantasy（比如花体）
                等宽字体：monospace（比如代码字体）
                p{
                    font-family:"Times New Roman",Timers,serif;
                }
            多字体（fallback）
                p{
                    font-family:"monaco","PingFang SC";
                }
            网络字体，自定义字体
                @font-face{
                    font-family="IF";   /*为调用的字体命名字体族*/
                    src:url("./IndieFlower.ttf");
                }
                .custom-font{
                    font-family:IF;
                }
                调用自定义字体或者网络字体
                <link rel="stylesheet" href="http://www.xxx.com/xxx.css"/>
                也可以link远程网站的css文件，他会提供一些不错的字体
            iconfont 
            行高的构成
                行高”顾名思意指一行文字的高度。具体来说是指两行文字间基线之间的距离。基线实在英文字母中用到的一个概念，我们刚学英语的时使用的那个英语本子每行有四条线，其中底部第二条线就是基线，是a,c,z,x等字母的底边线。每个字符都有基线，底线，顶线，撑开高度的是line-height而不是内容，默认状态下一行文本都是按照base line（基线）对齐的，而在同一行的不同大小的一组字，他们的盒子高度是由这一行中line-height最大的撑起的。即line-height会撑起line-box的高度，但是并不会影响他本身布局的高度
                    所以：行高是由linebox决定的，linebox是由inlinebox组成的，所以inlinebox的高度会决定行高的高度,字体背景是根据字体大小来进行渲染的，而不是行高。写一个垂直居中，只需要写line-height即可，把line-height设置为你需要的box的大小可以实现单行文字的垂直居中
                vertical-align中有top,middle,baseline,bottom与之是由关联的，通过设置vertical-align:middle/baseline/bottom/top;可以实现不同方式的对齐。其中top对齐是按照文字的顶线对齐而不是文字的顶对齐，注意区别。也可以设置vertical-align:5px;等通过像素改变对齐方式，但是不推荐，因为这样的对齐方式适应性很差，如果改变字体大小，那么就又没有对齐了。
                line-height 属性设置行间的距离（行高）。
                可能的值
                    normal默认。设置合理的行间距。
                    number设置数字，此数字会与当前的字体尺寸相乘来设置行间距。
                    ength设置固定的行间距。
                    %基于当前字体尺寸的百分比行间距。
                    inherit规定应该从父元素继承 line-height 属性的值。
            <!DOCTYPE html>
            <html>
                <head>
                    <meta charset="UTF-8"/>
                    <meta name="viewport" content="width=device-width,initial-scalable=1.0"/>
                    <meta http-equiv="X-UA-Compatible" content="ie=edge">
                    <title>inline</title>
                    <style>
                        span{
                            background:red;
                        }
                        .c1{
                            line-height:20px;
                        }
                        .c2{
                            line-height:12px;
                        }
                        .c3{
                            line-height:30px;
                        }
                        .c5{
                            line-height:25px;
                        }
                </style>
                </head>
                <body>
                    <div>
                        <span class="c1">inline box xfg中文</span>
                        <span class="c2">inline box</span>
                        <span class="c3">inline box</span>
                        inline box
                        <span class="c5">inline box</span>
                    </div>
                </body>
            </html>
                

            行高相关的现象和方案
                3px图片缝隙问题：
                    img默认也是一个inline元素，他也要遵守行高的构成，它的对齐方式也是默认baseline，就意味着在基线和底线之间还是有一段空隙的，就出现了3px像素的间隙
                解决方法：
                    通过vertical-align:bottom;设置图片按底线对齐就可以消除间隙；
                    通过设置图片的排列方式为block,让图片不要按照inline排列。display:block;这样图片就会单独成行。
            <!DOCTYPE html>
            <html>
                <head>
                    <meta charset="UTF-8"/>
                    <meta name="viewport" content="width=device-width,initial-scalable=1.0"/>
                    <meta http-equiv="X-UA-Compatible" content="ie=edge">
                    <title>inline</title>
                    <style>
                        .cc1{
                            font-size:12px;
                        }
                        .cc2{
                            font-size:18px;
                        }
                        .cc3{
                            font-size:30px;
                        }
                </style>
                </head>
                <body>
                    <div style="border:solid 1px red;">
                        <span style="background:blue;color:#fff;font-size:20px;line-height:60px;">
                            居中
                            xfg&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
                        </span>
                    <div class="c1">
                        <span class="cc1">第一段</span>
                        <span class="cc2">第二段</span>
                        <span class="cc3">第三段</span>
                    </div>
                    <div style="background:red">
                        <span>文字</span>
                        <img src="https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=8a8bd9935e43fbf2c579ae25804ee6b8/6f061d950a7b02083723c37a6fd9f2d3562cc847.jpg">
                    </div>
                    <div>
                        <div style="float:left">
                            <span>第一段</span>
                        </div>
                        <div style="float:left">
                            <span>第二段</span>
                        </div>
                    </div>
                </body>
            </html>

            行高的调整
                
        .背景、边框
            背景颜色
                .c1{
                    height:9px;
                    background:#F00;    
                    background:hsla(0,100%,50%,0.3); /*色相，饱和度，亮度,透明度*/
                    background:rgba(2,55,2,0.2); /*r g b a*/
                    background:url(./test.png); /*设置背景图*/
                }
            渐变色背景
                .c2{
                    height:9px;
                    background:-webkit-linear-gradient(left,red,green); /*设置从左往右的从红色到绿色的线性渐变*/ /*比较老的写法*/
                    background:linear-gradient(to right,red,green); /*设置从左往右的从红色到绿色的线性渐变*/ /*较新的写法*/
                    background:linear-gradient(45deg,red,green); /*设置45度的从左下角往右上角的渐变*/
                    background:linear-gradient(135deg,red 0,green 50%,blue 100%); /*设置135度的，并且规定各个位置的颜色的线性渐变*/
                }
            多背景叠加
                .c3{
                    background:linear-gradient(135edg,transparent 0,transparent 49.5%,green 49.5%,green 50%,transparent 50.5%,transparent 100%) linear-gradient(45edg,transparent 0,transparent 49.5%,red 49.5%,green 50%,transparent 50.5%,transparent 100%);
                    background.size:30px 30px;
                }

            背景图片和属性（雪碧图）
                .c1{
                    height:90px;
                    background:red url(./test.png); /*注意背景色和背景图的叠加是不需要逗号分隔的，直接空格就行*/
                    background-repeat:no-repeat; /*默认背景图片都是平铺的，通过设置background的repeat属性为no-repeat就可以设置为单张图片显示而不是平铺出多张图片排满backgroud,也可以设置repeat-x/repeat-y改变平铺的方向（横向平铺或者纵向平铺）*/
                    background-position:center center; /*设置背景图的位置 center，top，buttom还有具体的像素*/
                    background-size:100px 50px; /*指定背景图尺寸*/
                }
                使用雪碧图的优点有以下几点：
                    .将多张图片合并到一张图片中，可以减小图片的总大小
                    .将多张图片合并到一张图片后，只需一次网络请求就可以将所需的资源全部下载，减小建立连接的消耗，减少http的请求，在移动端尤为明显
                雪碧图的制作与使用方法：
                    使用图像编辑软件如Photoshop将多张图放到同一个图层并导出或使用自动化构建工具自动拼接合并后的图片
                    引用图片时，图片地址为合并后的图片地址，通过background-position调整背景图的位置，并通过容器的宽高共同作用，来选出所需的图片
            base64和性能优化
                Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，可用于在HTTP环境下传递较长的标识信息
                <img src="data:image/gif;base64,R0lGODlhAwADAIABAL6+vv///yH5BAEAAAEALAAAAAADAAMAAAIDjA9WADs=" />
                base64:URL传输图片文件的好处在于：
                    1.减少了HTTP请求
                    2.某些文件可以避免跨域的问题
                    3.没有图片更新要重新上传，还要清理缓存的问题
                不足在于：
                    1.浏览器支持
                    2.增加了CSS文件的尺寸
                    3.编码成本
            多分辨率适配
            边框
                边框的属性：线型 大小 颜色
                    .c1{
                        width:400px;
                        height:200px;
                        border:1px solid red; /*边框线型：solid dotted dashed*/
                    }
                边框背景图
                    .c2{
                        width:400px;
                        height:200px;
                        border:30px solid transparent;
                        border-image:url(./test.png) 30;
                        border-image:url(./test.png) 30 repeat/round; /*设置背景图片的拼接方式*/
                    }
                边框衔接（三角形）
                    .c3{
                        width:400px;
                        height:200px;
                        border-bottom:30px solid red;
                        border-right:30px solid green; /*在两个边的交界处以三角形斜切的方式衔接*/
                    }
        .滚动、换行
            滚动行为和滚动条
            overflow:
                visible
                    内容大于容器时直接把内容显示出来
                hidden
                    内容大于容器时掩藏多余的内容
                scroll
                    内容大于容器时以滚动条显示，滚动条一直存在，无论内容是否超出容器
                auto
                    只在内容超出容器时才显示滚动条
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <meta http-equiv="X-UA-Compatible" content="ie=edge">
                    <title>Document</title>
                    <style>
                        .c1{
                            background: red;
                            height: 200px;
                            overflow: auto;
                        }
                    </style>
                    </head>
                <body>
                    <div class="c1">
                        <p>段落</p>
                        <p>段落</p>
                        <p>段落</p>
                        <p>段落</p>
                        <p>段落</p>
                        <p>段落</p>
                        <p>段落</p>
                        <p>段落</p>
                        <p>段落</p>
                        <p>段落</p>
                    </div>
                </body>
            </html>
            文字折行
                .overflow-wrap（新规范叫法）(word-wrap（旧规范中叫法）)通用换行控制
                    是否换行，是否保留单词
                .Word-break针对多字节文字
                    中文也是单词
                .white-space空白处是否换行
                <!DOCTYPE html>
                <html lang="en">
                <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta http-equiv="X-UA-Compatible" content="ie=edge">
                <title>Document</title>
                <style>
                    .c1{
                        border: 1px solid;
                        width:8em;  /*设置宽度8个字符*/
                        overflow-wrap: normal;  /*他设置的是你要不要尽量保持单词，默认是要的即normal；他也有不保持单词（break-Word），此时他会将超出容器范围的长单词进行折行，这种情况下他仍然会尽量保持单词的完整性*/
                        word-break: normal;     /*normal（不打断单词）kepp-all(保持所有单词，一串中文也会被当成一个单词，不换行)break-all（打断所有单词，超出容器宽度就打断，不把单词当做一个单位）*/
                        white-space: normal;    /*normal（正常换行）nowrap(不换行)*/
                    }
                </style>
                </head>
                <body>
                    <div class="c1">
                        Lorem ipsum dolor sitametconsecteturadipisicing elit. Eum sunt, voluptates est rerum cum neque 还是你啥副科级.
                    </div>
                </body>
                </html>
        .粗体、斜体、下划线
            字重（粗体）font-weight (normal【正常】,bold【粗体】,bolder【加粗体】,lighter【细体】;100px~900px的整百像素)
            斜体 font-style:itatic
            下划线 text-decoration
            指针 cursor
        .其他
    CSS Hack
        (在一部分浏览器生效的css，hack：不合法但是生效的写法，主要用于区分不同的浏览器，难理解，难维护，易失效)
    demo1.html:(见文件)
    案列tree,.html 
    user-select CSS属性，控制着用户能否选中文本。除了在文本框里，它在chrome浏览器中对已加载的文本没有影响。
        /* Keyword values */
        user-select: none;
        user-select: auto;
        user-select: text;
        user-select: contain;
        user-select: all;

        /* Global values */
        user-select: inherit;
        user-select: initial;
        user-select: unset;

        /* Mozilla-specific values */
        -moz-user-select: none;
        -moz-user-select: text;
        -moz-user-select: all;

        /* WebKit-specific values */
        -webkit-user-select: none;
        -webkit-user-select: text;
        -webkit-user-select: all; /* Doesn't work in Safari;                                use only
                                    "none" or "text", or else it will
                                    allow typing in the <html> container */

        /* Microsoft-specific values */
        -ms-user-select: none;
        -ms-user-select: text;
        -ms-user-select: element;
            eg:
                <p>你应该可以选中这段文本。</p>
                <p class="unselectable">嗨，你不能选中这段文本!</p>
                .unselectable {
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                user-select: none;
                }
        none
            元素及其子元素的文本不可选中。 请注意这个Selection 对象可以包含这些元素。 从Firefox 21开始， none 表现的像 -moz-none，因此可以使用 -moz-user-select: text 在子元素上重新启用选择。
        auto
            auto的计算值确定如下：
            在 ::before 和 ::after 伪元素上，计算属性是 none
            如果元素是可编辑元素，则计算值是 contain
            否则，如果此元素的父元素的 user-select 的计算值为 all, 计算值则为 all
            否则，如果此元素的父级上的 user-select 的计算值为 none, 计算值则为 none
            否则，计算值则为 text
        text
            用户可以选择文本。
        -moz-none 
            元素和子元素的文本将显示为无法选择它们。 请注意， Selection 对象可以包含这些元素。 可以使用 -moz-user-select: text. 在子元素上重新启用选择。 从Firefox 21开始，none 表现得像 -moz-none.
        all
            在一个HTML编辑器中，当双击子元素或者上下文时，那么包含该子元素的最顶层元素也会被选中。
        contain
            element (IE-specific alias)
            允许选择在元素内开始; 但是，选择将包含在该元素的边界内。 仅在Internet Explorer中受支持。
        一、伪元素:before和:after用法
            这个两个伪元素在真正页面元素内部之前和之后添加新内容（当然了，可以对伪元素应用定位可以置于任何位置）。可以用以下例子来说明：

                <p>wonyun!</p>
                <style>
                    p:before{content: "hello "}
                    p:after{content: "you are handsome!"}
                </style>
            上面例子从技术角度看，等价于下面的html结构：

                <p>
                    <span>hello </span>
                    wonyun!
                    <span> you are handsome!</span>
                </p>
            由此可知：伪元素:before和:after添加的内容默认是inline元素；这个两个伪元素的content属性，表示伪元素的内容,设置:before和:after时必须设置其content属性，否则伪元素就不起作用。那么问题来了，content属性的值可以有哪些内容呢，具体有以下几种情况：

            字符串，字符串作为伪元素的内容添加到主元素中

            注意：字符串中若有html字符串，添加到主元素后不会进行html转义，也不会转化为真正的html内容显示，而是会原样输出

            attr(attr_name), 伪元素的内容跟主元素的某个属性值进行关联，及其内容为主元素的某指定属性的值

            好处：可以通过js动态改变主元素的指定属性值，这时伪元素的内容也会跟着改变，可以实现某些特殊效果，如图片加载失败用一段文字替换。

            url()/uri(), 引用外部资源，例如图片；

            counter(), 调用计数器，可以不使用列表元素实现序号问题。

            二、:before和:after特点
            上面说了，伪元素是通过样式来达到元素效果的，也就是说伪元素不占用dom元素节点，引用:before,:after伪元素妙用里面总结的，:before和:after伪元素的主要特点如下：

            伪元素不属于文档，所以js无法操作它

            伪元素属于主元素的一部分，因此点击伪元素触发的是主元素的click事件

            原文说块级元素才能有:before, :after，其实是不妥的，大部分行级元素也可以设置伪元素，但是像img可替换元素，因为其外观和尺寸有外部资源决定，那么如果外部资源正确加载，就会替换掉其内部内容，这时伪元素也会被替换掉，但是当外部资源加载失败时，设置的伪元素是可以起作用的。

            基于伪元素的特点可以知道其优缺点，也引用别人文章的话：

            优点

            减少dom节点数
            让css帮助解决部分js问题，让问题变得简单
            缺点

            不利于SEO(搜索引擎优化)
            无法审查元素，不利于调试
    面试真题
        1.css样式（选择器的优先级）
            权重计算确定
            !important
            内联样式
            后写的生效
        2.雪碧图的作用
            减少http请求数 提高加载性能
            有些情况下可以减少图片大小
        3.自定义字体的使用场景
            1.宣传、品牌、banner等固定文案
            2.字体图标
        4.base64的使用
            减少http请求数
            适用于小图片
            base64的体积会变为原图的4/3
        5.伪类和伪元素的区别
            伪类表状态：
            伪元素是真的存在的元素：：
        6.如何美化CheckBox
            label[for]和id
            掩藏原生的input
            css 里:checked+label设置行为样式

三.CSS（Cascading Style Sheet层叠样式表）[2]
    CSS布局
        css知识体系的重中之重
        早期以table为主（简单）
        后来以技巧性布局为主（难）
        现在有flebox/grid（偏简单）
        响应式布局是必备知识
        注意：设置文字居中对齐时，一定要设置line-height=content（内容区）的高度，然后text-align=center;
            text-align: center;
            line-height:30px;
        .盒子模型
            content->padding->border->margin  由内到外
            content（内容区）->padding(内容和边框之间的留白区)->border（边框，边框本身也是占据空间的）->margin（它离别的元素或者他的父级元素的距离）----盒子占用的空间=content+padding+border
            宽度（width）和高度（height）默认只对内容区（content）生效
            top、margin-top的区别：
                1、top、bottom、left、right是绝对定位，必须设置position为absolute。 margin一系列设置是相对定位。注意：如果用top等，而position未设置为absolute，那设置是不起作用的。
                2、top这些在绝对定位的前提下，这个绝对定位，是相对body  或者  position：relative的父级元素的绝对定位。margin的相对定位，是指相对相邻元素的定位。
            padding指内边距，是盒子里面内容到边框的距离，不允许使用负值。
            padding:10px 5px; 上内边距和下内边距是10px，右内边距和左内边距是5px。
            padding:1px 2px 3px 4px; (上右下左)
            padding:10px; 所有4个内边距都是10px。
            margin指外边距，是边框到外部另一元素之间的距离，允许使用负值。
            margin:10px 5px 15px 20px;(上右下左)
            margin:10px 5px; 上外边距和下外边距是10px，右外边距和左外边距是5px。
            margin:10px; 所有4个外边距都是10px。
                margin-block-start CSS 属性定义了一个元素的逻辑块的开始边距, 是用来根据元素的书写模式，方向和文本方向进行实际边界的衡量。
                /* <length> values */
                margin-block-start: 10px;  /* 绝对长度 */
                margin-block-start: 1em;   /* 文本的相对大小 */
                margin-block-start: 5%;    /* 相对于最近块容器的大小 */

                /* 关键字值 */
                margin-block-start: auto;

                /* 全局值 */
                margin-block-start: inherit;
                margin-block-start: initial;
                margin-block-start: unset
        .display/position
            确定元素的显示类型
                display:
                    block 块级元素，它是有独立宽高的，默认情况下会占据一行
                    inline  内联元素，他和文本一样，默认不会占据一行，inline元素是不能设置宽高的，可以通过设置vertical-align:top/middle/bottom来设置和其他同行元素的对齐方式
                    inline-block  行内块级元素，对内表现得像一个block一样，有独立宽高，对外表现得像一个inline，即可以和其它元素排在同一行，可以通过设置vertical-align:top/middle/bottom来设置和其他同行元素的对齐方式
            确定元素的位置
                position：
                   static:  静态位置（默认），按照文档流进行布局
                   relative:  相对位置，relative的偏移是相对于元素本身的，偏移的时候不会改变它占据的空间，不会因为偏移而改变布局的计算。
                   .p2{
                       position:relative;
                       left:10px;
                       top:-10px;
                   }    /*表示元素p2采用relative布局，偏移量，离原始左边10px，离原始位置顶部偏移-10px*/
                   absolute： 绝对位置，一旦设置布局为absolute，他就从文档流中脱离了，也就是说他不会对其他元素布局产生影响，
                        .p3{
                            position:absolute;
                            left:80px;
                            top:60px;
                        }   /*该布局的定位不一定是相对于body的，它相对的是最近的relative或者absolute，即相对的是它的父级relative或者absolute元素定位，没有就一直往上找，直到相对于body定位*/
                   fixed： 固定位置，它也是脱离文档流的，也不会对其他元素的布局造成影响，它是相对于屏幕或者说它是相对于可视区域进行定位的。
                层叠问题（前后）：   
                    设置Z-index：1/2...; 谁的数值高，谁就覆盖，或者说谁就在屏幕前显示，比如说需要设置一个遮罩，希望覆盖屏幕上所有元素，则可以设置为9999或者99999这样比较大的数值
                        什么样的元素可以设置z-index？
                            定位为fixed、absolute、relative的元素可以设置。

    常用布局方法
        .table 表格布局
            <!--
                其实将以下代码与传统<table>布局的代码一对比，可以看出，变化之处就是：
                    替换掉<table>的<main>有了一个“display:table”样式
                    替换掉<tr>的<section>有了一个“display:table-row”样式
                    替换掉<td>的<aside>和<article>分别有了一个“display:table-cell”样式。
                    用CSS来替代<table>进行“表格布局”的思路是基本一致的，只是进一步将页面的结构与表现分离开来，这样做最大的好处就是可以使HTML标签尽量做到“语义化”。
            -->
            <!DOCTYPE html>
            <html lang="en">
            <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>test</title>
            <style>
                /*表格元素实现表格布局*/
                table{
                    width: 300px;
                    height: 100px;
                    border-collapse: collapse;
                }
                .left{
                    background-color: aqua;
                    width:300px;
                    height: 100px;
                }
                .right{
                    background-color:blueviolet;
                    width:300px;
                    height: 100px;
                }
                /*非表格元素实现表格布局*/
                .table{
                    margin-top: 0px;
                    display: table;
                    width: 300px;
                    height: 100px;
                    vertical-align: middle;
                }
                .table-row{
                    display: table-row;
                }
                .table-cell{
                    vertical-align: middle;
                    display: table-cell;
                }

            </style>
            </head>
            <body>
                <!--使用表格元素实现表格布局-->
                <table>
                    <tr>
                        <td class="left">left_table_cell</td>
                        <td class="right">right_table_cell</td>
                    </tr>
                </table>
                <br>
                <!--使用非表格元素实现表格布局-->
                <div class="table">
                    <div class="table-row">
                        <div class="left table-cell">left_table_cell</div>
                        <div class="right table-cell">right_table_cell</div>
                    </div>
                </div>
            </body>
            </html>
        .float浮动+margin
            多用于做图文混排，文字环绕效果
            元素浮动
            脱离文档流:
                不会对其他元素的布局造成影响
            但是不脱离文本流
                影响其他块级元素的文本
            对自身的影响：
                形成“块”（BFC）
                位置默认尽量靠上
                位置尽量靠左（右）：float: left/right;
                    folat块在小于容器宽度的时候，float会尽量往上靠，在容器宽度不足够大的时候float会往下掉，尽量往左靠（或者尽量往右靠）
            对兄弟元素的影响
                上面贴非float元素
                旁边贴float元素
                不影响其他块级元素的位置（脱离文档流）
                影响其他块级元素的文本（不脱离文本流）
            对父级元素的影响
                从父级布局上消失
                父级元素高度塌陷
            清除浮动：
                1.让父元素接管自己的宽高
                    为父元素加一个Overflow:auto;/*当他里面的东西超出的时候自动进行滚动*/
                2.额外添加一个元素来撑起父级元素
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <meta http-equiv="X-UA-Compatible" content="ie=edge">
                    <title>Document</title>
                    <style>
                        .container{
                            background-color: rgb(0, 83, 63);
                            width: 400px;
                            color: white;
                        }
                        .p1{
                            background-color: rgb(83, 0, 39);
                            float: left;
                            width: 200px;
                            height: 50px;
                            /*span元素属于inline元素，原本是不能设置宽高的，但是因为float为span生成了一个块（BFC），块级元素是可以设置宽高的。*/
                        }

                        /*比较经典的清除浮动的方式*/
                        .container2::after{
                            content: 'aaa';
                            clear: both;/*保证这个content元素的左右两边都是干净的，没有浮动元素，此时他就只能在浮动元素的下方*/
                            display: block; 
                            height: 0;
                            visibility: hidden;
                        }
                    </style>
                </head>
                <body>
                    <div class="container">
                        <span class="p1">
                            float
                        </span>
                        <div class="p2">
                            很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的文字
                        </div>
                    </div>

                    <div class="container container2">
                        <span>写几个字</span>
                        <span class="p1">
                            float
                        </span>
                        <span class="p1">
                                float
                        </span>
                    </div>
                    <div class="container" style="height: 200px;background-color: rgb(30, 83, 0);">
                        <p>001</p>
                        <span>001</span>
                        <p>001</p>
                        <span>001</span>
                    </div>
                </body>
                </html>
            float布局demo:
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <meta http-equiv="X-UA-Compatible" content="ie=edge">
                    <title>Document</title>
                    <style>
                        /*浮动式布局，左边浮动，给右边的元素加margin-left: 200px（这里的像素点值为左边浮动块的宽度）;*/
                        .container{
                            width:800px;
                            height: 120px;
                        }
                        .left{
                            background-color: rgb(86, 214, 92);
                            float: left;
                            height:100%;
                            width:200px;
                        }
                        .right{
                            background-color: rgb(214, 86, 86);
                            float: left;
                            width: 200px;
                            height:100%;
                        }
                        .right2{
                            background-color: rgb(86, 199, 214);
                            float:right;
                            width: 200px;
                            height:100%;
                        }
                        .right3{
                            background-color: rgb(214, 86, 193);
                            float: right;
                            height:100%;
                            width: 200px;
                        }

                        /*实现3栏浮动布局：
                        .left{
                            background-color: rgb(86, 214, 92);
                            float: left;
                            height:100%;
                            width:200px;
                        }
                        .middle{
                        background-color: rgb(86, 214, 92);
                            margin-left:200px;
                            margin-right:200px;
                            height:100%;
                            width:200px;     
                        }
                        .right{
                            background-color: rgb(214, 86, 193);
                            float: right;
                            height:100%;
                            width: 200px;
                        }
                        */
                    </style>
                </head>
                <body>
                    <div class="container">    
                        <div class="left">左</div> 
                        <div class="right">右</div>
                        <div class="right3">右右右</div>
                        <div class="right2">右右</div> 
                    </div>
                </body>
                </html>
        .inline-block布局
            像文本一样排版block元素
            没有清除浮动等问题
            但是需要清除间隙
                /*如何屏蔽inline-block之间的间隙？方法：将父级元素的字体大小设为0*/
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta http-equiv="X-UA-Compatible" content="ie=edge">
                <title>Document</title>
                <style>
                    /*如何屏蔽inline-block之间的间隙？方法：将父级元素的字体大小设为0，然后在里面的inline-block元素里将字体大小设回来*/
                    .container{
                        width: 800px;
                        height: 200px;
                        font-size:0;
                    }
                    .left{
                        color:rgb(238, 253, 253);
                        font-size:14px;
                        background-color: rgb(172, 95, 95);
                        display:inline-block;
                        width:200px;
                        height: 200px;
                    }
                    .right{
                        color:rgb(238, 253, 253);
                        font-size:14px;
                        background-color: rgb(95, 163, 172);
                        display:inline-block;
                        width:600px;
                        height: 200px; 
                    }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="left">左边元素</div>
                    <div class="right">右边元素</div>
                </div>
            </body>
            </html>
        .flexbox布局
            .弹性盒子
            .盒子本来就是并列的
            .指定宽度即可
            注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。
            容器的属性
                以下6个属性设置在容器上。
                    flex-direction
                    flex-wrap
                    flex-flow
                    justify-content
                    align-items
                    align-content
                flex-direction属性
                    flex-direction属性决定主轴的方向（即项目的排列方向）。
                    它可能有4个值。
                        row（默认值）：主轴为水平方向，起点在左端。
                        row-reverse：主轴为水平方向，起点在右端。
                        column：主轴为垂直方向，起点在上沿。
                        column-reverse：主轴为垂直方向，起点在下沿。
                flex-wrap属性
                    默认情况下，项目都排在一条线（又称"轴线"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。
                    它可能取三个值。
                        （1）nowrap（默认）：不换行。
                        （2）wrap：换行，第一行在上方。
                        （3）wrap-reverse：换行，第一行在下方。
                flex-flow
                    flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
                justify-content属性
                    justify-content属性定义了项目在主轴上的对齐方式。
                    它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。
                        flex-start（默认值）：左对齐
                        flex-end：右对齐
                        center： 居中
                        space-between：两端对齐，项目之间的间隔都相等。
                        space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。   
                align-items属性
                    align-items属性定义项目在交叉轴上如何对齐。
                    它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。
                        flex-start：交叉轴的起点对齐。
                        flex-end：交叉轴的终点对齐。
                        center：交叉轴的中点对齐。
                        baseline: 项目的第一行文字的基线对齐。
                        stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
                align-content属性
                    align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
                    该属性可能取6个值。
                        flex-start：与交叉轴的起点对齐。
                        flex-end：与交叉轴的终点对齐。
                        center：与交叉轴的中点对齐。
                        space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
                        space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
                        stretch（默认值）：轴线占满整个交叉轴。
            项目的属性
                以下6个属性设置在项目上。
                    order
                    flex-grow
                    flex-shrink
                    flex-basis
                    flex
                    align-self
                order属性
                    order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
                flex-grow属性
                    flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
                    如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
                flex-shrink属性
                    flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
                    如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。
                flex-basis属性
                    flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
                    它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。
                flex属性
                    flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
                    该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。
                align-self属性
                    align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
                    该属性可能取6个值，除了auto，其他都与align-items属性完全一致。
                
            <!DOCTYPE html>
            <html lang="en">
            <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>Document</title>
            <style>
                .contaniner{
                width: 1100px;
                height: 300px;
                display: flex;
                border:1px solid rgb(5, 40, 56);
            }
            .flex{
                background-color: rgb(6, 127, 184);
                margin: 5px;
                flex: 1; /*通过设置flex的值来规定该元素占据多少份布局*/
                /*如果我想让一个元素固定宽度，写法
            .flex{
                width:180px;
                flex:none; //只需要写入你想规定的宽度，然后flex属性设置为none即可
            }
                */
            }
            .flex2{
                background-color: rgb(6, 127, 184);
                margin: 5px;
                flex:2;
            }
            .flex3{
                background-color: rgb(8, 158, 101);
                margin: 5px;
                flex:3;
            }
            .flex4{
                background-color: rgb(21, 184, 6);
                margin: 5px;
                flex:1;
            }
            .flex5{
                background-color: rgb(95, 2, 114);
                margin: 5px;
                flex:1;
            }
            .flex6{
                background-color: rgb(184, 6, 110);
                margin: 5px;
                width:100px;
                flex:none;
            }
            </style>
            </head>
            <body>
                <div class="contaniner">
                    <div class="flex">
                        flex布局
                    </div>
                    <div class="flex2">
                        flex布局
                    </div>
                    <div class="flex3">
                        flex布局
                    </div>
                    <div class="flex4">
                        flex布局
                    </div>
                    <div class="flex5">
                        flex布局
                    </div>
                    <div class="flex6">
                        flex布局
                    </div>
                </div>
            </body>
            </html>
四.CSS（Cascading Style Sheet层叠样式表）[3]
    响应式设计和布局
        .让页面在不同设备上正常使用
        .一般主要处理屏幕大小的问题
        .主要方法
            .隐藏+折行+自适应空间
            .rem(通过HTML字体大小来确定元素大小的方法)/viewport（）/media query（媒体查询）
            通过掩藏的方法来处理响应式内容（media query（媒体查询））：
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <meta http-equiv="X-UA-Compatible" content="ie=edge">
                    <title>Document</title>
                    <style>
                        .container{
                            margin:auto;
                            max-width: 880px;
                            display:flex;
                            border:1px solid rgb(48, 5, 105);
                        }
                        .left{
                            color:rgb(238, 253, 253);
                            font-size:14px;
                            background-color: rgb(172, 95, 95);
                            display: flex;
                            flex: 1;
                            width:200px;
                            margin:5px;
                        }
                        /*通过掩藏的方法来处理响应式内容，使用媒体查询（media query)，他可以根据一些硬件的不同情况来写不同的样式，这里设置了一个max-width：640px,意思是这段样式只有在小于等于640个像素的设备宽度上才会生效，在这个样式上我们重新给.left写一个样式.left{
                                display: none;
                            }*/
                        @media (max-width: 640px){
                            .left{
                                display: none;
                            }
                        }
                        .right{
                            color:rgb(238, 253, 253);
                            font-size:14px;
                            background-color: rgb(95, 170, 172);
                            display: flex;
                            flex:3;
                            width:200px;
                            margin:5px; 
                        }
                    </style>
                </head>
                <body>
                    <div class="container">
                        <div class="left">这里是一些不重要的内容，比如友情链接，广告</div>
                        <div class="right">这里是一些重要内容，比如一篇文章，文章是整个页面的核心，这里是一些重要内容</div>
                    </div>
                </body>
                </html>
                折行的方式来实现响应式布局（将横向排列的设置为纵向排列）：
                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <meta http-equiv="X-UA-Compatible" content="ie=edge">
                        <title>Document</title>
                        <style>
                            .container{
                                margin:0 auto;
                                max-width: 800px;
                                border:1px solid rgb(5, 105, 97);
                            }
                            .intro{
                                color:white;
                                background-color: rgb(5, 105, 97);
                                display:inline-block;
                                width:180px;
                                height: 180px;
                                line-height: 100px;
                                text-align: center;
                                border-radius: 90px;
                                border:1px solid rgb(3, 56, 52);
                                margin:7px;
                            }
                            @media (max-width:640px){
                                .intro{
                                    margin:7px auto;
                                    display:block;
                                }
                            }
                        </style>
                    </head>
                    <body>
                        <div class="container">
                            <!--类似特性介绍的一个页面-->
                            <div class="intro">介绍001</div>
                            <div class="intro">介绍002</div>
                            <div class="intro">介绍003</div>
                            <div class="intro">介绍004</div>
                        </div>
                    </body>
                    </html>
                使用rem来进行多设备页面适配：
                    在样式表中：
                        html{
                            font-size:16px;(HTML元素默认是16个像素，一个rem就表示这样一个16个像素，这样我们在用px的时候就可以将px换成rem单位来表示，当然，16个像素并不太好计算，在实际使用中，经常设font-size:10px;即一个rem就是10个px)
                        }
                        然后可以多写几个media query,该变html的font-size的值即可，来适配更多屏幕
                        @media (max-width:640px){
                            html{
                                font-size:40px;
                            }
                        }
                        @media (max-width:568px){
                            html{
                                font-size:30px;
                            }
                        }
                        @media (max-width:375px){
                            html{
                                font-size:20px;
                            }
                        }
                        @media (max-width:320px){
                            html{
                                font-size:10px;
                            }
                        }
                        /*注意在写media query的时候，要把大的通配范围写在上面，rem的单位不一定精确，对于精确性十分高的项目里，不应该使用rem*/
    面试真题：
        1.实现两栏（三栏）布局的方法？
           1.表格布局；
           2.float+margin布局
           3.inline-block布局
           4.flex-box布局  
        2.position:absolute/fixed有什么区别？
           absolute是相对于最近的absolute/relative来进行参照定位 
           fixed是相对于屏幕（viewport）来进行定位 
        3.display:inline-block之间为什么会有间隙以及怎么处理?
           原因：HTML有一些空白字符（字符间距）
           解决:消灭空白字符（把标签直接写到一起，中间不要留空白或者使用注释连接2个标签<!---->)
                消灭字符间距(将父级容器字体大小设为0，让他不要占据空间，在元素里在单独设置字体样式)   
        4.如何清除浮动？为什么需要清除浮动？
            这是因为浮动元素不会占据父级元素的布局空间，父级元素在布局的时候不会管浮动元素，这样就会导致浮动元素超出父元素，从而对其他元素产生影响。所以，你作为一个父级元素，一定要清除浮动，保证对外是无毒无害的。
            清除方法：
                .让盒子负责自己的布局。overflow:hidden/auto;
                .添加一个元素，放到浮动元素的后面，让父元素一定要包含浮动元素。::afer{clear:both;}
        5.如何适配移动端的页面？
            1.将页面的viewport进行适配。
            2.rem/viewport/media query
            3.在设计上：掩藏，折行，留下自适应空间

五.CSS（Cascading Style Sheet层叠样式表）[4]
    效果属性（这个效果怎么实现？）
    box-shadow(投影)
        box-shadow:64px(必需。水平阴影的位置。允许负值。) 64px(必需。垂直阴影的位置。允许负值。) 24px(可选。模糊距离，模糊值) 40px(可选。阴影的尺寸,扩展) rgba(0,0,0,0.5)(可选。阴影的颜色。请参阅 CSS 颜色值。),12px 12px0px 18px rgba(0,0,0,0.3)inset(可选。将外部阴影 (outset) 改为内部阴影);
    text-shadow(文本投影)
        h1
        {
            text-shadow: 5px 5px 5px #FF0000;/*水平阴影、垂直阴影、模糊距离，以及阴影的颜色*/
        }
    border-radius(圆角)
        圆角矩形
        圆形
        半圆/扇形
        奇怪的图形
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>Document</title>
            <style>
                .container{
                    width:100px;
                    height: 100px;
                    background-color: rgb(33, 122, 81);
                    border-radius: 10px;
                    border-radius: 50%;
                    /* border: 50px solid rgb(187, 52, 52); */
                    /* border-top-left-radius: 10px 200px;
                    border-top-right-radius: 50%;
                    border-bottom-left-radius: 50%;
                    border-bottom-right-radius: 50%; */
                    border-radius: 30px 30px 10px 10px/20px 30px 40px 50px;
                    /*按此顺序设置每个 radii 的四个值。如果省略 bottom-left，则与 top-right 相同。如果省略 bottom-right，则与 top-left 相同。如果省略 top-right，则与 top-left 相同。
                    border-radius: 2em 1em 4em / 0.5em 3em;
                    等价于
                    border-top-left-radius: 2em 0.5em;
                    border-top-right-radius: 1em 3em;
                    border-bottom-right-radius: 4em 0.5em;
                    border-bottom-left-radius: 1em 3em;
                    */
                }
            </style>
        </head>
        <body>
            <div class="container">
            </div>
        </body>
        </html>
    background(背景)
        纹理、图案
        渐变
        雪碧图动画
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>Document</title>
            <style>
                .i{
                    width: 16px;
                    height: 16px;
                    background: url(../png/lian.png) no-repeat;
                    background-size: 16px 40px;
                    transition: background-position 0.3s;
                }
                .i:hover{
                    background-position :0 -22px;
                }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="i"></div>
            </div>
        </body>
        </html>
    背景图尺寸适应
        background-position:center center;
            可能的值：（如果您仅规定了一个关键词，那么第二个值将是"center"。默认值：0% 0%。）
                top left
                top center
                top right
                center left
                center center
                center right
                bottom left
                bottom center
                bottom right
                x% y% （第一个值是水平位置，第二个值是垂直位置。左上角是 0% 0%。右下角是 100% 100%。如果您仅规定了一个值，另一个值将是 50%。）
                xpos ypos（第一个值是水平位置，第二个值是垂直位置。左上角是 0 0。单位是像素 (0px 0px) 或任何其他的 CSS 单位。如果您仅规定了一个值，另一个值将是50%。您可以混合使用 % 和 position 值。）
        background-repeat:repeat-x/repeat-y/no-repeat;
        background-size: length|percentage|cover|contain;
            （length）设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 "auto"
            （percentage）以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 "auto"。  
             (cover)覆盖整个画面同时保持长宽比不变把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。 
            （contain）把背景图完整的显示出来，把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域.
    clip-path(修剪路径)
        对容器进行裁剪
        常见的集合图形
        自定义路径裁剪
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>Document</title>
            <style>
                .container{
                    width:800px;
                    height: 520px;
                    border:1px solid rgba(0, 0, 0, 0.315);
                    background: url(../png/test.jpg);
                    background-size: contain;
                    background-repeat: no-repeat;
                    background-position: center center;
                    padding:10px;
                    /* clip-path: inset(100px 50px); 矩形裁剪 */
                    clip-path: circle(100px); /*  圆形裁剪 */
                    /* clip-path: polygon(90% 8%,35% 23%,17% 79%,48% 72%); 多边形裁剪 */
                    transition:clip-path 0.4s;
                    /* clip-path: url(#clippath); */
                }
                .container:hover{
                    clip-path: circle(400px)
                }
            </style>
        </head>
        <body>
            <div class="container">
            </div>
            <svg>
                <defs>
                    <clippath id="clippath">
                        <circle cx="60" cy="60" r="250" fill="rgb(255,255,255)"></circle>
                    </clippath>
                </defs>
            </svg>
        </body>
        </html>
    3d变换
       translate (位移)
       scale (缩放)
       skew (斜切，拉伸)
       rotate (旋转)
       [3D盒子demo]
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=dege">
            <title>Document</title>
            <style>
                .container{
                    margin: 50px;
                    padding: 10px;
                    width:300px;
                    height: 300px;
                    border: 1px solid rgb(14, 185, 100);
                    position: relative;
                    perspective: 1500px; /*透视距离*/
                }
                #cube{
                    width: 300px;
                    height: 300px;
                    transform-style: preserve-3d;
                    transform: translateZ(-400px) rotateY(20deg) rotateX(20deg) rotateZ(20deg);
                    transition: transform 2s;
                }
                #cube div{
                    color: rgba(255, 255, 255, 0.575);
                    width: 300px;
                    height: 300px;
                    position: absolute;
                    line-height: 300px;
                    font-size: 100px;
                    text-align: center;
                }
                #cube:hover{
                    transform: translateZ(100px) rotateY(300deg);
                }
                .front{
                    transform: translateZ(150px);
                    background-color: rgba(185, 14, 71, 0.219);
                }
                .back{
                    transform: translateZ(-150px) rotateY(-180deg);
                    background: rgba(136, 10, 98, 0.363);
                }
                .left{
                    transform: translateX(-150px) rotateY(-90deg);
                    background: rgba(136, 134, 10, 0.295);
                }
                .right{
                    transform: translateX(150px) rotateY(90deg);
                    background: rgba(44, 10, 136, 0.329);
                }
                .top{
                    transform: translateY(-150px) rotateX(-90deg);
                    background: rgba(10, 107, 136, 0.329);
                }
                .bottom{
                    transform: translateY(150px) rotateX(90deg);
                    background: rgba(10, 136, 94, 0.329);
                }
            </style>
        </head>
        <body>
            <div class="container">
                <!--定义一个立方体的包裹容器-->
                <div id="cube">
                    <!--立方体的6个面-->
                    <div class="front">1</div>
                    <div class="back">2</div>
                    <div class="left">3</div>
                    <div class="right">4</div>
                    <div class="top">5</div>
                    <div class="bottom">6</div>
                </div>    
            </div>
        </body>
        </html>
    面试真题：
        如何用一个div画xxx
            box-shadow无限投影
            ::before
            ::after
        如何产生不占空间的边框
            1.box-shadow
            2.outline。
        如何实现圆形元素（头像）
            border-radius
        如何实现iOS图标圆角
            clip-path:(svg)
        如何实现半圆、扇形等图形
            border-radius组合
            有无边框
            边框粗细
            圆角半径
        如何实现背景图居中、不显示、不重复、改变大小
            background-position
            background-repeat
            background-size(cover/contain)
        如何平移、放大一个元素？
            transform:translateX/Y/Z(100px)
            transform:scale(2);
        如何实现3D效果？
            perspective:500px;/*设置透视*/
            transform-style:preserve-3d;    /*设置变换风格保留为3d*/
            transform:translate rotate;(对具体元素做位移和旋转变换)
六.CSS（Cascading Style Sheet层叠样式表）[5]
    css 鼠标的5种状态
          1、a:link{color:#fff}  未访问时的状态（鼠标点击前显示的状态）
          2、a:hover{color:#fff}  鼠标悬停时的状态
          3、a:visited{color:#fff}  已访问过的状态（鼠标点击后的状态）
          4、a:active{color:#fff}  鼠标点击时的状态
          5、a:focus{color:#fff}  点击后鼠标移开保持鼠标点击时的状态（只有在<a href="#"></a>时标签中有效
    css动画
        动画原理：
            视觉暂留作用
    CSS中的动画类型
        transition补间动画
            位移-平移
                （left/right/margin/transform）
            方位-旋转（transform）
            大小-缩放（transform）
            透明度（opacity)
            其他-线性变换（transform）
            transition 属性是一个简写属性，用于设置四个过渡属性：
                transition-property 规定设置过渡效果的 CSS 属性的名称。
                transition-duration 规定完成过渡效果需要多少秒或毫秒。
                transition-timing-function  规定速度效果的速度曲线。
                transition-delay    定义过渡效果何时开始。
            transition: property duration timing-function delay;

        keyframe关键帧动画
            与元素状态的变化无关
            定义更加灵活
            @keyframes 规则，您能够创建动画。
            创建动画的原理是，将一套 CSS 样式逐渐变化为另一套样式。
            在动画过程中，您能够多次改变这套 CSS 样式。
            以百分比来规定改变发生的时间，或者通过关键词 "from" 和 "to"，等价于 0% 和 100%。
            0% 是动画的开始时间，100% 动画的结束时间。
            为了获得最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。
            @keyframes animationname {
                keyframes-selector {css-styles;}
                }
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta http-equiv="X-UA-Compatible" content="ie=edge">
                <title>Document</title>
                <style>
                    .container{
                        width:200px;
                        height: 100px;
                        background: rgb(15, 33, 36);
                        animation: run 1s linear; /*一个线性的动画。可以指定动画类型*/
                        animation-direction:alternate-reverse; /*指定播放动画的反向（进度正向还是反向播放）*/
                        animation-fill-mode:forwards;   /*决定动画最后停在哪里*/
                        animation-iteration-count: infinite; /*循环的次数，这里为无限循环 */
                        /*animation-play-state: paused; /*指定动画播放状态（播放或者暂停）*/
                    }
                    @keyframes run{
                        0%{
                            width:100px;
                        }/*0%也可以写成from*/
                        /*动画中间还可以添加更多状态关键帧*/
                        100%{
                            width: 800px;
                        }/*100%也可以写成to*/
                    }
                </style>
            </head>
            <body>
                <div class="container">

                </div>
            </body>
            </html>
        
        逐帧动画 
            适用于无法补间计算的动画
            动画资源较大（图片）
            使用steps()
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta http-equiv="X-UA-Compatible" content="ie=edge">
                <title>Document</title>
                <style>
                    .container{
                        width:100px;
                        height: 111px;
                        border:1px solid rgb(62, 61, 75);
                        background: url(../png/序列帧.jpg) no-repeat;
                        animation: run 1s infinite; 
                        animation-timing-function: steps(1);
                        /*这里设置的steps是作用于关键帧之间有几个动画过度，设置为1了以后就表示不需要系统为我们设置过度，就只显示我们自己的关键帧动画就可以*/
                    }
                    /*下面使用雪碧图来制作关键帧动画*/
                    @keyframes run{
                        0%{
                            background-position: 0 0;
                        }
                        6.6%{
                            background-position: -100px 0;
                        }
                        13.2%{
                            background-position: -200px 0;
                        }
                        19.8%{
                            background-position: -300px 0;
                        }
                        26.4%{
                            background-position: -400px 0;
                        }
                        33%{
                            background-position: 0 -111px;
                        }
                        39.6%{
                            background-position: -100px -111px;
                        }
                        46.2%{
                            background-position: -200px -111px;
                        }
                        52.8%{
                            background-position: -300px -111px;
                        }
                        59.4%{
                            background-position: -400px -111px;
                        }
                        66%{
                            background-position: 0 -222px;
                        }
                        72.6%{
                            background-position: -100px -222px;
                        }
                        79.2%{
                            background-position: -200px -222px;
                        }
                        85.8%{
                            background-position: -300px -222px;
                        }
                        92.4%{
                            background-position: -400px -222px;
                        }
                        100%{
                            background-position: 0 0;
                        }
                    }
                </style>
            </head>
            <body>
                <div class="container">

                </div>
            </body>
            </html>
    面试真题：
        css动画的实现方式    
            transition
            keyframes(animation) 注：逐帧动画也是关键帧动画，他只是去除了逐帧动画里的补间动画
        过度动画和关键帧动画的区别
            过渡动画需要有状态的变化
            关键帧动画不需要有状态变化
            关键帧动画能控制得更精细
        如何实现逐帧动画
            使用关键帧动画
            去掉补间（steps(1);）
        css动画的性能
            1.性能不坏
            2.部分情况下优于JS
            3.但JS可以做得更好
            4.部分高危属性（性能慢）
                box-shadow等;

七.CSS（Cascading Style Sheet层叠样式表）[5]
    HTML&CSS——选择器中间加空格和逗号的区别？
        p span{}选择了P元素下的所有span元素。这是后代选择器，空格是后代选择器的标识符。
        p,span{}选择了P元素和span元素。这是多元素选择器，同时选择多个元素，元素之间用逗号分隔。    
    CSS预处理器
      基于CSS的另一种语言
      通过工具编译成CSS
      添加了很多CSS不具有的特性  
      能提升CSS文件的组织

      常见预处理器
        less
            使用JS编写，编译速度比较快，而且它有一个浏览器中可以直接使用的版本，不需要预先编译，入门相对简单，但是在一些复杂特性方面显得相对繁琐。Less 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。Less 可以运行在 Node、浏览器和 Rhino 平台上。网上有很多第三方工具帮助你编译 Less 源码。
        sass（scss（新版名称））
            使用ruby编写，编译过程相对较慢
        CSS预处理器到底提供了那些功能？
            嵌套 反映层级和对选择器进行约束
            变量和计算 减少重复代码
            Extend和Mixin代码片段
            循环 适用于复杂有规律的样式（循环是CSS完全不具备的）
            import CSS文件模块化

            安装less编译工具/安装sass编译工具
            安装Esay-less和Esay-sass插件（vcode）,ctrl+s保存编译.less或者.scss为.css文件。
            注：xxx.less代码编译之后的css文件名默认xxx.css。
            而xxx.scss编译之后默认会产生2个css文件，一个是:compressed - 压缩格式的css文件，输出文件名默认为xxx.min.css；还有一个是打平嵌套结构的:expanded - 展开格式的css文件，输出文件名默认为xxx.css;
                备注：Sass编译输出的CSS格式可以自定义。有4种输出格式：
                    :nested - 嵌套格式
                    :expanded - 展开格式
                    :compact - 紧凑格式 
                    :compressed - 压缩格式（压缩格式占用尽可能少的空间，选择符定义不换行，文件最小，一般用于生产版本。）
        嵌套
            嵌套选择器 &，css 预处理器里&的用法
                a, b {
                    & c { color: blue; }
                }
                /* 等价于 */
                a c,
                b c { color: blue; 
                }
            less（xxx.less）
                .body{
                    padding: 0;
                    margin:0;
                }

                .wrappeer{
                    background: white;

                    .nav{
                        font-size: 24px;
                    }

                    .content{
                        font-size: 30px;
                        /*&符号相当于平级关系，表示直接接在选择器后面的*/
                        &:hover{
                            background: red;
                        }
                    }
                }
            less编译后的css代码
                .body {
                padding: 0;
                margin: 0;
                }
                .wrappeer {
                background: white;
                }
                .wrappeer .nav {
                font-size: 24px;
                }
                .wrappeer .content {
                font-size: 30px;
                /*&符号相当于平级关系*/
                }
                .wrappeer .content:hover {
                background: red;
                }
            同样的样式用sass写(xxx.scss)
                可以看出来，sass与less的语法很大程度上是一样的
                body{
                    padding:0;
                    margin:0;
                }

                .wrapper{
                    background: white;

                    .nav{
                        font-size: 24px;
                    }

                    .container{
                        font-size: 30px;

                        &:hover{
                            background: red;
                        }
                    }
                    
                }
            sass编译成css文件（压缩格式）
                body{padding:0;margin:0}.wrapper{background:white}.wrapper .nav{font-size:24px}.wrapper .container{font-size:30px}.wrapper .container:hover{background:red}
        变量
            变量为什么会存在，就是为了避免让我们重复写一些相同的值，同时变量也意味着它们能参与一些运算，比如典型的，关于字体大小，关于背景颜色等等这些你都能定义变量，然后在下面通过变量的方式来进行引用。这样的话，如果你只是需要修改或者微调，只需要与这个变量产生关系就OK了。
            less
                /*变量的定义是带单位的，运算时也是带单位进行运算的*/
                @fontsize:24px; /*定义变量使用@,定义字体大小变量*/
                @bgcolor:red;   /*定义背景颜色变量*/

                .body{
                    padding: 0;
                    margin:0;
                }

                .wrappeer{
                    background:lighten(@bgcolor,40%); 
                    /*less为我们提供了很多颜色函数，进行颜色相关的运算，比如lighten()让这个颜色变浅,注意参数之间要有逗号隔开*/

                    .nav{
                        font-size: @fontsize;
                    }

                    .content{
                        font-size: @fontsize+10px; /*这里字体直接运算，要注意带单位进行运算，因为定义的变量也是带单位的*/
                        /*&符号相当于平级关系*/
                        &:hover{
                            font-size:@fontsize;
                        }
                    }
                }
                xxx.css 
                    /*定义变量使用@,定义字体大小变量*/
                    /*定义背景颜色变量*/
                    .body {
                    padding: 0;
                    margin: 0;
                    }
                    .wrappeer {
                    background: #ffcccc;
                    /*less为我们提供了很多颜色函数，进行颜色相关的运算，比如lighten()让这个颜色变浅,注意参数之间要有逗号隔开*/
                    }
                    .wrappeer .nav {
                    font-size: 24px;
                    }
                    .wrappeer .content {
                    font-size: 34px;
                    /*这里字体直接运算，要注意带单位进行运算，因为定义的变量也是带单位的*/
                    /*&符号相当于平级关系*/
                    }
                    .wrappeer .content:hover {
                    font-size: 24px;
                    }
            xxx.sass
                /*sass定义变量用 $ 符号，也是带单位定义和计算的*/
                $fontsize:24px;
                $bgcolor:green;

                body{
                    padding:0;
                    margin:0;
                }

                .wrapper{
                    background: $bgcolor;

                    .nav{
                        font-size: $fontsize;
                    }

                    .container{
                        font-size: $fontsize+10px;

                        &:hover{
                            background: lighten($color: $bgcolor, $amount: 45%);
                        }
                    }
                    
                }
            xxx.css(:expanded - 展开格式)
                @charset "UTF-8";
                /*sass定义变量用 $ 符号，也是带单位定义和计算的*/
                body {
                padding: 0;
                margin: 0;
                }

                .wrapper {
                background: green;
                }

                .wrapper .nav {
                font-size: 24px;
                }

                .wrapper .container {
                font-size: 34px;
                }

                .wrapper .container:hover {
                background: #67ff67;
                }  
        Mixin（样式复用）：
            sass中mixin强制要求显式声明格式，注意名字前面没有点 @mixin name($形参){}；这点与less不同，less可以直接 .classname（@形参）{}即可，less既是一个class，又是一个mixin，同时sass的mixin用法也不一样，需要显式@include name()调用。
            less 
                @fontsize:24px; /*定义变量使用@,定义字体大小变量*/
                @bgcolor:rgb(196, 0, 59);   /*定义背景颜色变量*/

                .body{
                    padding: 0;
                    margin:0;
                }

                /*类似于声明了一个函数块,函数名就是.block,带有两个形参(@font--size,@bg--color)，实现了样式的复用*/
                .block(@font--size,@bg--color){
                    font-size: @font--size;
                    background-color: @bg--color;
                }

                .wrappeer{
                    .nav{
                        .block(@fontsize, @bgcolor);
                    }

                    .content{
                        .block(@fontsize+10px, lighten(@bgcolor,40%));
                        &:hover{
                            .block(@fontsize+20px, lighten(@bgcolor,80%))
                        }
                    }
                }   
            xxx.css
                /*定义变量使用@,定义字体大小变量*/
                /*定义背景颜色变量*/
                .body {
                padding: 0;
                margin: 0;
                }
                /*类似于声明了一个函数块,函数名就是.block,带有两个形参(@font--size,@bg--color)，实现了样式的复用*/
                .wrappeer .nav {
                font-size: 24px;
                background-color: #c4003b;
                }
                .wrappeer .content {
                font-size: 34px;
                background-color: #ff91b2;
                }
                .wrappeer .content:hover {
                font-size: 44px;
                background-color: #ffffff;
                }  
            sass
                /*sass定义变量用 $ 符号，也是带单位定义和计算的*/
                $fontsize:24px;
                $bgcolor:green;
                $degree:65deg;      /*定义一个角度*/

                body{
                    padding:0;
                    margin:0;
                }

                /*sass中mixin强制要求显式声明格式，注意名字前面没有点 @mixin name($形参){}；这点与less不同，less可以直接 .classname（@形参）{}即可，less既是一个class，又是一个mixin*/
                @mixin block($font--size,$bg--color){
                    font-size: $font--size;
                    background-color: $bg--color;
                    border:1px solid #ddaafc;
                    border-radius:5px;
                }

                .wrapper{
                    /*同时sass的mixin用法也不一样，需要显式@include name();*/
                    .nav{
                        @include block($fontsize,$bgcolor);
                    }

                    .container{
                        @include block($fontsize+10px, $bgcolor);

                        &:hover{
                        @include block($fontsize+15px,adjust-hue($bgcolor,$degree));
                        }
                    }
                    
                }
            xxx.min.css
                body{padding:0;margin:0}.wrapper .nav{font-size:24px;background-color:green;border:1px solid #ddaafc;border-radius:5px}.wrapper .container{font-size:34px;background-color:green;border:1px solid #ddaafc;border-radius:5px}.wrapper .container:hover{font-size:39px;background-color:#007580;border:1px solid #ddaafc;border-radius:5px}
        extend：（样式复用）
            其实，反观上面使用mixin生成的css代码,生成的代码中有非常多的重复代码，这种结果如果是手写css的话，这种结果是完全不能接受的。因为会有非常多的重复代码。extend就是为解决这样的问题而生的。解决重复代码问题，减少 css 体积。不同之处在于，mixin 是把代码直接复制过来，extend 是把选择器提取出来，把公共样式写到一起编译成 css
            less
                @fontsize:24px; /*定义变量使用@,定义字体大小变量*/
                @bgcolor:rgb(196, 0, 59);   /*定义背景颜色变量*/

                .body{
                    padding: 0;
                    margin:0;
                }
                /*extend它是扩展某一个选择器，所以在这里就不加参数了，而是一个标准的选择器*/
                .block{
                    font-size: @fontsize;
                    background-color: @bgcolor;
                    border:1px solid #259980;
                    border-radius:5px;
                }
                /*extend写法1：在选择器后面+:extend(.选择器)；*/
                /*extend写法2：在选择器的内容里+&:extend(.选择器)；看自己怎么方便怎么用，2者之间完全等价*/
                .wrappeer{   
                    .nav:extend(.block){
                        color:#992548;
                    }
                    .content{
                        &:extend(.block);
                        &:hover{
                            &:extend(.block);
                        }
                    }
                }
            编译后.css
                /*定义变量使用@,定义字体大小变量*/
                /*定义背景颜色变量*/
                .body {
                padding: 0;
                margin: 0;
                }
                /*extend它是扩展某一个选择器，所以在这里就不加参数了，而是一个标准的选择器*/
                .block,
                .wrappeer .nav,
                .wrappeer .content,
                .wrappeer .content:hover {
                font-size: 24px;
                background-color: #c4003b;
                border: 1px solid #259980;
                border-radius: 5px;
                }
                /*extend写法1：在选择器后面+:extend(.选择器)；*/
                /*extend写法2：在选择器的内容里+&:extend(.选择器)；看自己怎么方便怎么用，2者之间完全等价*/
                .wrappeer .nav {
                color: #992548;
                }
            sass
                /*sass定义变量用 $ 符号，也是带单位定义和计算的*/
                $fontsize:24px;
                $bgcolor:green;
                $degree:65deg;      /*定义一个角度*/

                body{
                    padding:0;
                    margin:0;
                }
                .block{
                    font-size: $fontsize;
                    background-color: $bgcolor;
                    border:1px solid #ddaafc;
                    border-radius:5px;
                }
                /*注意：在sass中，调用extend没有在选择器后面加：的调用方法，自有在样式里+@extend .选择器;这一种调用方法，这点与less有所区别*/
                .wrapper{
                    color:#334444;
                    .nav{
                        @extend .block;
                        color:#666;
                    }

                    .container{
                        @extend .block;

                        &:hover{
                        @extend .block;
                        }
                    }
                    
                }
            编译后.css
                @charset "UTF-8";
                /*sass定义变量用 $ 符号，也是带单位定义和计算的*/
                /*定义一个角度*/
                body {
                padding: 0;
                margin: 0;
                }

                .block, .wrapper .nav, .wrapper .container, .wrapper .container:hover {
                font-size: 24px;
                background-color: green;
                border: 1px solid #ddaafc;
                border-radius: 5px;
                }

                /*注意：在sass中，调用extend没有在选择器后面加：的调用方法，自有在样式里+@extend .选择器;这一种调用方法，这点与less有所区别*/
                .wrapper {
                color: #334444;
                }

                .wrapper .nav {
                color: #666;
                }
            关于mixin和extend
                @extend命令不够灵活。不能向它传递参数，它原本是啥样就是啥样。这里还有一些在@media中使用@extend的限制，比如，不能横跨多个@media指令使用@extend。

                还有一个重要的问题就是@extend增加了选择器之间的联系。当你正在为一些相关的元素设置样式，就拿一组按钮来说，使用@extend让他们共享样式看起来合情合理。但是如果这些被复用的样式片段并不仅仅局限于相关的元素，那么使用@mixin或许更好。

                @mixin主要的优势就是它能够接受参数。如果想传递参数，你会很自然地选择@mixin而不是@extend。

                如果没有任何参数，使用@extend来创造DRY应该是个不错的选择。不过要注意的是，使用gzip压缩过的文件可能会破坏代码中的DRY。

                当文件很小的时候，编译完成代码中有重复的片段并不是一件坏事。不过如果源文件中存在这样的重复片段，会使得代码很难维护。使用@mixin会减少编译后文件中DRY式的代码。但是，如果gzip的算法对重复片段的优化工作做得比较好，那么编译后的代码不会变得肿胀。

                @mixin会更强大，更灵活，它与gzip的组合跟@extend的主要优势相比，一点都不会逊色。

                原文: https://www.w3cplus.com/preprocessor/sass-mixin-or-extend.html © w3cplus.com

        loop循环
            Less
                /*关于循环，首先我们需要定义一个mixin，.gen-col(@n)
                    然后我们要给这个mixin一个出口 when (@n>0)。注意：不管你是循环还是递归你都要给她一个出口，如果不给，他将会变成一个死循环，这里表示n要大于0，当n小于等于0，循环结束
                    注意：@{n} 这个实际上得到的是n的值，在这里是序号1-12
                    因为less不支持循环，所以只能用递归来做*/
                    .gen-col(@n) when (@n>0){
                        .gen-col(@n - 1);
                        .col-@{n}{
                            width:1200px/12*@n;
                        }
                    }
                    /*上面定义了mixin在这里只需要调用mixin，再把参数传递进去就OK了*/
                    .gen-col(12);
                    编译后.css
                        .col-1 {
                        width: 100px;
                        }
                        .col-2 {
                        width: 200px;
                        }
                        .col-3 {
                        width: 300px;
                        }
                        .col-4 {
                        width: 400px;
                        }
                        .col-5 {
                        width: 500px;
                        }
                        .col-6 {
                        width: 600px;
                        }
                        .col-7 {
                        width: 700px;
                        }
                        .col-8 {
                        width: 800px;
                        }
                        .col-9 {
                        width: 900px;
                        }
                        .col-10 {
                        width: 1000px;
                        }
                        .col-11 {
                        width: 1100px;
                        }
                        .col-12 {
                        width: 1200px;
                        }
                sass
                    /*这里将mixin改成了sass中定义mxin的方法，@mixin ，变量也用sass的变量符号$.
                    还有就是他的循环条件是写在mixin里面的，if。而less是写在外面，mixin名后面，使用when.
                    调用他自己的mixin，生成一组.col-n的class样式。
                    注意less和sass的后标生成方式不一样，less是@{n},而sass是#{$n}，注意两者的区别*/
                    @mixin gen-col($n){
                        @if $n > 0{
                            @include gen-col($n - 1);
                            .col-#{$n}{
                                widows: 1200px/12*$n;
                            }
                        }  
                    }

                    @include gen-col(12); 
                    编译后的.css 
                         .col-1 {
                        widows: 100px;
                        }

                        .col-2 {
                        widows: 200px;
                        }

                        .col-3 {
                        widows: 300px;
                        }

                        .col-4 {
                        widows: 400px;
                        }

                        .col-5 {
                        widows: 500px;
                        }

                        .col-6 {
                        widows: 600px;
                        }

                        .col-7 {
                        widows: 700px;
                        }

                        .col-8 {
                        widows: 800px;
                        }

                        .col-9 {
                        widows: 900px;
                        }

                        .col-10 {
                        widows: 1000px;
                        }

                        .col-11 {
                        widows: 1100px;
                        }

                        .col-12 {
                        widows: 1200px;
                        }
                
                    /*上面的方法在sass里其实是比较蠢的，因为sass是支持for循环的,less是不支持的，所以只能用mixin的方式去递归*/
                    /*sass 使用for循环进行loop*/
                        @for $i from 1 through 12{
                            .coll-#{$i}{
                                height: 1200px/12*$i;
                            }
                        }
                    编译后结果.css
                       .coll-1 {
                        height: 100px;
                        }

                        .coll-2 {
                        height: 200px;
                        }

                        .coll-3 {
                        height: 300px;
                        }

                        .coll-4 {
                        height: 400px;
                        }

                        .coll-5 {
                        height: 500px;
                        }

                        .coll-6 {
                        height: 600px;
                        }

                        .coll-7 {
                        height: 700px;
                        }

                        .coll-8 {
                        height: 800px;
                        }

                        .coll-9 {
                        height: 900px;
                        }

                        .coll-10 {
                        height: 1000px;
                        }

                        .coll-11 {
                        height: 1100px;
                        }

                        .coll-12 {
                        height: 1200px;
                        }  
        预处理器是怎样处理模块化的问题的
            注：预处理器的变量是可以跨文件使用的,@import "est/all";引入所有的est less文件，这里引用所有和部分引用有什么区别吗？其实并没有，因为less/sass是按需引用的，用到什么他就编译什么。
            所谓的模块化，就是把我们的代码分成一个一个的模块。
            @import 对于模块化开发来说非常有帮助，但就这个功能来说，三种预处理器的行为各不相同。

            先说 Less，Less 扩展了语法，为 @import 增加了多种选项：

                @import (less) somefile.ext
                    会将无论什么扩展名的文件都作为 Less 文件引入、一起编译；

                @import (css) somefile.ext
                    直接编译生成 @import somefile.ext，当做原生 @import；

                @import (inline) somefile.ext
                    直接将外部文件拷贝进输出文件的这个位置，但不会参与编译；

                @import (reference) somefile.ext
                    外部文件参与编译，但不输出内容，仅用来被本文件中的样式继承；

                @import (optional) somefile.ext
                    引入文件但在文件不存在时不报错，静默失败。

                上面的选项是可以联合使用的，比如可以这样写：

                    @import (less, optional) somefile.ext;
                除此之外还有 once 和 multiple 选项分别用来表示去重和不去重的引入方式，默认为 once。在不写任何选项时，Less 会根据扩展名进行推断来决定引入逻辑。                  eg:
                    【1 import-main.less】
                        @import "./varible.less";   
                        @import "./module1.less";
                        @import "./module2.less";

                        /*通过import的方式将这些模块引用进来，在编译的时候，再编译在一起，最后产生的是一整个css文件。这样就解决了css文件太细碎之后加载的性能问题*/

                        /*可以根据具体的项目，将自己的css文件组织得非常清晰*/
                        /*
                        @import "./logo.less";
                        @import "./header.less";
                        @import "./nav.less";
                        @import "./article.less";
                        @import "./dialog.less";
                        @import "./foot.less";
                        等等
                        */ 
                    [2 varible.less] 
                        @themColor:rgb(255, 0, 98);
                        @fontSize:24px; 
                    [3 module1.less]
                        .module1{
                            .box{
                                font-size:@fontSize+2px;
                                color:@themColor;
                            }
                            .tips{
                                font-size:@fontSize;
                                color:lighten(@themColor,66%);
                            }
                        }
                    [4 module2.less]
                        .module2{
                            .box{
                                font-size:@fontSize+24px;
                                color:@themColor;
                            }
                            .tips{
                                font-size:@fontSize+12px;
                                color:lighten(@themColor,36%);
                            }
                        }
                    编译import-main.less文件得到的css文件
                        .module1 .box {
                        font-size: 26px;
                        color: #ff0062;
                        }
                        .module1 .tips {
                        font-size: 24px;
                        color: #ffffff;
                        }
                        .module2 .box {
                        font-size: 48px;
                        color: #ff0062;
                        }
                        .module2 .tips {
                        font-size: 36px;
                        color: #ffb8d3;
                        }
            然后是sass。
                Sass 没有扩展语法，而是自己推断引入的方式。.css 后缀、绝对路径、url() 表达式和带有 media query 的 @import 会直接用原生 @import，其他都会作为 Sass 代码参与编译。相比之下 Less 更灵活也更复杂。Sass 有个特有的功能叫做「partial」，因为 Sass 默认的编译工具可以编译整个目录下的文件，所以当一些文件不需要编译时，可以在文件名前加上 _ 表明这是一个被别的模块引入本身不需要编译的代码片段。Less 的 lessc 由于本来就只处理一个文件，所以这件事就交给用户自己去写编译脚本了。Sass 中有一个比较棘手的问题是，@import 不会被去重，多次引入会导致一个样式文件被多次输出到编译结果中。
                sass的模块化引用和less是大致一样的，也是通过@引用。只需要注意具体模块的变量定义，语法就可以。
                    @import "./varible.less";   
                    @import "./module1.less";
                    @import "./module2.less";
        css预处理器框架
            预处理器为我们带来了使用他人代码的可能性。在css中，如果你需要使用他人的代码，那么你可能只能引用一整套，很不方便。如果你想引用多个来源的代码，将会更加的不方便。此时，预处理器就为我们带来了更人性化的服务，让我们可以按需引用他人代码。就是所谓的css预处理器框架。提供现成的mixin，类似JS类库，封装了常用功能。
            css预处理器框架有哪些？
                sass - Compass
                Less - lesshat/EST
                    伪元素只要没有content，它就不会显示。
                案例见set-triangle-demo.html,est-mainn0.less和est-main0.css。
    面试真题：
        常见的css预处理器
            Less(node.js)
            Sass(ruby和node.js移植版本)
        预处理器的作用
            帮助更好的组织css代码
            提高代码复用率
            提升可维护性
        预处理器的能力
            嵌套 反映层级关系和对选择器进行约束
            变量和计算，减少重复代码
            Extend和Mixin代码片段
            循环 适用于复杂有规律的样式
            import CSS文件模块化
八.CSS（Cascading Style Sheet层叠样式表）[5]
    bootstrap（v4）
        一个css框架，由Twitter出品，提供通用的基础样式。使用sass编写。
        兼容IE 10+
        使用flexbox布局
        抛弃Nomallize.css 
        提供布局和reboot版本
        作用：
            基础样式
            常用组件
            JS插件
        bootstrap JS组件
            用于组件交互
               dropdown(下拉) 
                modal(弹窗)
                .....
            基于jQuery编写的
            同时依赖第三方库Popper.js
                (注意：在bootstrap的js包里，bootstrap已经为我们打包好了Popper，只需要引入bootstrap.bundle.js该Js文件即可)
            需要引入bootstrap.js
            使用方式
                1.基于date-*属性
                2.基于JS API
        bootstrap响应式布局
            
                                    Extra small         Small       Medium      Large       Extra large
                                    <576px	            ≥576px      ≥768px      ≥992px      ≥1200px

            Max container width	    None (auto)	        540px	    720px	    960px	    1140px
            Class prefix	        .col-	            .col-sm-	.col-md-	.col-lg-	.col-xl-
            # of columns	        ----------------------------------12------------------------------
            Gutter width	        --------------30px (15px on each side of a column)----------------
            Nestable	            ---------------------------------Yes------------------------------
            Column ordering	        ---------------------------------Yes------------------------------  

        bootstrap定制方法
            使用css同名类进行覆盖
            修改源码重新构建
            引用scss源文件 修改变量
    面试真题
        Bootstrap优缺点
            优点：
                css代码结构合理，现成的样式可以直接使用，它的网格系统，响应式布局是非常具有借鉴意义的
            缺点：
                定制较为繁琐，体积大
        bootstrap 如何实现响应式布局
            原理：通过media query设置不同分辨率的class
            使用：为不同分辨率寻址不同的网格class 
        如何基于bootstrap定制自己的样式
            使用css同名类进行覆盖
            修改源码重新构建
            引用scss源文件 修改变量
九.css工程化
    组织 优化 构建 维护
    css工程化工具
        PostCSS
            css->PostCSS解析转换(模块化 加前缀 兼容性.....)->CSS
        PostCSS本身只有解析的能力
        各种神奇的特性全靠插件
        目前至少有200多个插件
           常见插件
                .import 模块合并
                .autoprefixier 自动添加前缀 
                .cssnano 压缩代码
                .cssnext 使用CSS新特性
                .precss 变量、mixin、循环等
            使用npm安装：npm install postcss-cli
        PostCSS支持的构建工具
            .cli 命令行工具
            .webpack postcss-loader
            .Gulp gulp-postcss
            .Grunt grunt-postcss
            .Rollup rollup postcss
            ......
        ****
        webpack
            （它是一个模块化打包工具）
            JS是整个应用的核心入口
            一切资源均由JS管理依赖
            一切资源均由webpack打包
十.前端框架中的css
    Angular Vue React 三大框架
    Angular Vue 内置样式集成
    React一些业界实践

    Angular
        Angular.js(v1.x)
            没有样式集成能力
        Angular(v2+)
            提供了样式封装的能力
            与组件深度集成
                ShadowDOM
                    逻辑上一个DoM
                    结构上存在字集结构
                Scoped css
                    限定了范围的css
                    无法影响外部元素
                    外部样式一般不可以影响内部
                    可以通过/deep/或者>>>穿透选择器，进行影响内部样式
            模拟scoped css
            方案一：随机选择器（不支持）
            方案二：随机属性
                <div abcdefg></div>
                div[abcdefg]{}
    Vue
        模拟scoped css
        方案一：随机选择器
            .css modules
        方案二：随机属性
            <div abcdefg></div>
            div[abcdefg]{}

Sass 面试问题
    什么是SASS？
        SASS（Syntactically Awesome Stylesheet）是一个CSS预处理器，有助于减少CSS的重复，节省时间。 它是更稳定和强大的CSS扩展语言，描述文档的样式干净和结构。

    为什么要使用SASS？
        它是预处理语言，它为CSS提供缩进语法（它自己的语法）。

        它允许更有效地编写代码和易于维护。

        它是包含CSS的所有功能的CSS的超集，是一个开源的预处理器，以 Ruby 编码。

        它提供了比平面CSS好的结构格式的文档样式。

        它使用可重复使用的方法，逻辑语句和一些内置函数，如颜色操作，数学和参数列表。

    列出SASS的一些功能？
        它是更稳定，强大，与CSS的版本兼容。

        它是超集的CSS和基于JavaScript。

        它被称为CSS的语法糖，这意味着它使用户更容易阅读或表达的东西更清楚。

        它使用自己的语法并编译为可读的CSS。

        你可以在更少的时间内轻松地编写CSS代码。

        它是一个开源的预处理器，被解释为CSS。

    SASS的优点是什么？
        它允许在编程结构中编写干净的CSS。

        它有助于编写CSS更快。

        它是CSS的超集，帮助设计师和开发人员更有效率和快速地工作。

        由于Sass兼容所有版本的CSS，我们可以使用任何可用的CSS库。

        可以使用嵌套语法和有用的函数，如颜色操作，数学和其他值。

    SASS的缺点是什么？
        开发人员需要时间了解此预处理器中存在的新功能。

        如果更多的人在同一个网站上工作，那么将使用相同的预处理器。 有些人使用Sass，有些人使用CSS直接编辑文件。 因此，它将变得难以与现场工作。

        有机会失去浏览器的内置元素检查器的好处。

    列出SASS支持的两种语法？
        SASS支持两种语法，即 SCSS 和缩进语法。

        SCSS（Sassy CSS）是CSS语法的扩展，可以更容易地维护大型样式表，并且可以识别供应商特定的语法和许多CSS。 SCSS文件使用扩展名 .scss 。

        缩进是较旧的语法，有时仅称为 Sass 。 使用这种形式的语法，可以简洁地编写CSS。 SASS文件使用扩展名 .sass 。

    有多少种方法可以使用SASS？
        您可以使用三种不同的方式使用SASS:

            作为命令行工具

            作为一个Ruby模块

            作为Rack启用框架的插件

    SASS中的嵌套规则是什么？
        嵌套是不同逻辑结构的组合。 使用SASS，我们可以将多个CSS规则相互组合。 如果使用多个选择器，则可以在另一个选择器中使用一个选择器来创建复合选择器。

    如何在SASS中引用父选择器？
        您可以使用＆amp; 字符选择父级选择器。 它告诉父选择器应该插入的位置。

    如何在SASS中写入占位符选择器？
        SASS使用 class 或 id 选择器支持占位符选择器。 在正常CSS中，这些用“＃"或“。"指定，但在SASS中，它们替换为“％"。

    列出SASS上的不同类型的运算符？
        有5种类型的运算符:

            数字运算符

            颜色运算符

            字符串运算符

            布尔运算符

            列表运算符

    什么是数字运算？
        它允许诸如加法，减法，乘法和除法的数学运算。

    什么是彩色运算？
        它允许使用颜色分量和算术运算。

    什么是列表运算？
        列表表示使用逗号或空格分隔的一系列值。

    什么是布尔运算？
        您可以使用and、or和not（与或非）对Sass脚本执行布尔运算。

    SASS中的括号是什么？
        括号是一对标记，通常用圆括号（）或方括号[]来标记，这提供了影响操作顺序的符号逻辑。

    什么是SASS中的插值？
        它使用＃{} 语法提供选择器和属性名称中的SassScript变量。 您可以在花括号中指定变量或属性名称。

    什么是可变默认值？
        您可以通过向变量值的结尾添加！default 标志来设置变量的默认值。如果值已经分配给变量，则不会重新分配该值。

    什么是导入指令？
        它直接采用文件名导入，所有导入的文件将合并到一个单一的CSS文件。

    什么是媒体指令？
        它将样式规则设置为不同的媒体类型。

    什么是扩展指令？
        它用于共享选择器之间的规则和关系。 它可以在一个类中扩展所有其他类样式，也可以应用自己的特定样式。

    什么是根指令？
        它是一个嵌套规则的集合，它能够在文档的根节点创建样式块。

    什么是@if指令？
        它用于基于表达式求值的结果选择性地执行代码语句。

    什么是@else if指令？
        @else if语句与@if指令一起使用，每当@if语句失败，则尝试@else if语句，如果它们也失败，则执行@else。

    什么是@for指令？
        它允许您在循环中生成样式。 计数器变量用于设置每次迭代的输出。

    什么是@each指令？
        在@each指令中，定义了一个包含列表中每个项目的值的变量。

    什么是@mixin指令？
        它用于定义mixin，其中包含可选的mixin名称之后的变量和参数。

    什么是@include指令？
        它用于在文档中包含mixin，由mixin定义的样式可以包含在当前规则中。

    什么是mixin 参数?
        SassScript值可以作为mixin中的参数，当mixin包含并在mixin中作为变量使用时，可以将其作为参数。

    列出两种类型的mixin参数？
        有两种类型的mixin参数:

            关键字参数

            可变参数

    什么是关键字参数？
        它用于在mixin中包含参数。 命名的参数可以按任何顺序传递，参数的默认值可以省略。

    什么是可变参数？
        变量参数用于将任意数量的参数传递给mixin。 它包含传递给函数或mixin的关键字参数。

    什么是函数指令？
        使用函数指令，可以创建自己的函数，并在脚本上下文中使用它们，或者可以使用任何值。

    什么是SASS输出样式？
        SASS生成的CSS文件由反映文档结构的默认CSS样式组成。 默认的CSS样式很好，但可能不适合所有情况。

    什么是嵌套CSS样式？
        嵌套样式是SASS的默认样式。 这种方式的样式在处理大型CSS文件时非常有用。

    什么是扩展CSS样式？
        在扩展输出样式中，每个属性和规则都有自己的线。 与嵌套CSS样式相比，它需要更多的空间。

    什么是紧凑的CSS样式？
        紧凑的CSS风格竞争力比Expanded和Nested占用更少的空间。 它主要关注选择器而不是其属性。

    什么是压缩CSS样式？
        与所有其他样式相比，压缩的CSS样式占用最少的空间。 它仅提供空格，以在文件末尾分隔选择器和换行符。

    SASS缩进语法的主要特点是什么？
        它使用缩进而不是 {和} 来分隔块。

        要分隔语句，它使用换行符而不是分号（;）。

        属性声明和选择器必须放在自己的行上， {和} 中的语句必须放在 >和缩进。

    有多少种方法可以声明CSS属性？
        CSS属性可以通过两种方式声明:

        属性可以声明为类似于CSS但没有分号（;）。

        colon（:）将以每个属性名称为前缀。

    什么是写@mixin和@include指令的速记？
        您可以使用= for @mixin指令和+ for @include指令，这需要更少的键入，使您的代码更简单，更容易阅读。

    每当SASS文件更改时，使用哪个命令来观察文件并更新CSS？
        sass --watch C:\\ ruby \\ lib \\ sass \\ style.scss:style.css

    什么是SASS的注释？
        注释占用整行并包围嵌套在它们下面的所有文本，它们是基于行的缩进语法。

    哪个命令用于从命令行运行SASS代码？
        sass input.scss output.css

    样式表的字符编码的CSS规范是什么？
        首先它检查Unicode字节，下一个 @charset 声明，然后检查Ruby字符串编码。

    接下来，如果未设置任何内容，则会将字符集编码视为。

        使用 @charset 声明显式地确定字符编码。 只需在样式表的开头使用“@charset encoding name"，SASS将假设这是给定的字符编码。

        如果SASS的输出文件包含非ASCII字符，那么它将使用 @charset 声明。

    有多少种注释类型？
        Sass支持两种类型的注释:

            多行注释 - 使用/ *和* /写入。 多行注释保存在CSS输出中。

            单行注释 - 这些是使用 // 和注释写成的。 单行注释不会保留在CSS输出中。

    什么是交互式shell？
        它使用命令行评估SassScript表达式。 您可以使用sass命令行和 - i 选项运行shell。

    什么是@debug指令？
        它检测错误并将SassScript表达式值显示到标准错误输出流。

    什么是@error指令？
        它将SassScript表达式值显示为致命错误。
        
            

            